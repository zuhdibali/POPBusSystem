/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BanksesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBanksForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBanksForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBanksForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBanksForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetBanksForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetBanksForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBanksForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBanksForView(id: number | null | undefined): Observable<GetBanksForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/GetBanksForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBanksForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBanksForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBanksForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBanksForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBanksForView(response: HttpResponseBase): Observable<GetBanksForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBanksForViewDto.fromJS(resultData200) : new GetBanksForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBanksForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBanksForEdit(id: number | null | undefined): Observable<GetBanksForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/GetBanksForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBanksForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBanksForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBanksForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBanksForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBanksForEdit(response: HttpResponseBase): Observable<GetBanksForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBanksForEditOutput.fromJS(resultData200) : new GetBanksForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBanksForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBanksDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getBanksesToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Bankses/GetBanksesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBanksesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBanksesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBanksesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BranchesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Branches/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBranchesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Branches/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBranchesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBranchesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBranchesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetBranchesForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetBranchesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBranchesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBranchesForView(id: number | null | undefined): Observable<GetBranchesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Branches/GetBranchesForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchesForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchesForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBranchesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBranchesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranchesForView(response: HttpResponseBase): Observable<GetBranchesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBranchesForViewDto.fromJS(resultData200) : new GetBranchesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBranchesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBranchesForEdit(id: number | null | undefined): Observable<GetBranchesForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Branches/GetBranchesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBranchesForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBranchesForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranchesForEdit(response: HttpResponseBase): Observable<GetBranchesForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBranchesForEditOutput.fromJS(resultData200) : new GetBranchesForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBranchesForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBranchesDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branches/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branches/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getBranchesToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Branches/GetBranchesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranchesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BusInfosServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param busNumberFilter (optional) 
     * @param busModelFilter (optional) 
     * @param modelFilter (optional) 
     * @param chassisNumberFilter (optional) 
     * @param trackerIEMIFilter (optional) 
     * @param maxInsuPolicyNumberFilter (optional) 
     * @param minInsuPolicyNumberFilter (optional) 
     * @param maxCapcityFilter (optional) 
     * @param minCapcityFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, busNumberFilter: string | null | undefined, busModelFilter: string | null | undefined, modelFilter: string | null | undefined, chassisNumberFilter: string | null | undefined, trackerIEMIFilter: string | null | undefined, maxInsuPolicyNumberFilter: moment.Moment | null | undefined, minInsuPolicyNumberFilter: moment.Moment | null | undefined, maxCapcityFilter: number | null | undefined, minCapcityFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBusInfoForView> {
        let url_ = this.baseUrl + "/api/services/app/BusInfos/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (busNumberFilter !== undefined)
            url_ += "BusNumberFilter=" + encodeURIComponent("" + busNumberFilter) + "&"; 
        if (busModelFilter !== undefined)
            url_ += "BusModelFilter=" + encodeURIComponent("" + busModelFilter) + "&"; 
        if (modelFilter !== undefined)
            url_ += "ModelFilter=" + encodeURIComponent("" + modelFilter) + "&"; 
        if (chassisNumberFilter !== undefined)
            url_ += "ChassisNumberFilter=" + encodeURIComponent("" + chassisNumberFilter) + "&"; 
        if (trackerIEMIFilter !== undefined)
            url_ += "TrackerIEMIFilter=" + encodeURIComponent("" + trackerIEMIFilter) + "&"; 
        if (maxInsuPolicyNumberFilter !== undefined)
            url_ += "MaxInsuPolicyNumberFilter=" + encodeURIComponent(maxInsuPolicyNumberFilter ? "" + maxInsuPolicyNumberFilter.toJSON() : "") + "&"; 
        if (minInsuPolicyNumberFilter !== undefined)
            url_ += "MinInsuPolicyNumberFilter=" + encodeURIComponent(minInsuPolicyNumberFilter ? "" + minInsuPolicyNumberFilter.toJSON() : "") + "&"; 
        if (maxCapcityFilter !== undefined)
            url_ += "MaxCapcityFilter=" + encodeURIComponent("" + maxCapcityFilter) + "&"; 
        if (minCapcityFilter !== undefined)
            url_ += "MinCapcityFilter=" + encodeURIComponent("" + minCapcityFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBusInfoForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBusInfoForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusInfoForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetBusInfoForView.fromJS(resultData200) : new PagedResultDtoOfGetBusInfoForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBusInfoForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusInfoForEdit(id: number | null | undefined): Observable<GetBusInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusInfos/GetBusInfoForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusInfoForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusInfoForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusInfoForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusInfoForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusInfoForEdit(response: HttpResponseBase): Observable<GetBusInfoForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBusInfoForEditOutput.fromJS(resultData200) : new GetBusInfoForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusInfoForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBusInfoDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusInfos/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusInfos/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param busNumberFilter (optional) 
     * @param busModelFilter (optional) 
     * @param modelFilter (optional) 
     * @param chassisNumberFilter (optional) 
     * @param trackerIEMIFilter (optional) 
     * @param maxInsuPolicyNumberFilter (optional) 
     * @param minInsuPolicyNumberFilter (optional) 
     * @param maxCapcityFilter (optional) 
     * @param minCapcityFilter (optional) 
     * @return Success
     */
    getBusInfosToExcel(filter: string | null | undefined, busNumberFilter: string | null | undefined, busModelFilter: string | null | undefined, modelFilter: string | null | undefined, chassisNumberFilter: string | null | undefined, trackerIEMIFilter: string | null | undefined, maxInsuPolicyNumberFilter: moment.Moment | null | undefined, minInsuPolicyNumberFilter: moment.Moment | null | undefined, maxCapcityFilter: number | null | undefined, minCapcityFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusInfos/GetBusInfosToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (busNumberFilter !== undefined)
            url_ += "BusNumberFilter=" + encodeURIComponent("" + busNumberFilter) + "&"; 
        if (busModelFilter !== undefined)
            url_ += "BusModelFilter=" + encodeURIComponent("" + busModelFilter) + "&"; 
        if (modelFilter !== undefined)
            url_ += "ModelFilter=" + encodeURIComponent("" + modelFilter) + "&"; 
        if (chassisNumberFilter !== undefined)
            url_ += "ChassisNumberFilter=" + encodeURIComponent("" + chassisNumberFilter) + "&"; 
        if (trackerIEMIFilter !== undefined)
            url_ += "TrackerIEMIFilter=" + encodeURIComponent("" + trackerIEMIFilter) + "&"; 
        if (maxInsuPolicyNumberFilter !== undefined)
            url_ += "MaxInsuPolicyNumberFilter=" + encodeURIComponent(maxInsuPolicyNumberFilter ? "" + maxInsuPolicyNumberFilter.toJSON() : "") + "&"; 
        if (minInsuPolicyNumberFilter !== undefined)
            url_ += "MinInsuPolicyNumberFilter=" + encodeURIComponent(minInsuPolicyNumberFilter ? "" + minInsuPolicyNumberFilter.toJSON() : "") + "&"; 
        if (maxCapcityFilter !== undefined)
            url_ += "MaxCapcityFilter=" + encodeURIComponent("" + maxCapcityFilter) + "&"; 
        if (minCapcityFilter !== undefined)
            url_ += "MinCapcityFilter=" + encodeURIComponent("" + minCapcityFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusInfosToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusInfosToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusInfosToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param busNumber (optional) 
     * @return Success
     */
    getByBusNmber(busNumber: string | null | undefined): Observable<BusInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BusInfos/GetByBusNmber?";
        if (busNumber !== undefined)
            url_ += "BusNumber=" + encodeURIComponent("" + busNumber) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBusNmber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBusNmber(<any>response_);
                } catch (e) {
                    return <Observable<BusInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByBusNmber(response: HttpResponseBase): Observable<BusInfoDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusInfoDto[]>(<any>null);
    }
}

@Injectable()
export class BusTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param busTypeDescFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, busTypeDescFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBusTypesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (busTypeDescFilter !== undefined)
            url_ += "BusTypeDescFilter=" + encodeURIComponent("" + busTypeDescFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBusTypesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBusTypesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBusTypesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetBusTypesForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetBusTypesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBusTypesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusTypesForView(id: number | null | undefined): Observable<GetBusTypesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/GetBusTypesForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusTypesForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusTypesForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBusTypesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusTypesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusTypesForView(response: HttpResponseBase): Observable<GetBusTypesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBusTypesForViewDto.fromJS(resultData200) : new GetBusTypesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusTypesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBusTypesForEdit(id: number | null | undefined): Observable<GetBusTypesForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/GetBusTypesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusTypesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusTypesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBusTypesForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBusTypesForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusTypesForEdit(response: HttpResponseBase): Observable<GetBusTypesForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBusTypesForEditOutput.fromJS(resultData200) : new GetBusTypesForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBusTypesForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBusTypesDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param busTypeDescFilter (optional) 
     * @return Success
     */
    getBusTypesToExcel(filter: string | null | undefined, busTypeDescFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BusTypes/GetBusTypesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (busTypeDescFilter !== undefined)
            url_ += "BusTypeDescFilter=" + encodeURIComponent("" + busTypeDescFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusTypesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CalenderBusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/CalenderBuses/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param mondayFilter (optional) 
     * @param tuesdayFilter (optional) 
     * @param wednesdayFilter (optional) 
     * @param thursdayFilter (optional) 
     * @param fridayFilter (optional) 
     * @param saturdayFilter (optional) 
     * @param sundayFilter (optional) 
     * @param maxstart_dateFilter (optional) 
     * @param minstart_dateFilter (optional) 
     * @param maxend_dateFilter (optional) 
     * @param minend_dateFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, mondayFilter: number | null | undefined, tuesdayFilter: number | null | undefined, wednesdayFilter: number | null | undefined, thursdayFilter: number | null | undefined, fridayFilter: number | null | undefined, saturdayFilter: number | null | undefined, sundayFilter: number | null | undefined, maxstart_dateFilter: moment.Moment | null | undefined, minstart_dateFilter: moment.Moment | null | undefined, maxend_dateFilter: moment.Moment | null | undefined, minend_dateFilter: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCalenderBusForView> {
        let url_ = this.baseUrl + "/api/services/app/CalenderBuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (mondayFilter !== undefined)
            url_ += "mondayFilter=" + encodeURIComponent("" + mondayFilter) + "&"; 
        if (tuesdayFilter !== undefined)
            url_ += "tuesdayFilter=" + encodeURIComponent("" + tuesdayFilter) + "&"; 
        if (wednesdayFilter !== undefined)
            url_ += "wednesdayFilter=" + encodeURIComponent("" + wednesdayFilter) + "&"; 
        if (thursdayFilter !== undefined)
            url_ += "thursdayFilter=" + encodeURIComponent("" + thursdayFilter) + "&"; 
        if (fridayFilter !== undefined)
            url_ += "fridayFilter=" + encodeURIComponent("" + fridayFilter) + "&"; 
        if (saturdayFilter !== undefined)
            url_ += "saturdayFilter=" + encodeURIComponent("" + saturdayFilter) + "&"; 
        if (sundayFilter !== undefined)
            url_ += "sundayFilter=" + encodeURIComponent("" + sundayFilter) + "&"; 
        if (maxstart_dateFilter !== undefined)
            url_ += "Maxstart_dateFilter=" + encodeURIComponent(maxstart_dateFilter ? "" + maxstart_dateFilter.toJSON() : "") + "&"; 
        if (minstart_dateFilter !== undefined)
            url_ += "Minstart_dateFilter=" + encodeURIComponent(minstart_dateFilter ? "" + minstart_dateFilter.toJSON() : "") + "&"; 
        if (maxend_dateFilter !== undefined)
            url_ += "Maxend_dateFilter=" + encodeURIComponent(maxend_dateFilter ? "" + maxend_dateFilter.toJSON() : "") + "&"; 
        if (minend_dateFilter !== undefined)
            url_ += "Minend_dateFilter=" + encodeURIComponent(minend_dateFilter ? "" + minend_dateFilter.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCalenderBusForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCalenderBusForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCalenderBusForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetCalenderBusForView.fromJS(resultData200) : new PagedResultDtoOfGetCalenderBusForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCalenderBusForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCalenderBusForEdit(id: number | null | undefined): Observable<GetCalenderBusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CalenderBuses/GetCalenderBusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalenderBusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalenderBusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCalenderBusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCalenderBusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCalenderBusForEdit(response: HttpResponseBase): Observable<GetCalenderBusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCalenderBusForEditOutput.fromJS(resultData200) : new GetCalenderBusForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCalenderBusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCalenderBusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CalenderBuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CalenderBuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param mondayFilter (optional) 
     * @param tuesdayFilter (optional) 
     * @param wednesdayFilter (optional) 
     * @param thursdayFilter (optional) 
     * @param fridayFilter (optional) 
     * @param saturdayFilter (optional) 
     * @param sundayFilter (optional) 
     * @param maxstart_dateFilter (optional) 
     * @param minstart_dateFilter (optional) 
     * @param maxend_dateFilter (optional) 
     * @param minend_dateFilter (optional) 
     * @return Success
     */
    getCalenderBusesToExcel(filter: string | null | undefined, mondayFilter: number | null | undefined, tuesdayFilter: number | null | undefined, wednesdayFilter: number | null | undefined, thursdayFilter: number | null | undefined, fridayFilter: number | null | undefined, saturdayFilter: number | null | undefined, sundayFilter: number | null | undefined, maxstart_dateFilter: moment.Moment | null | undefined, minstart_dateFilter: moment.Moment | null | undefined, maxend_dateFilter: moment.Moment | null | undefined, minend_dateFilter: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CalenderBuses/GetCalenderBusesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (mondayFilter !== undefined)
            url_ += "mondayFilter=" + encodeURIComponent("" + mondayFilter) + "&"; 
        if (tuesdayFilter !== undefined)
            url_ += "tuesdayFilter=" + encodeURIComponent("" + tuesdayFilter) + "&"; 
        if (wednesdayFilter !== undefined)
            url_ += "wednesdayFilter=" + encodeURIComponent("" + wednesdayFilter) + "&"; 
        if (thursdayFilter !== undefined)
            url_ += "thursdayFilter=" + encodeURIComponent("" + thursdayFilter) + "&"; 
        if (fridayFilter !== undefined)
            url_ += "fridayFilter=" + encodeURIComponent("" + fridayFilter) + "&"; 
        if (saturdayFilter !== undefined)
            url_ += "saturdayFilter=" + encodeURIComponent("" + saturdayFilter) + "&"; 
        if (sundayFilter !== undefined)
            url_ += "sundayFilter=" + encodeURIComponent("" + sundayFilter) + "&"; 
        if (maxstart_dateFilter !== undefined)
            url_ += "Maxstart_dateFilter=" + encodeURIComponent(maxstart_dateFilter ? "" + maxstart_dateFilter.toJSON() : "") + "&"; 
        if (minstart_dateFilter !== undefined)
            url_ += "Minstart_dateFilter=" + encodeURIComponent(minstart_dateFilter ? "" + minstart_dateFilter.toJSON() : "") + "&"; 
        if (maxend_dateFilter !== undefined)
            url_ += "Maxend_dateFilter=" + encodeURIComponent(maxend_dateFilter ? "" + maxend_dateFilter.toJSON() : "") + "&"; 
        if (minend_dateFilter !== undefined)
            url_ += "Minend_dateFilter=" + encodeURIComponent(minend_dateFilter ? "" + minend_dateFilter.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCalenderBusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCalenderBusesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCalenderBusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DepartmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Departments/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param departmentNameFilter (optional) 
     * @param departmentEnNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, departmentNameFilter: string | null | undefined, departmentEnNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetDepartmentForView> {
        let url_ = this.baseUrl + "/api/services/app/Departments/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (departmentNameFilter !== undefined)
            url_ += "DepartmentNameFilter=" + encodeURIComponent("" + departmentNameFilter) + "&"; 
        if (departmentEnNameFilter !== undefined)
            url_ += "DepartmentEnNameFilter=" + encodeURIComponent("" + departmentEnNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDepartmentForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDepartmentForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDepartmentForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetDepartmentForView.fromJS(resultData200) : new PagedResultDtoOfGetDepartmentForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDepartmentForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDepartmentForEdit(id: number | null | undefined): Observable<GetDepartmentForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Departments/GetDepartmentForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDepartmentForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDepartmentForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentForEdit(response: HttpResponseBase): Observable<GetDepartmentForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDepartmentForEditOutput.fromJS(resultData200) : new GetDepartmentForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDepartmentForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditDepartmentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Departments/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Departments/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param departmentNameFilter (optional) 
     * @param departmentEnNameFilter (optional) 
     * @return Success
     */
    getDepartmentsToExcel(filter: string | null | undefined, departmentNameFilter: string | null | undefined, departmentEnNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Departments/GetDepartmentsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (departmentNameFilter !== undefined)
            url_ += "DepartmentNameFilter=" + encodeURIComponent("" + departmentNameFilter) + "&"; 
        if (departmentEnNameFilter !== undefined)
            url_ += "DepartmentEnNameFilter=" + encodeURIComponent("" + departmentEnNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDepartmentsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDepartmentsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDepartmentsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEdition(input: CreateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateEdition(input: UpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class EmployeesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param userNameFilter (optional) 
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param cellularFilter (optional) 
     * @param genderFilter (optional) 
     * @param emailFilter (optional) 
     * @param employeeIDNumberFilter (optional) 
     * @param employeeNumberFilter (optional) 
     * @param maxPasswordFilter (optional) 
     * @param minPasswordFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param maxCardNumberTicketingFilter (optional) 
     * @param minCardNumberTicketingFilter (optional) 
     * @param emailAddressFilter (optional) 
     * @param maxPercentageOfPositionFilter (optional) 
     * @param minPercentageOfPositionFilter (optional) 
     * @param maxWorkStartDateFilter (optional) 
     * @param minWorkStartDateFilter (optional) 
     * @param maxWorkEndDateFilter (optional) 
     * @param minWorkEndDateFilter (optional) 
     * @param maxDateOfBirthFilter (optional) 
     * @param minDateOfBirthFilter (optional) 
     * @param bankAccountNumberFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param employeeTypeDescriptionFilter (optional) 
     * @param branchesDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, userNameFilter: string | null | undefined, firstNameFilter: string | null | undefined, lastNameFilter: string | null | undefined, cellularFilter: string | null | undefined, genderFilter: string | null | undefined, emailFilter: string | null | undefined, employeeIDNumberFilter: string | null | undefined, employeeNumberFilter: string | null | undefined, maxPasswordFilter: number | null | undefined, minPasswordFilter: number | null | undefined, isActiveFilter: number | null | undefined, maxCardNumberTicketingFilter: number | null | undefined, minCardNumberTicketingFilter: number | null | undefined, emailAddressFilter: string | null | undefined, maxPercentageOfPositionFilter: number | null | undefined, minPercentageOfPositionFilter: number | null | undefined, maxWorkStartDateFilter: moment.Moment | null | undefined, minWorkStartDateFilter: moment.Moment | null | undefined, maxWorkEndDateFilter: moment.Moment | null | undefined, minWorkEndDateFilter: moment.Moment | null | undefined, maxDateOfBirthFilter: moment.Moment | null | undefined, minDateOfBirthFilter: moment.Moment | null | undefined, bankAccountNumberFilter: string | null | undefined, jobTitleFilter: string | null | undefined, employeeTypeDescriptionFilter: string | null | undefined, branchesDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetEmployeesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&"; 
        if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&"; 
        if (cellularFilter !== undefined)
            url_ += "CellularFilter=" + encodeURIComponent("" + cellularFilter) + "&"; 
        if (genderFilter !== undefined)
            url_ += "GenderFilter=" + encodeURIComponent("" + genderFilter) + "&"; 
        if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&"; 
        if (employeeIDNumberFilter !== undefined)
            url_ += "EmployeeIDNumberFilter=" + encodeURIComponent("" + employeeIDNumberFilter) + "&"; 
        if (employeeNumberFilter !== undefined)
            url_ += "EmployeeNumberFilter=" + encodeURIComponent("" + employeeNumberFilter) + "&"; 
        if (maxPasswordFilter !== undefined)
            url_ += "MaxPasswordFilter=" + encodeURIComponent("" + maxPasswordFilter) + "&"; 
        if (minPasswordFilter !== undefined)
            url_ += "MinPasswordFilter=" + encodeURIComponent("" + minPasswordFilter) + "&"; 
        if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (maxCardNumberTicketingFilter !== undefined)
            url_ += "MaxCardNumberTicketingFilter=" + encodeURIComponent("" + maxCardNumberTicketingFilter) + "&"; 
        if (minCardNumberTicketingFilter !== undefined)
            url_ += "MinCardNumberTicketingFilter=" + encodeURIComponent("" + minCardNumberTicketingFilter) + "&"; 
        if (emailAddressFilter !== undefined)
            url_ += "EmailAddressFilter=" + encodeURIComponent("" + emailAddressFilter) + "&"; 
        if (maxPercentageOfPositionFilter !== undefined)
            url_ += "MaxPercentageOfPositionFilter=" + encodeURIComponent("" + maxPercentageOfPositionFilter) + "&"; 
        if (minPercentageOfPositionFilter !== undefined)
            url_ += "MinPercentageOfPositionFilter=" + encodeURIComponent("" + minPercentageOfPositionFilter) + "&"; 
        if (maxWorkStartDateFilter !== undefined)
            url_ += "MaxWorkStartDateFilter=" + encodeURIComponent(maxWorkStartDateFilter ? "" + maxWorkStartDateFilter.toJSON() : "") + "&"; 
        if (minWorkStartDateFilter !== undefined)
            url_ += "MinWorkStartDateFilter=" + encodeURIComponent(minWorkStartDateFilter ? "" + minWorkStartDateFilter.toJSON() : "") + "&"; 
        if (maxWorkEndDateFilter !== undefined)
            url_ += "MaxWorkEndDateFilter=" + encodeURIComponent(maxWorkEndDateFilter ? "" + maxWorkEndDateFilter.toJSON() : "") + "&"; 
        if (minWorkEndDateFilter !== undefined)
            url_ += "MinWorkEndDateFilter=" + encodeURIComponent(minWorkEndDateFilter ? "" + minWorkEndDateFilter.toJSON() : "") + "&"; 
        if (maxDateOfBirthFilter !== undefined)
            url_ += "MaxDateOfBirthFilter=" + encodeURIComponent(maxDateOfBirthFilter ? "" + maxDateOfBirthFilter.toJSON() : "") + "&"; 
        if (minDateOfBirthFilter !== undefined)
            url_ += "MinDateOfBirthFilter=" + encodeURIComponent(minDateOfBirthFilter ? "" + minDateOfBirthFilter.toJSON() : "") + "&"; 
        if (bankAccountNumberFilter !== undefined)
            url_ += "BankAccountNumberFilter=" + encodeURIComponent("" + bankAccountNumberFilter) + "&"; 
        if (jobTitleFilter !== undefined)
            url_ += "jobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&"; 
        if (employeeTypeDescriptionFilter !== undefined)
            url_ += "EmployeeTypeDescriptionFilter=" + encodeURIComponent("" + employeeTypeDescriptionFilter) + "&"; 
        if (branchesDescriptionFilter !== undefined)
            url_ += "BranchesDescriptionFilter=" + encodeURIComponent("" + branchesDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEmployeesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEmployeesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEmployeesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetEmployeesForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetEmployeesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEmployeesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeesForView(id: number | null | undefined): Observable<GetEmployeesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetEmployeesForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesForView(response: HttpResponseBase): Observable<GetEmployeesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmployeesForViewDto.fromJS(resultData200) : new GetEmployeesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeesForEdit(id: number | null | undefined): Observable<GetEmployeesForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetEmployeesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeesForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeesForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesForEdit(response: HttpResponseBase): Observable<GetEmployeesForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmployeesForEditOutput.fromJS(resultData200) : new GetEmployeesForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeesForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditEmployeesDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employees/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employees/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param userNameFilter (optional) 
     * @param firstNameFilter (optional) 
     * @param lastNameFilter (optional) 
     * @param cellularFilter (optional) 
     * @param genderFilter (optional) 
     * @param emailFilter (optional) 
     * @param employeeIDNumberFilter (optional) 
     * @param employeeNumberFilter (optional) 
     * @param maxPasswordFilter (optional) 
     * @param minPasswordFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param maxCardNumberTicketingFilter (optional) 
     * @param minCardNumberTicketingFilter (optional) 
     * @param emailAddressFilter (optional) 
     * @param maxPercentageOfPositionFilter (optional) 
     * @param minPercentageOfPositionFilter (optional) 
     * @param maxWorkStartDateFilter (optional) 
     * @param minWorkStartDateFilter (optional) 
     * @param maxWorkEndDateFilter (optional) 
     * @param minWorkEndDateFilter (optional) 
     * @param maxDateOfBirthFilter (optional) 
     * @param minDateOfBirthFilter (optional) 
     * @param bankAccountNumberFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param employeeTypeDescriptionFilter (optional) 
     * @param branchesDescriptionFilter (optional) 
     * @return Success
     */
    getEmployeesToExcel(filter: string | null | undefined, userNameFilter: string | null | undefined, firstNameFilter: string | null | undefined, lastNameFilter: string | null | undefined, cellularFilter: string | null | undefined, genderFilter: string | null | undefined, emailFilter: string | null | undefined, employeeIDNumberFilter: string | null | undefined, employeeNumberFilter: string | null | undefined, maxPasswordFilter: number | null | undefined, minPasswordFilter: number | null | undefined, isActiveFilter: number | null | undefined, maxCardNumberTicketingFilter: number | null | undefined, minCardNumberTicketingFilter: number | null | undefined, emailAddressFilter: string | null | undefined, maxPercentageOfPositionFilter: number | null | undefined, minPercentageOfPositionFilter: number | null | undefined, maxWorkStartDateFilter: moment.Moment | null | undefined, minWorkStartDateFilter: moment.Moment | null | undefined, maxWorkEndDateFilter: moment.Moment | null | undefined, minWorkEndDateFilter: moment.Moment | null | undefined, maxDateOfBirthFilter: moment.Moment | null | undefined, minDateOfBirthFilter: moment.Moment | null | undefined, bankAccountNumberFilter: string | null | undefined, jobTitleFilter: string | null | undefined, employeeTypeDescriptionFilter: string | null | undefined, branchesDescriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetEmployeesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (firstNameFilter !== undefined)
            url_ += "FirstNameFilter=" + encodeURIComponent("" + firstNameFilter) + "&"; 
        if (lastNameFilter !== undefined)
            url_ += "LastNameFilter=" + encodeURIComponent("" + lastNameFilter) + "&"; 
        if (cellularFilter !== undefined)
            url_ += "CellularFilter=" + encodeURIComponent("" + cellularFilter) + "&"; 
        if (genderFilter !== undefined)
            url_ += "GenderFilter=" + encodeURIComponent("" + genderFilter) + "&"; 
        if (emailFilter !== undefined)
            url_ += "EmailFilter=" + encodeURIComponent("" + emailFilter) + "&"; 
        if (employeeIDNumberFilter !== undefined)
            url_ += "EmployeeIDNumberFilter=" + encodeURIComponent("" + employeeIDNumberFilter) + "&"; 
        if (employeeNumberFilter !== undefined)
            url_ += "EmployeeNumberFilter=" + encodeURIComponent("" + employeeNumberFilter) + "&"; 
        if (maxPasswordFilter !== undefined)
            url_ += "MaxPasswordFilter=" + encodeURIComponent("" + maxPasswordFilter) + "&"; 
        if (minPasswordFilter !== undefined)
            url_ += "MinPasswordFilter=" + encodeURIComponent("" + minPasswordFilter) + "&"; 
        if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&"; 
        if (maxCardNumberTicketingFilter !== undefined)
            url_ += "MaxCardNumberTicketingFilter=" + encodeURIComponent("" + maxCardNumberTicketingFilter) + "&"; 
        if (minCardNumberTicketingFilter !== undefined)
            url_ += "MinCardNumberTicketingFilter=" + encodeURIComponent("" + minCardNumberTicketingFilter) + "&"; 
        if (emailAddressFilter !== undefined)
            url_ += "EmailAddressFilter=" + encodeURIComponent("" + emailAddressFilter) + "&"; 
        if (maxPercentageOfPositionFilter !== undefined)
            url_ += "MaxPercentageOfPositionFilter=" + encodeURIComponent("" + maxPercentageOfPositionFilter) + "&"; 
        if (minPercentageOfPositionFilter !== undefined)
            url_ += "MinPercentageOfPositionFilter=" + encodeURIComponent("" + minPercentageOfPositionFilter) + "&"; 
        if (maxWorkStartDateFilter !== undefined)
            url_ += "MaxWorkStartDateFilter=" + encodeURIComponent(maxWorkStartDateFilter ? "" + maxWorkStartDateFilter.toJSON() : "") + "&"; 
        if (minWorkStartDateFilter !== undefined)
            url_ += "MinWorkStartDateFilter=" + encodeURIComponent(minWorkStartDateFilter ? "" + minWorkStartDateFilter.toJSON() : "") + "&"; 
        if (maxWorkEndDateFilter !== undefined)
            url_ += "MaxWorkEndDateFilter=" + encodeURIComponent(maxWorkEndDateFilter ? "" + maxWorkEndDateFilter.toJSON() : "") + "&"; 
        if (minWorkEndDateFilter !== undefined)
            url_ += "MinWorkEndDateFilter=" + encodeURIComponent(minWorkEndDateFilter ? "" + minWorkEndDateFilter.toJSON() : "") + "&"; 
        if (maxDateOfBirthFilter !== undefined)
            url_ += "MaxDateOfBirthFilter=" + encodeURIComponent(maxDateOfBirthFilter ? "" + maxDateOfBirthFilter.toJSON() : "") + "&"; 
        if (minDateOfBirthFilter !== undefined)
            url_ += "MinDateOfBirthFilter=" + encodeURIComponent(minDateOfBirthFilter ? "" + minDateOfBirthFilter.toJSON() : "") + "&"; 
        if (bankAccountNumberFilter !== undefined)
            url_ += "BankAccountNumberFilter=" + encodeURIComponent("" + bankAccountNumberFilter) + "&"; 
        if (jobTitleFilter !== undefined)
            url_ += "jobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&"; 
        if (employeeTypeDescriptionFilter !== undefined)
            url_ += "EmployeeTypeDescriptionFilter=" + encodeURIComponent("" + employeeTypeDescriptionFilter) + "&"; 
        if (branchesDescriptionFilter !== undefined)
            url_ += "BranchesDescriptionFilter=" + encodeURIComponent("" + branchesDescriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEmployeeTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAllEmployeeTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmployeeTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmployeeTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEmployeeTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBranchesForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEmployeesBranchesLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Employees/GetAllBranchesForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBranchesForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBranchesForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEmployeesBranchesLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEmployeesBranchesLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBranchesForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeesBranchesLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEmployeesBranchesLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfEmployeesBranchesLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEmployeesBranchesLookupTableDto>(<any>null);
    }
}

@Injectable()
export class EmployeeTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetEmployeeTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEmployeeTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEmployeeTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEmployeeTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetEmployeeTypeForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetEmployeeTypeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEmployeeTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeeTypeForView(id: number | null | undefined): Observable<GetEmployeeTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/GetEmployeeTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTypeForView(response: HttpResponseBase): Observable<GetEmployeeTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmployeeTypeForViewDto.fromJS(resultData200) : new GetEmployeeTypeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEmployeeTypeForEdit(id: number | null | undefined): Observable<GetEmployeeTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/GetEmployeeTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTypeForEdit(response: HttpResponseBase): Observable<GetEmployeeTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmployeeTypeForEditOutput.fromJS(resultData200) : new GetEmployeeTypeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditEmployeeTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getEmployeeTypeToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeType/GetEmployeeTypeToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmployeeTypeToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmployeeTypeToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmployeeTypeToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class JobTitleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param description2ndLangFilter (optional) 
     * @param description3rdLangFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, description2ndLangFilter: string | null | undefined, description3rdLangFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetJobTitleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (description2ndLangFilter !== undefined)
            url_ += "Description2ndLangFilter=" + encodeURIComponent("" + description2ndLangFilter) + "&"; 
        if (description3rdLangFilter !== undefined)
            url_ += "Description3rdLangFilter=" + encodeURIComponent("" + description3rdLangFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetJobTitleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetJobTitleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetJobTitleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetJobTitleForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetJobTitleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetJobTitleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobTitleForView(id: number | null | undefined): Observable<GetJobTitleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetJobTitleForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTitleForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTitleForView(<any>response_);
                } catch (e) {
                    return <Observable<GetJobTitleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetJobTitleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobTitleForView(response: HttpResponseBase): Observable<GetJobTitleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetJobTitleForViewDto.fromJS(resultData200) : new GetJobTitleForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJobTitleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobTitleForEdit(id: number | null | undefined): Observable<GetJobTitleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetJobTitleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTitleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTitleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetJobTitleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetJobTitleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobTitleForEdit(response: HttpResponseBase): Observable<GetJobTitleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetJobTitleForEditOutput.fromJS(resultData200) : new GetJobTitleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetJobTitleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditJobTitleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param description2ndLangFilter (optional) 
     * @param description3rdLangFilter (optional) 
     * @return Success
     */
    getJobTitleToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined, description2ndLangFilter: string | null | undefined, description3rdLangFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetJobTitleToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (description2ndLangFilter !== undefined)
            url_ += "Description2ndLangFilter=" + encodeURIComponent("" + description2ndLangFilter) + "&"; 
        if (description3rdLangFilter !== undefined)
            url_ += "Description3rdLangFilter=" + encodeURIComponent("" + description3rdLangFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobTitleToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobTitleToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetJobTitleToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findRoles(input: FindOrganizationUnitRolesInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentAsync?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalPaymentId (optional) 
     * @param paypalPayerId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | null | undefined, paypalPaymentId: string | null | undefined, paypalPayerId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalPaymentId !== undefined)
            url_ += "paypalPaymentId=" + encodeURIComponent("" + paypalPaymentId) + "&"; 
        if (paypalPayerId !== undefined)
            url_ += "paypalPayerId=" + encodeURIComponent("" + paypalPayerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalConfigurationDto.fromJS(resultData200) : new PayPalConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendVerificationSms(input: SendVerificationSmsInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoutesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Routes/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxLineNumberFilter (optional) 
     * @param minLineNumberFilter (optional) 
     * @param maxDirectionFilter (optional) 
     * @param minDirectionFilter (optional) 
     * @param maxLineCodeFilter (optional) 
     * @param minLineCodeFilter (optional) 
     * @param maxSignageFilter (optional) 
     * @param minSignageFilter (optional) 
     * @param maxagencyFilter (optional) 
     * @param minagencyFilter (optional) 
     * @param maxTotalKMFilter (optional) 
     * @param minTotalKMFilter (optional) 
     * @param maxTotalMinutesFilter (optional) 
     * @param minTotalMinutesFilter (optional) 
     * @param routeIDGTFSFilter (optional) 
     * @param maxCatSedorFilter (optional) 
     * @param minCatSedorFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxLineNumberFilter: number | null | undefined, minLineNumberFilter: number | null | undefined, maxDirectionFilter: number | null | undefined, minDirectionFilter: number | null | undefined, maxLineCodeFilter: number | null | undefined, minLineCodeFilter: number | null | undefined, maxSignageFilter: number | null | undefined, minSignageFilter: number | null | undefined, maxagencyFilter: number | null | undefined, minagencyFilter: number | null | undefined, maxTotalKMFilter: number | null | undefined, minTotalKMFilter: number | null | undefined, maxTotalMinutesFilter: number | null | undefined, minTotalMinutesFilter: number | null | undefined, routeIDGTFSFilter: string | null | undefined, maxCatSedorFilter: number | null | undefined, minCatSedorFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRouteForView> {
        let url_ = this.baseUrl + "/api/services/app/Routes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxLineNumberFilter !== undefined)
            url_ += "MaxLineNumberFilter=" + encodeURIComponent("" + maxLineNumberFilter) + "&"; 
        if (minLineNumberFilter !== undefined)
            url_ += "MinLineNumberFilter=" + encodeURIComponent("" + minLineNumberFilter) + "&"; 
        if (maxDirectionFilter !== undefined)
            url_ += "MaxDirectionFilter=" + encodeURIComponent("" + maxDirectionFilter) + "&"; 
        if (minDirectionFilter !== undefined)
            url_ += "MinDirectionFilter=" + encodeURIComponent("" + minDirectionFilter) + "&"; 
        if (maxLineCodeFilter !== undefined)
            url_ += "MaxLineCodeFilter=" + encodeURIComponent("" + maxLineCodeFilter) + "&"; 
        if (minLineCodeFilter !== undefined)
            url_ += "MinLineCodeFilter=" + encodeURIComponent("" + minLineCodeFilter) + "&"; 
        if (maxSignageFilter !== undefined)
            url_ += "MaxSignageFilter=" + encodeURIComponent("" + maxSignageFilter) + "&"; 
        if (minSignageFilter !== undefined)
            url_ += "MinSignageFilter=" + encodeURIComponent("" + minSignageFilter) + "&"; 
        if (maxagencyFilter !== undefined)
            url_ += "MaxagencyFilter=" + encodeURIComponent("" + maxagencyFilter) + "&"; 
        if (minagencyFilter !== undefined)
            url_ += "MinagencyFilter=" + encodeURIComponent("" + minagencyFilter) + "&"; 
        if (maxTotalKMFilter !== undefined)
            url_ += "MaxTotalKMFilter=" + encodeURIComponent("" + maxTotalKMFilter) + "&"; 
        if (minTotalKMFilter !== undefined)
            url_ += "MinTotalKMFilter=" + encodeURIComponent("" + minTotalKMFilter) + "&"; 
        if (maxTotalMinutesFilter !== undefined)
            url_ += "MaxTotalMinutesFilter=" + encodeURIComponent("" + maxTotalMinutesFilter) + "&"; 
        if (minTotalMinutesFilter !== undefined)
            url_ += "MinTotalMinutesFilter=" + encodeURIComponent("" + minTotalMinutesFilter) + "&"; 
        if (routeIDGTFSFilter !== undefined)
            url_ += "RouteIDGTFSFilter=" + encodeURIComponent("" + routeIDGTFSFilter) + "&"; 
        if (maxCatSedorFilter !== undefined)
            url_ += "MaxCatSedorFilter=" + encodeURIComponent("" + maxCatSedorFilter) + "&"; 
        if (minCatSedorFilter !== undefined)
            url_ += "MinCatSedorFilter=" + encodeURIComponent("" + minCatSedorFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRouteForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRouteForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRouteForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRouteForView.fromJS(resultData200) : new PagedResultDtoOfGetRouteForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRouteForView>(<any>null);
    }

    /**
     * @param idofRoute (optional) 
     * @return Success
     */
    getStationsofRoute(idofRoute: number | null | undefined): Observable<PagedResultDtoOfGetStatoinDetailForRouteForView> {
        let url_ = this.baseUrl + "/api/services/app/Routes/GetStationsofRoute?";
        if (idofRoute !== undefined)
            url_ += "IdofRoute=" + encodeURIComponent("" + idofRoute) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStationsofRoute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStationsofRoute(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetStatoinDetailForRouteForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetStatoinDetailForRouteForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetStationsofRoute(response: HttpResponseBase): Observable<PagedResultDtoOfGetStatoinDetailForRouteForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetStatoinDetailForRouteForView.fromJS(resultData200) : new PagedResultDtoOfGetStatoinDetailForRouteForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetStatoinDetailForRouteForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRouteForEdit(id: number | null | undefined): Observable<GetRouteForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Routes/GetRouteForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRouteForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRouteForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRouteForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRouteForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRouteForEdit(response: HttpResponseBase): Observable<GetRouteForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRouteForEditOutput.fromJS(resultData200) : new GetRouteForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRouteForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRouteDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Routes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Routes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxLineNumberFilter (optional) 
     * @param minLineNumberFilter (optional) 
     * @param maxDirectionFilter (optional) 
     * @param minDirectionFilter (optional) 
     * @param maxLineCodeFilter (optional) 
     * @param minLineCodeFilter (optional) 
     * @param maxSignageFilter (optional) 
     * @param minSignageFilter (optional) 
     * @param maxagencyFilter (optional) 
     * @param minagencyFilter (optional) 
     * @param maxTotalKMFilter (optional) 
     * @param minTotalKMFilter (optional) 
     * @param maxTotalMinutesFilter (optional) 
     * @param minTotalMinutesFilter (optional) 
     * @param routeIDGTFSFilter (optional) 
     * @param maxCatSedorFilter (optional) 
     * @param minCatSedorFilter (optional) 
     * @return Success
     */
    getRoutesToExcel(filter: string | null | undefined, maxLineNumberFilter: number | null | undefined, minLineNumberFilter: number | null | undefined, maxDirectionFilter: number | null | undefined, minDirectionFilter: number | null | undefined, maxLineCodeFilter: number | null | undefined, minLineCodeFilter: number | null | undefined, maxSignageFilter: number | null | undefined, minSignageFilter: number | null | undefined, maxagencyFilter: number | null | undefined, minagencyFilter: number | null | undefined, maxTotalKMFilter: number | null | undefined, minTotalKMFilter: number | null | undefined, maxTotalMinutesFilter: number | null | undefined, minTotalMinutesFilter: number | null | undefined, routeIDGTFSFilter: string | null | undefined, maxCatSedorFilter: number | null | undefined, minCatSedorFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Routes/GetRoutesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxLineNumberFilter !== undefined)
            url_ += "MaxLineNumberFilter=" + encodeURIComponent("" + maxLineNumberFilter) + "&"; 
        if (minLineNumberFilter !== undefined)
            url_ += "MinLineNumberFilter=" + encodeURIComponent("" + minLineNumberFilter) + "&"; 
        if (maxDirectionFilter !== undefined)
            url_ += "MaxDirectionFilter=" + encodeURIComponent("" + maxDirectionFilter) + "&"; 
        if (minDirectionFilter !== undefined)
            url_ += "MinDirectionFilter=" + encodeURIComponent("" + minDirectionFilter) + "&"; 
        if (maxLineCodeFilter !== undefined)
            url_ += "MaxLineCodeFilter=" + encodeURIComponent("" + maxLineCodeFilter) + "&"; 
        if (minLineCodeFilter !== undefined)
            url_ += "MinLineCodeFilter=" + encodeURIComponent("" + minLineCodeFilter) + "&"; 
        if (maxSignageFilter !== undefined)
            url_ += "MaxSignageFilter=" + encodeURIComponent("" + maxSignageFilter) + "&"; 
        if (minSignageFilter !== undefined)
            url_ += "MinSignageFilter=" + encodeURIComponent("" + minSignageFilter) + "&"; 
        if (maxagencyFilter !== undefined)
            url_ += "MaxagencyFilter=" + encodeURIComponent("" + maxagencyFilter) + "&"; 
        if (minagencyFilter !== undefined)
            url_ += "MinagencyFilter=" + encodeURIComponent("" + minagencyFilter) + "&"; 
        if (maxTotalKMFilter !== undefined)
            url_ += "MaxTotalKMFilter=" + encodeURIComponent("" + maxTotalKMFilter) + "&"; 
        if (minTotalKMFilter !== undefined)
            url_ += "MinTotalKMFilter=" + encodeURIComponent("" + minTotalKMFilter) + "&"; 
        if (maxTotalMinutesFilter !== undefined)
            url_ += "MaxTotalMinutesFilter=" + encodeURIComponent("" + maxTotalMinutesFilter) + "&"; 
        if (minTotalMinutesFilter !== undefined)
            url_ += "MinTotalMinutesFilter=" + encodeURIComponent("" + minTotalMinutesFilter) + "&"; 
        if (routeIDGTFSFilter !== undefined)
            url_ += "RouteIDGTFSFilter=" + encodeURIComponent("" + routeIDGTFSFilter) + "&"; 
        if (maxCatSedorFilter !== undefined)
            url_ += "MaxCatSedorFilter=" + encodeURIComponent("" + maxCatSedorFilter) + "&"; 
        if (minCatSedorFilter !== undefined)
            url_ += "MinCatSedorFilter=" + encodeURIComponent("" + minCatSedorFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoutesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoutesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoutesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class Routes_StationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxRoutesIDFilter (optional) 
     * @param minRoutesIDFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param maxStationOrderFilter (optional) 
     * @param minStationOrderFilter (optional) 
     * @param maxDistanceFStartFilter (optional) 
     * @param minDistanceFStartFilter (optional) 
     * @param maxDistanceFPrviousStFilter (optional) 
     * @param minDistanceFPrviousStFilter (optional) 
     * @param maxTimefrStartStationFilter (optional) 
     * @param minTimefrStartStationFilter (optional) 
     * @param maxLinkToMainFilter (optional) 
     * @param minLinkToMainFilter (optional) 
     * @param timefrPrviousFilter (optional) 
     * @param timeFrStartFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxRoutesIDFilter: number | null | undefined, minRoutesIDFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, maxStationOrderFilter: number | null | undefined, minStationOrderFilter: number | null | undefined, maxDistanceFStartFilter: number | null | undefined, minDistanceFStartFilter: number | null | undefined, maxDistanceFPrviousStFilter: number | null | undefined, minDistanceFPrviousStFilter: number | null | undefined, maxTimefrStartStationFilter: number | null | undefined, minTimefrStartStationFilter: number | null | undefined, maxLinkToMainFilter: number | null | undefined, minLinkToMainFilter: number | null | undefined, timefrPrviousFilter: string | null | undefined, timeFrStartFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRoutes_StationForView> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxRoutesIDFilter !== undefined)
            url_ += "MaxRoutesIDFilter=" + encodeURIComponent("" + maxRoutesIDFilter) + "&"; 
        if (minRoutesIDFilter !== undefined)
            url_ += "MinRoutesIDFilter=" + encodeURIComponent("" + minRoutesIDFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (maxStationOrderFilter !== undefined)
            url_ += "MaxStationOrderFilter=" + encodeURIComponent("" + maxStationOrderFilter) + "&"; 
        if (minStationOrderFilter !== undefined)
            url_ += "MinStationOrderFilter=" + encodeURIComponent("" + minStationOrderFilter) + "&"; 
        if (maxDistanceFStartFilter !== undefined)
            url_ += "MaxDistanceFStartFilter=" + encodeURIComponent("" + maxDistanceFStartFilter) + "&"; 
        if (minDistanceFStartFilter !== undefined)
            url_ += "MinDistanceFStartFilter=" + encodeURIComponent("" + minDistanceFStartFilter) + "&"; 
        if (maxDistanceFPrviousStFilter !== undefined)
            url_ += "MaxDistanceFPrviousStFilter=" + encodeURIComponent("" + maxDistanceFPrviousStFilter) + "&"; 
        if (minDistanceFPrviousStFilter !== undefined)
            url_ += "MinDistanceFPrviousStFilter=" + encodeURIComponent("" + minDistanceFPrviousStFilter) + "&"; 
        if (maxTimefrStartStationFilter !== undefined)
            url_ += "MaxTimefrStartStationFilter=" + encodeURIComponent("" + maxTimefrStartStationFilter) + "&"; 
        if (minTimefrStartStationFilter !== undefined)
            url_ += "MinTimefrStartStationFilter=" + encodeURIComponent("" + minTimefrStartStationFilter) + "&"; 
        if (maxLinkToMainFilter !== undefined)
            url_ += "MaxLinkToMainFilter=" + encodeURIComponent("" + maxLinkToMainFilter) + "&"; 
        if (minLinkToMainFilter !== undefined)
            url_ += "MinLinkToMainFilter=" + encodeURIComponent("" + minLinkToMainFilter) + "&"; 
        if (timefrPrviousFilter !== undefined)
            url_ += "TimefrPrviousFilter=" + encodeURIComponent("" + timefrPrviousFilter) + "&"; 
        if (timeFrStartFilter !== undefined)
            url_ += "TimeFrStartFilter=" + encodeURIComponent("" + timeFrStartFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRoutes_StationForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRoutes_StationForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRoutes_StationForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRoutes_StationForView.fromJS(resultData200) : new PagedResultDtoOfGetRoutes_StationForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRoutes_StationForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoutes_StationForEdit(id: number | null | undefined): Observable<GetRoutes_StationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/GetRoutes_StationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoutes_StationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoutes_StationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoutes_StationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoutes_StationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoutes_StationForEdit(response: HttpResponseBase): Observable<GetRoutes_StationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoutes_StationForEditOutput.fromJS(resultData200) : new GetRoutes_StationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoutes_StationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRoutes_StationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param idofRoute (optional) 
     * @param stationCode (optional) 
     * @return Success
     */
    deleteRouteStation(idofRoute: number | null | undefined, stationCode: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/DeleteRouteStation?";
        if (idofRoute !== undefined)
            url_ += "IdofRoute=" + encodeURIComponent("" + idofRoute) + "&"; 
        if (stationCode !== undefined)
            url_ += "StationCode=" + encodeURIComponent("" + stationCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRouteStation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRouteStation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRouteStation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxRoutesIDFilter (optional) 
     * @param minRoutesIDFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param maxStationOrderFilter (optional) 
     * @param minStationOrderFilter (optional) 
     * @param maxDistanceFStartFilter (optional) 
     * @param minDistanceFStartFilter (optional) 
     * @param maxDistanceFPrviousStFilter (optional) 
     * @param minDistanceFPrviousStFilter (optional) 
     * @param maxTimefrStartStationFilter (optional) 
     * @param minTimefrStartStationFilter (optional) 
     * @param maxLinkToMainFilter (optional) 
     * @param minLinkToMainFilter (optional) 
     * @param timefrPrviousFilter (optional) 
     * @param timeFrStartFilter (optional) 
     * @return Success
     */
    getRoutes_StationsToExcel(filter: string | null | undefined, maxRoutesIDFilter: number | null | undefined, minRoutesIDFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, maxStationOrderFilter: number | null | undefined, minStationOrderFilter: number | null | undefined, maxDistanceFStartFilter: number | null | undefined, minDistanceFStartFilter: number | null | undefined, maxDistanceFPrviousStFilter: number | null | undefined, minDistanceFPrviousStFilter: number | null | undefined, maxTimefrStartStationFilter: number | null | undefined, minTimefrStartStationFilter: number | null | undefined, maxLinkToMainFilter: number | null | undefined, minLinkToMainFilter: number | null | undefined, timefrPrviousFilter: string | null | undefined, timeFrStartFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Routes_Stations/GetRoutes_StationsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxRoutesIDFilter !== undefined)
            url_ += "MaxRoutesIDFilter=" + encodeURIComponent("" + maxRoutesIDFilter) + "&"; 
        if (minRoutesIDFilter !== undefined)
            url_ += "MinRoutesIDFilter=" + encodeURIComponent("" + minRoutesIDFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (maxStationOrderFilter !== undefined)
            url_ += "MaxStationOrderFilter=" + encodeURIComponent("" + maxStationOrderFilter) + "&"; 
        if (minStationOrderFilter !== undefined)
            url_ += "MinStationOrderFilter=" + encodeURIComponent("" + minStationOrderFilter) + "&"; 
        if (maxDistanceFStartFilter !== undefined)
            url_ += "MaxDistanceFStartFilter=" + encodeURIComponent("" + maxDistanceFStartFilter) + "&"; 
        if (minDistanceFStartFilter !== undefined)
            url_ += "MinDistanceFStartFilter=" + encodeURIComponent("" + minDistanceFStartFilter) + "&"; 
        if (maxDistanceFPrviousStFilter !== undefined)
            url_ += "MaxDistanceFPrviousStFilter=" + encodeURIComponent("" + maxDistanceFPrviousStFilter) + "&"; 
        if (minDistanceFPrviousStFilter !== undefined)
            url_ += "MinDistanceFPrviousStFilter=" + encodeURIComponent("" + minDistanceFPrviousStFilter) + "&"; 
        if (maxTimefrStartStationFilter !== undefined)
            url_ += "MaxTimefrStartStationFilter=" + encodeURIComponent("" + maxTimefrStartStationFilter) + "&"; 
        if (minTimefrStartStationFilter !== undefined)
            url_ += "MinTimefrStartStationFilter=" + encodeURIComponent("" + minTimefrStartStationFilter) + "&"; 
        if (maxLinkToMainFilter !== undefined)
            url_ += "MaxLinkToMainFilter=" + encodeURIComponent("" + maxLinkToMainFilter) + "&"; 
        if (minLinkToMainFilter !== undefined)
            url_ += "MinLinkToMainFilter=" + encodeURIComponent("" + minLinkToMainFilter) + "&"; 
        if (timefrPrviousFilter !== undefined)
            url_ += "TimefrPrviousFilter=" + encodeURIComponent("" + timefrPrviousFilter) + "&"; 
        if (timeFrStartFilter !== undefined)
            url_ += "TimeFrStartFilter=" + encodeURIComponent("" + timeFrStartFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoutes_StationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoutes_StationsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoutes_StationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class StaffsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param fULL_NAMEFilter (optional) 
     * @param genderFilter (optional) 
     * @param workMobileFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param professionFilter (optional) 
     * @param pHONEFilter (optional) 
     * @param mOBILEFilter (optional) 
     * @param pOSISTIONFilter (optional) 
     * @param eMPLOYMENT_TYPEFilter (optional) 
     * @param maxPROJECT_IDFilter (optional) 
     * @param minPROJECT_IDFilter (optional) 
     * @param maxDOBFilter (optional) 
     * @param minDOBFilter (optional) 
     * @param maxDOEFilter (optional) 
     * @param minDOEFilter (optional) 
     * @param lOGIN_NAMEFilter (optional) 
     * @param lOGIN_PASSFilter (optional) 
     * @param iS_ACTIVEFilter (optional) 
     * @param rolesFilter (optional) 
     * @param emailFilter (optional) 
     * @param skypeFilter (optional) 
     * @param personalIMFilter (optional) 
     * @param homeFaxFilter (optional) 
     * @param homePhoneFilter (optional) 
     * @param addressFilter (optional) 
     * @param postalCodeFilter (optional) 
     * @param workExtensionFilter (optional) 
     * @param maxlastUpdatedFilter (optional) 
     * @param minlastUpdatedFilter (optional) 
     * @param maxEmployeestartDateFilter (optional) 
     * @param minEmployeestartDateFilter (optional) 
     * @param maxCostFilter (optional) 
     * @param minCostFilter (optional) 
     * @param maxTimsheetCheckByEmpFilter (optional) 
     * @param minTimsheetCheckByEmpFilter (optional) 
     * @param maxautoranIDFilter (optional) 
     * @param minautoranIDFilter (optional) 
     * @param iSDriverFilter (optional) 
     * @param maxXFilter (optional) 
     * @param minXFilter (optional) 
     * @param maxYFilter (optional) 
     * @param minYFilter (optional) 
     * @param dayFilter (optional) 
     * @param maxDisplayOrderFilter (optional) 
     * @param minDisplayOrderFilter (optional) 
     * @param isStopFilter (optional) 
     * @param maxautoranIDServerFilter (optional) 
     * @param minautoranIDServerFilter (optional) 
     * @param iDNumberFilter (optional) 
     * @param klushNoFilter (optional) 
     * @param maxwelfareClockIdFilter (optional) 
     * @param minwelfareClockIdFilter (optional) 
     * @param departmentDepartmentNameFilter (optional) 
     * @param organizationUnitDisplayNameFilter (optional) 
     * @param staffFULL_NAMEFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, fULL_NAMEFilter: string | null | undefined, genderFilter: string | null | undefined, workMobileFilter: string | null | undefined, jobTitleFilter: string | null | undefined, professionFilter: string | null | undefined, pHONEFilter: string | null | undefined, mOBILEFilter: string | null | undefined, pOSISTIONFilter: string | null | undefined, eMPLOYMENT_TYPEFilter: string | null | undefined, maxPROJECT_IDFilter: number | null | undefined, minPROJECT_IDFilter: number | null | undefined, maxDOBFilter: moment.Moment | null | undefined, minDOBFilter: moment.Moment | null | undefined, maxDOEFilter: moment.Moment | null | undefined, minDOEFilter: moment.Moment | null | undefined, lOGIN_NAMEFilter: string | null | undefined, lOGIN_PASSFilter: string | null | undefined, iS_ACTIVEFilter: number | null | undefined, rolesFilter: string | null | undefined, emailFilter: string | null | undefined, skypeFilter: string | null | undefined, personalIMFilter: string | null | undefined, homeFaxFilter: string | null | undefined, homePhoneFilter: string | null | undefined, addressFilter: string | null | undefined, postalCodeFilter: string | null | undefined, workExtensionFilter: string | null | undefined, maxlastUpdatedFilter: moment.Moment | null | undefined, minlastUpdatedFilter: moment.Moment | null | undefined, maxEmployeestartDateFilter: moment.Moment | null | undefined, minEmployeestartDateFilter: moment.Moment | null | undefined, maxCostFilter: number | null | undefined, minCostFilter: number | null | undefined, maxTimsheetCheckByEmpFilter: number | null | undefined, minTimsheetCheckByEmpFilter: number | null | undefined, maxautoranIDFilter: number | null | undefined, minautoranIDFilter: number | null | undefined, iSDriverFilter: number | null | undefined, maxXFilter: number | null | undefined, minXFilter: number | null | undefined, maxYFilter: number | null | undefined, minYFilter: number | null | undefined, dayFilter: string | null | undefined, maxDisplayOrderFilter: number | null | undefined, minDisplayOrderFilter: number | null | undefined, isStopFilter: number | null | undefined, maxautoranIDServerFilter: number | null | undefined, minautoranIDServerFilter: number | null | undefined, iDNumberFilter: string | null | undefined, klushNoFilter: string | null | undefined, maxwelfareClockIdFilter: number | null | undefined, minwelfareClockIdFilter: number | null | undefined, departmentDepartmentNameFilter: string | null | undefined, organizationUnitDisplayNameFilter: string | null | undefined, staffFULL_NAMEFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetStaffForView> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (fULL_NAMEFilter !== undefined)
            url_ += "FULL_NAMEFilter=" + encodeURIComponent("" + fULL_NAMEFilter) + "&"; 
        if (genderFilter !== undefined)
            url_ += "genderFilter=" + encodeURIComponent("" + genderFilter) + "&"; 
        if (workMobileFilter !== undefined)
            url_ += "workMobileFilter=" + encodeURIComponent("" + workMobileFilter) + "&"; 
        if (jobTitleFilter !== undefined)
            url_ += "jobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&"; 
        if (professionFilter !== undefined)
            url_ += "professionFilter=" + encodeURIComponent("" + professionFilter) + "&"; 
        if (pHONEFilter !== undefined)
            url_ += "PHONEFilter=" + encodeURIComponent("" + pHONEFilter) + "&"; 
        if (mOBILEFilter !== undefined)
            url_ += "MOBILEFilter=" + encodeURIComponent("" + mOBILEFilter) + "&"; 
        if (pOSISTIONFilter !== undefined)
            url_ += "POSISTIONFilter=" + encodeURIComponent("" + pOSISTIONFilter) + "&"; 
        if (eMPLOYMENT_TYPEFilter !== undefined)
            url_ += "EMPLOYMENT_TYPEFilter=" + encodeURIComponent("" + eMPLOYMENT_TYPEFilter) + "&"; 
        if (maxPROJECT_IDFilter !== undefined)
            url_ += "MaxPROJECT_IDFilter=" + encodeURIComponent("" + maxPROJECT_IDFilter) + "&"; 
        if (minPROJECT_IDFilter !== undefined)
            url_ += "MinPROJECT_IDFilter=" + encodeURIComponent("" + minPROJECT_IDFilter) + "&"; 
        if (maxDOBFilter !== undefined)
            url_ += "MaxDOBFilter=" + encodeURIComponent(maxDOBFilter ? "" + maxDOBFilter.toJSON() : "") + "&"; 
        if (minDOBFilter !== undefined)
            url_ += "MinDOBFilter=" + encodeURIComponent(minDOBFilter ? "" + minDOBFilter.toJSON() : "") + "&"; 
        if (maxDOEFilter !== undefined)
            url_ += "MaxDOEFilter=" + encodeURIComponent(maxDOEFilter ? "" + maxDOEFilter.toJSON() : "") + "&"; 
        if (minDOEFilter !== undefined)
            url_ += "MinDOEFilter=" + encodeURIComponent(minDOEFilter ? "" + minDOEFilter.toJSON() : "") + "&"; 
        if (lOGIN_NAMEFilter !== undefined)
            url_ += "LOGIN_NAMEFilter=" + encodeURIComponent("" + lOGIN_NAMEFilter) + "&"; 
        if (lOGIN_PASSFilter !== undefined)
            url_ += "LOGIN_PASSFilter=" + encodeURIComponent("" + lOGIN_PASSFilter) + "&"; 
        if (iS_ACTIVEFilter !== undefined)
            url_ += "IS_ACTIVEFilter=" + encodeURIComponent("" + iS_ACTIVEFilter) + "&"; 
        if (rolesFilter !== undefined)
            url_ += "RolesFilter=" + encodeURIComponent("" + rolesFilter) + "&"; 
        if (emailFilter !== undefined)
            url_ += "emailFilter=" + encodeURIComponent("" + emailFilter) + "&"; 
        if (skypeFilter !== undefined)
            url_ += "skypeFilter=" + encodeURIComponent("" + skypeFilter) + "&"; 
        if (personalIMFilter !== undefined)
            url_ += "personalIMFilter=" + encodeURIComponent("" + personalIMFilter) + "&"; 
        if (homeFaxFilter !== undefined)
            url_ += "homeFaxFilter=" + encodeURIComponent("" + homeFaxFilter) + "&"; 
        if (homePhoneFilter !== undefined)
            url_ += "homePhoneFilter=" + encodeURIComponent("" + homePhoneFilter) + "&"; 
        if (addressFilter !== undefined)
            url_ += "addressFilter=" + encodeURIComponent("" + addressFilter) + "&"; 
        if (postalCodeFilter !== undefined)
            url_ += "postalCodeFilter=" + encodeURIComponent("" + postalCodeFilter) + "&"; 
        if (workExtensionFilter !== undefined)
            url_ += "workExtensionFilter=" + encodeURIComponent("" + workExtensionFilter) + "&"; 
        if (maxlastUpdatedFilter !== undefined)
            url_ += "MaxlastUpdatedFilter=" + encodeURIComponent(maxlastUpdatedFilter ? "" + maxlastUpdatedFilter.toJSON() : "") + "&"; 
        if (minlastUpdatedFilter !== undefined)
            url_ += "MinlastUpdatedFilter=" + encodeURIComponent(minlastUpdatedFilter ? "" + minlastUpdatedFilter.toJSON() : "") + "&"; 
        if (maxEmployeestartDateFilter !== undefined)
            url_ += "MaxEmployeestartDateFilter=" + encodeURIComponent(maxEmployeestartDateFilter ? "" + maxEmployeestartDateFilter.toJSON() : "") + "&"; 
        if (minEmployeestartDateFilter !== undefined)
            url_ += "MinEmployeestartDateFilter=" + encodeURIComponent(minEmployeestartDateFilter ? "" + minEmployeestartDateFilter.toJSON() : "") + "&"; 
        if (maxCostFilter !== undefined)
            url_ += "MaxCostFilter=" + encodeURIComponent("" + maxCostFilter) + "&"; 
        if (minCostFilter !== undefined)
            url_ += "MinCostFilter=" + encodeURIComponent("" + minCostFilter) + "&"; 
        if (maxTimsheetCheckByEmpFilter !== undefined)
            url_ += "MaxTimsheetCheckByEmpFilter=" + encodeURIComponent("" + maxTimsheetCheckByEmpFilter) + "&"; 
        if (minTimsheetCheckByEmpFilter !== undefined)
            url_ += "MinTimsheetCheckByEmpFilter=" + encodeURIComponent("" + minTimsheetCheckByEmpFilter) + "&"; 
        if (maxautoranIDFilter !== undefined)
            url_ += "MaxautoranIDFilter=" + encodeURIComponent("" + maxautoranIDFilter) + "&"; 
        if (minautoranIDFilter !== undefined)
            url_ += "MinautoranIDFilter=" + encodeURIComponent("" + minautoranIDFilter) + "&"; 
        if (iSDriverFilter !== undefined)
            url_ += "ISDriverFilter=" + encodeURIComponent("" + iSDriverFilter) + "&"; 
        if (maxXFilter !== undefined)
            url_ += "MaxXFilter=" + encodeURIComponent("" + maxXFilter) + "&"; 
        if (minXFilter !== undefined)
            url_ += "MinXFilter=" + encodeURIComponent("" + minXFilter) + "&"; 
        if (maxYFilter !== undefined)
            url_ += "MaxYFilter=" + encodeURIComponent("" + maxYFilter) + "&"; 
        if (minYFilter !== undefined)
            url_ += "MinYFilter=" + encodeURIComponent("" + minYFilter) + "&"; 
        if (dayFilter !== undefined)
            url_ += "DayFilter=" + encodeURIComponent("" + dayFilter) + "&"; 
        if (maxDisplayOrderFilter !== undefined)
            url_ += "MaxDisplayOrderFilter=" + encodeURIComponent("" + maxDisplayOrderFilter) + "&"; 
        if (minDisplayOrderFilter !== undefined)
            url_ += "MinDisplayOrderFilter=" + encodeURIComponent("" + minDisplayOrderFilter) + "&"; 
        if (isStopFilter !== undefined)
            url_ += "IsStopFilter=" + encodeURIComponent("" + isStopFilter) + "&"; 
        if (maxautoranIDServerFilter !== undefined)
            url_ += "MaxautoranIDServerFilter=" + encodeURIComponent("" + maxautoranIDServerFilter) + "&"; 
        if (minautoranIDServerFilter !== undefined)
            url_ += "MinautoranIDServerFilter=" + encodeURIComponent("" + minautoranIDServerFilter) + "&"; 
        if (iDNumberFilter !== undefined)
            url_ += "IDNumberFilter=" + encodeURIComponent("" + iDNumberFilter) + "&"; 
        if (klushNoFilter !== undefined)
            url_ += "KlushNoFilter=" + encodeURIComponent("" + klushNoFilter) + "&"; 
        if (maxwelfareClockIdFilter !== undefined)
            url_ += "MaxwelfareClockIdFilter=" + encodeURIComponent("" + maxwelfareClockIdFilter) + "&"; 
        if (minwelfareClockIdFilter !== undefined)
            url_ += "MinwelfareClockIdFilter=" + encodeURIComponent("" + minwelfareClockIdFilter) + "&"; 
        if (departmentDepartmentNameFilter !== undefined)
            url_ += "DepartmentDepartmentNameFilter=" + encodeURIComponent("" + departmentDepartmentNameFilter) + "&"; 
        if (organizationUnitDisplayNameFilter !== undefined)
            url_ += "OrganizationUnitDisplayNameFilter=" + encodeURIComponent("" + organizationUnitDisplayNameFilter) + "&"; 
        if (staffFULL_NAMEFilter !== undefined)
            url_ += "StaffFULL_NAMEFilter=" + encodeURIComponent("" + staffFULL_NAMEFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetStaffForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetStaffForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStaffForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetStaffForView.fromJS(resultData200) : new PagedResultDtoOfGetStaffForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetStaffForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStaffForEdit(id: number | null | undefined): Observable<GetStaffForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetStaffForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetStaffForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStaffForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaffForEdit(response: HttpResponseBase): Observable<GetStaffForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStaffForEditOutput.fromJS(resultData200) : new GetStaffForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStaffForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditStaffDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAutoranDrivers(): Observable<{ [key: string] : string; }> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetAutoranDrivers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAutoranDrivers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAutoranDrivers(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : string; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : string; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetAutoranDrivers(response: HttpResponseBase): Observable<{ [key: string] : string; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : string; }>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param fULL_NAMEFilter (optional) 
     * @param genderFilter (optional) 
     * @param workMobileFilter (optional) 
     * @param jobTitleFilter (optional) 
     * @param professionFilter (optional) 
     * @param pHONEFilter (optional) 
     * @param mOBILEFilter (optional) 
     * @param pOSISTIONFilter (optional) 
     * @param eMPLOYMENT_TYPEFilter (optional) 
     * @param maxPROJECT_IDFilter (optional) 
     * @param minPROJECT_IDFilter (optional) 
     * @param maxDOBFilter (optional) 
     * @param minDOBFilter (optional) 
     * @param maxDOEFilter (optional) 
     * @param minDOEFilter (optional) 
     * @param lOGIN_NAMEFilter (optional) 
     * @param lOGIN_PASSFilter (optional) 
     * @param iS_ACTIVEFilter (optional) 
     * @param rolesFilter (optional) 
     * @param emailFilter (optional) 
     * @param skypeFilter (optional) 
     * @param personalIMFilter (optional) 
     * @param homeFaxFilter (optional) 
     * @param homePhoneFilter (optional) 
     * @param addressFilter (optional) 
     * @param postalCodeFilter (optional) 
     * @param workExtensionFilter (optional) 
     * @param maxlastUpdatedFilter (optional) 
     * @param minlastUpdatedFilter (optional) 
     * @param maxEmployeestartDateFilter (optional) 
     * @param minEmployeestartDateFilter (optional) 
     * @param maxCostFilter (optional) 
     * @param minCostFilter (optional) 
     * @param maxTimsheetCheckByEmpFilter (optional) 
     * @param minTimsheetCheckByEmpFilter (optional) 
     * @param maxautoranIDFilter (optional) 
     * @param minautoranIDFilter (optional) 
     * @param iSDriverFilter (optional) 
     * @param maxXFilter (optional) 
     * @param minXFilter (optional) 
     * @param maxYFilter (optional) 
     * @param minYFilter (optional) 
     * @param dayFilter (optional) 
     * @param maxDisplayOrderFilter (optional) 
     * @param minDisplayOrderFilter (optional) 
     * @param isStopFilter (optional) 
     * @param maxautoranIDServerFilter (optional) 
     * @param minautoranIDServerFilter (optional) 
     * @param iDNumberFilter (optional) 
     * @param klushNoFilter (optional) 
     * @param maxwelfareClockIdFilter (optional) 
     * @param minwelfareClockIdFilter (optional) 
     * @param departmentDepartmentNameFilter (optional) 
     * @param organizationUnitDisplayNameFilter (optional) 
     * @param staffFULL_NAMEFilter (optional) 
     * @return Success
     */
    getStaffsToExcel(filter: string | null | undefined, fULL_NAMEFilter: string | null | undefined, genderFilter: string | null | undefined, workMobileFilter: string | null | undefined, jobTitleFilter: string | null | undefined, professionFilter: string | null | undefined, pHONEFilter: string | null | undefined, mOBILEFilter: string | null | undefined, pOSISTIONFilter: string | null | undefined, eMPLOYMENT_TYPEFilter: string | null | undefined, maxPROJECT_IDFilter: number | null | undefined, minPROJECT_IDFilter: number | null | undefined, maxDOBFilter: moment.Moment | null | undefined, minDOBFilter: moment.Moment | null | undefined, maxDOEFilter: moment.Moment | null | undefined, minDOEFilter: moment.Moment | null | undefined, lOGIN_NAMEFilter: string | null | undefined, lOGIN_PASSFilter: string | null | undefined, iS_ACTIVEFilter: number | null | undefined, rolesFilter: string | null | undefined, emailFilter: string | null | undefined, skypeFilter: string | null | undefined, personalIMFilter: string | null | undefined, homeFaxFilter: string | null | undefined, homePhoneFilter: string | null | undefined, addressFilter: string | null | undefined, postalCodeFilter: string | null | undefined, workExtensionFilter: string | null | undefined, maxlastUpdatedFilter: moment.Moment | null | undefined, minlastUpdatedFilter: moment.Moment | null | undefined, maxEmployeestartDateFilter: moment.Moment | null | undefined, minEmployeestartDateFilter: moment.Moment | null | undefined, maxCostFilter: number | null | undefined, minCostFilter: number | null | undefined, maxTimsheetCheckByEmpFilter: number | null | undefined, minTimsheetCheckByEmpFilter: number | null | undefined, maxautoranIDFilter: number | null | undefined, minautoranIDFilter: number | null | undefined, iSDriverFilter: number | null | undefined, maxXFilter: number | null | undefined, minXFilter: number | null | undefined, maxYFilter: number | null | undefined, minYFilter: number | null | undefined, dayFilter: string | null | undefined, maxDisplayOrderFilter: number | null | undefined, minDisplayOrderFilter: number | null | undefined, isStopFilter: number | null | undefined, maxautoranIDServerFilter: number | null | undefined, minautoranIDServerFilter: number | null | undefined, iDNumberFilter: string | null | undefined, klushNoFilter: string | null | undefined, maxwelfareClockIdFilter: number | null | undefined, minwelfareClockIdFilter: number | null | undefined, departmentDepartmentNameFilter: string | null | undefined, organizationUnitDisplayNameFilter: string | null | undefined, staffFULL_NAMEFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetStaffsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (fULL_NAMEFilter !== undefined)
            url_ += "FULL_NAMEFilter=" + encodeURIComponent("" + fULL_NAMEFilter) + "&"; 
        if (genderFilter !== undefined)
            url_ += "genderFilter=" + encodeURIComponent("" + genderFilter) + "&"; 
        if (workMobileFilter !== undefined)
            url_ += "workMobileFilter=" + encodeURIComponent("" + workMobileFilter) + "&"; 
        if (jobTitleFilter !== undefined)
            url_ += "jobTitleFilter=" + encodeURIComponent("" + jobTitleFilter) + "&"; 
        if (professionFilter !== undefined)
            url_ += "professionFilter=" + encodeURIComponent("" + professionFilter) + "&"; 
        if (pHONEFilter !== undefined)
            url_ += "PHONEFilter=" + encodeURIComponent("" + pHONEFilter) + "&"; 
        if (mOBILEFilter !== undefined)
            url_ += "MOBILEFilter=" + encodeURIComponent("" + mOBILEFilter) + "&"; 
        if (pOSISTIONFilter !== undefined)
            url_ += "POSISTIONFilter=" + encodeURIComponent("" + pOSISTIONFilter) + "&"; 
        if (eMPLOYMENT_TYPEFilter !== undefined)
            url_ += "EMPLOYMENT_TYPEFilter=" + encodeURIComponent("" + eMPLOYMENT_TYPEFilter) + "&"; 
        if (maxPROJECT_IDFilter !== undefined)
            url_ += "MaxPROJECT_IDFilter=" + encodeURIComponent("" + maxPROJECT_IDFilter) + "&"; 
        if (minPROJECT_IDFilter !== undefined)
            url_ += "MinPROJECT_IDFilter=" + encodeURIComponent("" + minPROJECT_IDFilter) + "&"; 
        if (maxDOBFilter !== undefined)
            url_ += "MaxDOBFilter=" + encodeURIComponent(maxDOBFilter ? "" + maxDOBFilter.toJSON() : "") + "&"; 
        if (minDOBFilter !== undefined)
            url_ += "MinDOBFilter=" + encodeURIComponent(minDOBFilter ? "" + minDOBFilter.toJSON() : "") + "&"; 
        if (maxDOEFilter !== undefined)
            url_ += "MaxDOEFilter=" + encodeURIComponent(maxDOEFilter ? "" + maxDOEFilter.toJSON() : "") + "&"; 
        if (minDOEFilter !== undefined)
            url_ += "MinDOEFilter=" + encodeURIComponent(minDOEFilter ? "" + minDOEFilter.toJSON() : "") + "&"; 
        if (lOGIN_NAMEFilter !== undefined)
            url_ += "LOGIN_NAMEFilter=" + encodeURIComponent("" + lOGIN_NAMEFilter) + "&"; 
        if (lOGIN_PASSFilter !== undefined)
            url_ += "LOGIN_PASSFilter=" + encodeURIComponent("" + lOGIN_PASSFilter) + "&"; 
        if (iS_ACTIVEFilter !== undefined)
            url_ += "IS_ACTIVEFilter=" + encodeURIComponent("" + iS_ACTIVEFilter) + "&"; 
        if (rolesFilter !== undefined)
            url_ += "RolesFilter=" + encodeURIComponent("" + rolesFilter) + "&"; 
        if (emailFilter !== undefined)
            url_ += "emailFilter=" + encodeURIComponent("" + emailFilter) + "&"; 
        if (skypeFilter !== undefined)
            url_ += "skypeFilter=" + encodeURIComponent("" + skypeFilter) + "&"; 
        if (personalIMFilter !== undefined)
            url_ += "personalIMFilter=" + encodeURIComponent("" + personalIMFilter) + "&"; 
        if (homeFaxFilter !== undefined)
            url_ += "homeFaxFilter=" + encodeURIComponent("" + homeFaxFilter) + "&"; 
        if (homePhoneFilter !== undefined)
            url_ += "homePhoneFilter=" + encodeURIComponent("" + homePhoneFilter) + "&"; 
        if (addressFilter !== undefined)
            url_ += "addressFilter=" + encodeURIComponent("" + addressFilter) + "&"; 
        if (postalCodeFilter !== undefined)
            url_ += "postalCodeFilter=" + encodeURIComponent("" + postalCodeFilter) + "&"; 
        if (workExtensionFilter !== undefined)
            url_ += "workExtensionFilter=" + encodeURIComponent("" + workExtensionFilter) + "&"; 
        if (maxlastUpdatedFilter !== undefined)
            url_ += "MaxlastUpdatedFilter=" + encodeURIComponent(maxlastUpdatedFilter ? "" + maxlastUpdatedFilter.toJSON() : "") + "&"; 
        if (minlastUpdatedFilter !== undefined)
            url_ += "MinlastUpdatedFilter=" + encodeURIComponent(minlastUpdatedFilter ? "" + minlastUpdatedFilter.toJSON() : "") + "&"; 
        if (maxEmployeestartDateFilter !== undefined)
            url_ += "MaxEmployeestartDateFilter=" + encodeURIComponent(maxEmployeestartDateFilter ? "" + maxEmployeestartDateFilter.toJSON() : "") + "&"; 
        if (minEmployeestartDateFilter !== undefined)
            url_ += "MinEmployeestartDateFilter=" + encodeURIComponent(minEmployeestartDateFilter ? "" + minEmployeestartDateFilter.toJSON() : "") + "&"; 
        if (maxCostFilter !== undefined)
            url_ += "MaxCostFilter=" + encodeURIComponent("" + maxCostFilter) + "&"; 
        if (minCostFilter !== undefined)
            url_ += "MinCostFilter=" + encodeURIComponent("" + minCostFilter) + "&"; 
        if (maxTimsheetCheckByEmpFilter !== undefined)
            url_ += "MaxTimsheetCheckByEmpFilter=" + encodeURIComponent("" + maxTimsheetCheckByEmpFilter) + "&"; 
        if (minTimsheetCheckByEmpFilter !== undefined)
            url_ += "MinTimsheetCheckByEmpFilter=" + encodeURIComponent("" + minTimsheetCheckByEmpFilter) + "&"; 
        if (maxautoranIDFilter !== undefined)
            url_ += "MaxautoranIDFilter=" + encodeURIComponent("" + maxautoranIDFilter) + "&"; 
        if (minautoranIDFilter !== undefined)
            url_ += "MinautoranIDFilter=" + encodeURIComponent("" + minautoranIDFilter) + "&"; 
        if (iSDriverFilter !== undefined)
            url_ += "ISDriverFilter=" + encodeURIComponent("" + iSDriverFilter) + "&"; 
        if (maxXFilter !== undefined)
            url_ += "MaxXFilter=" + encodeURIComponent("" + maxXFilter) + "&"; 
        if (minXFilter !== undefined)
            url_ += "MinXFilter=" + encodeURIComponent("" + minXFilter) + "&"; 
        if (maxYFilter !== undefined)
            url_ += "MaxYFilter=" + encodeURIComponent("" + maxYFilter) + "&"; 
        if (minYFilter !== undefined)
            url_ += "MinYFilter=" + encodeURIComponent("" + minYFilter) + "&"; 
        if (dayFilter !== undefined)
            url_ += "DayFilter=" + encodeURIComponent("" + dayFilter) + "&"; 
        if (maxDisplayOrderFilter !== undefined)
            url_ += "MaxDisplayOrderFilter=" + encodeURIComponent("" + maxDisplayOrderFilter) + "&"; 
        if (minDisplayOrderFilter !== undefined)
            url_ += "MinDisplayOrderFilter=" + encodeURIComponent("" + minDisplayOrderFilter) + "&"; 
        if (isStopFilter !== undefined)
            url_ += "IsStopFilter=" + encodeURIComponent("" + isStopFilter) + "&"; 
        if (maxautoranIDServerFilter !== undefined)
            url_ += "MaxautoranIDServerFilter=" + encodeURIComponent("" + maxautoranIDServerFilter) + "&"; 
        if (minautoranIDServerFilter !== undefined)
            url_ += "MinautoranIDServerFilter=" + encodeURIComponent("" + minautoranIDServerFilter) + "&"; 
        if (iDNumberFilter !== undefined)
            url_ += "IDNumberFilter=" + encodeURIComponent("" + iDNumberFilter) + "&"; 
        if (klushNoFilter !== undefined)
            url_ += "KlushNoFilter=" + encodeURIComponent("" + klushNoFilter) + "&"; 
        if (maxwelfareClockIdFilter !== undefined)
            url_ += "MaxwelfareClockIdFilter=" + encodeURIComponent("" + maxwelfareClockIdFilter) + "&"; 
        if (minwelfareClockIdFilter !== undefined)
            url_ += "MinwelfareClockIdFilter=" + encodeURIComponent("" + minwelfareClockIdFilter) + "&"; 
        if (departmentDepartmentNameFilter !== undefined)
            url_ += "DepartmentDepartmentNameFilter=" + encodeURIComponent("" + departmentDepartmentNameFilter) + "&"; 
        if (organizationUnitDisplayNameFilter !== undefined)
            url_ += "OrganizationUnitDisplayNameFilter=" + encodeURIComponent("" + organizationUnitDisplayNameFilter) + "&"; 
        if (staffFULL_NAMEFilter !== undefined)
            url_ += "StaffFULL_NAMEFilter=" + encodeURIComponent("" + staffFULL_NAMEFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaffsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDepartmentForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDepartmentLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetAllDepartmentForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDepartmentForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDepartmentForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDepartmentLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDepartmentLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDepartmentForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfDepartmentLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDepartmentLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfDepartmentLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDepartmentLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllStaffForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfStaffLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetAllStaffForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStaffForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStaffForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStaffLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStaffLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStaffForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfStaffLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfStaffLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfStaffLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStaffLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOrganizationUnitForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Staffs/GetAllOrganizationUnitForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnitForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnitForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganizationUnitForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitLookupTableDto>(<any>null);
    }
}

@Injectable()
export class StationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Stations/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param isStopFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param locationNameHebrewFilter (optional) 
     * @param typeFilter (optional) 
     * @param isMarkFilter (optional) 
     * @param isSaveFilter (optional) 
     * @param maxcheckDistanceFilter (optional) 
     * @param mincheckDistanceFilter (optional) 
     * @param isPathFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getRoutesofStation(filter: string | null | undefined, locationNameFilter: string | null | undefined, maxLatitudeFilter: number | null | undefined, minLatitudeFilter: number | null | undefined, maxLongitudeFilter: number | null | undefined, minLongitudeFilter: number | null | undefined, isStopFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, locationNameHebrewFilter: string | null | undefined, typeFilter: string | null | undefined, isMarkFilter: number | null | undefined, isSaveFilter: number | null | undefined, maxcheckDistanceFilter: number | null | undefined, mincheckDistanceFilter: number | null | undefined, isPathFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRouteForView> {
        let url_ = this.baseUrl + "/api/services/app/Stations/GetRoutesofStation?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&"; 
        if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&"; 
        if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&"; 
        if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&"; 
        if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&"; 
        if (isStopFilter !== undefined)
            url_ += "IsStopFilter=" + encodeURIComponent("" + isStopFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (locationNameHebrewFilter !== undefined)
            url_ += "LocationNameHebrewFilter=" + encodeURIComponent("" + locationNameHebrewFilter) + "&"; 
        if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (isMarkFilter !== undefined)
            url_ += "isMarkFilter=" + encodeURIComponent("" + isMarkFilter) + "&"; 
        if (isSaveFilter !== undefined)
            url_ += "IsSaveFilter=" + encodeURIComponent("" + isSaveFilter) + "&"; 
        if (maxcheckDistanceFilter !== undefined)
            url_ += "MaxcheckDistanceFilter=" + encodeURIComponent("" + maxcheckDistanceFilter) + "&"; 
        if (mincheckDistanceFilter !== undefined)
            url_ += "MincheckDistanceFilter=" + encodeURIComponent("" + mincheckDistanceFilter) + "&"; 
        if (isPathFilter !== undefined)
            url_ += "IsPathFilter=" + encodeURIComponent("" + isPathFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoutesofStation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoutesofStation(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRouteForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRouteForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoutesofStation(response: HttpResponseBase): Observable<PagedResultDtoOfGetRouteForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetRouteForView.fromJS(resultData200) : new PagedResultDtoOfGetRouteForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRouteForView>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param isStopFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param locationNameHebrewFilter (optional) 
     * @param typeFilter (optional) 
     * @param isMarkFilter (optional) 
     * @param isSaveFilter (optional) 
     * @param maxcheckDistanceFilter (optional) 
     * @param mincheckDistanceFilter (optional) 
     * @param isPathFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, locationNameFilter: string | null | undefined, maxLatitudeFilter: number | null | undefined, minLatitudeFilter: number | null | undefined, maxLongitudeFilter: number | null | undefined, minLongitudeFilter: number | null | undefined, isStopFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, locationNameHebrewFilter: string | null | undefined, typeFilter: string | null | undefined, isMarkFilter: number | null | undefined, isSaveFilter: number | null | undefined, maxcheckDistanceFilter: number | null | undefined, mincheckDistanceFilter: number | null | undefined, isPathFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetStationForView> {
        let url_ = this.baseUrl + "/api/services/app/Stations/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&"; 
        if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&"; 
        if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&"; 
        if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&"; 
        if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&"; 
        if (isStopFilter !== undefined)
            url_ += "IsStopFilter=" + encodeURIComponent("" + isStopFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (locationNameHebrewFilter !== undefined)
            url_ += "LocationNameHebrewFilter=" + encodeURIComponent("" + locationNameHebrewFilter) + "&"; 
        if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (isMarkFilter !== undefined)
            url_ += "isMarkFilter=" + encodeURIComponent("" + isMarkFilter) + "&"; 
        if (isSaveFilter !== undefined)
            url_ += "IsSaveFilter=" + encodeURIComponent("" + isSaveFilter) + "&"; 
        if (maxcheckDistanceFilter !== undefined)
            url_ += "MaxcheckDistanceFilter=" + encodeURIComponent("" + maxcheckDistanceFilter) + "&"; 
        if (mincheckDistanceFilter !== undefined)
            url_ += "MincheckDistanceFilter=" + encodeURIComponent("" + mincheckDistanceFilter) + "&"; 
        if (isPathFilter !== undefined)
            url_ += "IsPathFilter=" + encodeURIComponent("" + isPathFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetStationForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetStationForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetStationForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetStationForView.fromJS(resultData200) : new PagedResultDtoOfGetStationForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetStationForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStationForEdit(id: number | null | undefined): Observable<GetStationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Stations/GetStationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetStationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStationForEdit(response: HttpResponseBase): Observable<GetStationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStationForEditOutput.fromJS(resultData200) : new GetStationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditStationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Stations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Stations/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param isStopFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param locationNameHebrewFilter (optional) 
     * @param typeFilter (optional) 
     * @param isMarkFilter (optional) 
     * @param isSaveFilter (optional) 
     * @param maxcheckDistanceFilter (optional) 
     * @param mincheckDistanceFilter (optional) 
     * @param isPathFilter (optional) 
     * @return Success
     */
    getStationsToExcel(filter: string | null | undefined, locationNameFilter: string | null | undefined, maxLatitudeFilter: number | null | undefined, minLatitudeFilter: number | null | undefined, maxLongitudeFilter: number | null | undefined, minLongitudeFilter: number | null | undefined, isStopFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, locationNameHebrewFilter: string | null | undefined, typeFilter: string | null | undefined, isMarkFilter: number | null | undefined, isSaveFilter: number | null | undefined, maxcheckDistanceFilter: number | null | undefined, mincheckDistanceFilter: number | null | undefined, isPathFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Stations/GetStationsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&"; 
        if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&"; 
        if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&"; 
        if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&"; 
        if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&"; 
        if (isStopFilter !== undefined)
            url_ += "IsStopFilter=" + encodeURIComponent("" + isStopFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (locationNameHebrewFilter !== undefined)
            url_ += "LocationNameHebrewFilter=" + encodeURIComponent("" + locationNameHebrewFilter) + "&"; 
        if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (isMarkFilter !== undefined)
            url_ += "isMarkFilter=" + encodeURIComponent("" + isMarkFilter) + "&"; 
        if (isSaveFilter !== undefined)
            url_ += "IsSaveFilter=" + encodeURIComponent("" + isSaveFilter) + "&"; 
        if (maxcheckDistanceFilter !== undefined)
            url_ += "MaxcheckDistanceFilter=" + encodeURIComponent("" + maxcheckDistanceFilter) + "&"; 
        if (mincheckDistanceFilter !== undefined)
            url_ += "MincheckDistanceFilter=" + encodeURIComponent("" + mincheckDistanceFilter) + "&"; 
        if (isPathFilter !== undefined)
            url_ += "IsPathFilter=" + encodeURIComponent("" + isPathFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStationsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    confirmPayment(input: StripeConfirmPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createSubscription(input: StripeCreateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSubscription(input: StripeUpdateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StripeConfigurationDto.fromJS(resultData200) : new StripeConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RefreshTokenResult.fromJS(resultData200) : new RefreshTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TripActualServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param timeSpanFilter (optional) 
     * @param maxEndStationIDFilter (optional) 
     * @param minEndStationIDFilter (optional) 
     * @param maxStartStationIDFilter (optional) 
     * @param minStartStationIDFilter (optional) 
     * @param startStationFilter (optional) 
     * @param endStationFilter (optional) 
     * @param maxTripDateFilter (optional) 
     * @param minTripDateFilter (optional) 
     * @param controlStartTimeFilter (optional) 
     * @param isdoneFilter (optional) 
     * @param routeLineNumberFilter (optional) 
     * @param calenderBusTenantIdFilter (optional) 
     * @param tripPlanedTenantIdFilter (optional) 
     * @param tripByMinistryTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, timeSpanFilter: string | null | undefined, maxEndStationIDFilter: number | null | undefined, minEndStationIDFilter: number | null | undefined, maxStartStationIDFilter: number | null | undefined, minStartStationIDFilter: number | null | undefined, startStationFilter: string | null | undefined, endStationFilter: string | null | undefined, maxTripDateFilter: moment.Moment | null | undefined, minTripDateFilter: moment.Moment | null | undefined, controlStartTimeFilter: string | null | undefined, isdoneFilter: number | null | undefined, routeLineNumberFilter: string | null | undefined, calenderBusTenantIdFilter: string | null | undefined, tripPlanedTenantIdFilter: string | null | undefined, tripByMinistryTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripActualForView> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (timeSpanFilter !== undefined)
            url_ += "TimeSpanFilter=" + encodeURIComponent("" + timeSpanFilter) + "&"; 
        if (maxEndStationIDFilter !== undefined)
            url_ += "MaxEndStationIDFilter=" + encodeURIComponent("" + maxEndStationIDFilter) + "&"; 
        if (minEndStationIDFilter !== undefined)
            url_ += "MinEndStationIDFilter=" + encodeURIComponent("" + minEndStationIDFilter) + "&"; 
        if (maxStartStationIDFilter !== undefined)
            url_ += "MaxStartStationIDFilter=" + encodeURIComponent("" + maxStartStationIDFilter) + "&"; 
        if (minStartStationIDFilter !== undefined)
            url_ += "MinStartStationIDFilter=" + encodeURIComponent("" + minStartStationIDFilter) + "&"; 
        if (startStationFilter !== undefined)
            url_ += "StartStationFilter=" + encodeURIComponent("" + startStationFilter) + "&"; 
        if (endStationFilter !== undefined)
            url_ += "EndStationFilter=" + encodeURIComponent("" + endStationFilter) + "&"; 
        if (maxTripDateFilter !== undefined)
            url_ += "MaxTripDateFilter=" + encodeURIComponent(maxTripDateFilter ? "" + maxTripDateFilter.toJSON() : "") + "&"; 
        if (minTripDateFilter !== undefined)
            url_ += "MinTripDateFilter=" + encodeURIComponent(minTripDateFilter ? "" + minTripDateFilter.toJSON() : "") + "&"; 
        if (controlStartTimeFilter !== undefined)
            url_ += "ControlStartTimeFilter=" + encodeURIComponent("" + controlStartTimeFilter) + "&"; 
        if (isdoneFilter !== undefined)
            url_ += "isdoneFilter=" + encodeURIComponent("" + isdoneFilter) + "&"; 
        if (routeLineNumberFilter !== undefined)
            url_ += "RouteLineNumberFilter=" + encodeURIComponent("" + routeLineNumberFilter) + "&"; 
        if (calenderBusTenantIdFilter !== undefined)
            url_ += "CalenderBusTenantIdFilter=" + encodeURIComponent("" + calenderBusTenantIdFilter) + "&"; 
        if (tripPlanedTenantIdFilter !== undefined)
            url_ += "TripPlanedTenantIdFilter=" + encodeURIComponent("" + tripPlanedTenantIdFilter) + "&"; 
        if (tripByMinistryTenantIdFilter !== undefined)
            url_ += "TripByMinistryTenantIdFilter=" + encodeURIComponent("" + tripByMinistryTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripActualForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripActualForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripActualForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripActualForView.fromJS(resultData200) : new PagedResultDtoOfGetTripActualForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripActualForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripActualForEdit(id: number | null | undefined): Observable<GetTripActualForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetTripActualForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripActualForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripActualForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripActualForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripActualForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripActualForEdit(response: HttpResponseBase): Observable<GetTripActualForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripActualForEditOutput.fromJS(resultData200) : new GetTripActualForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripActualForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripActualDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param timeSpanFilter (optional) 
     * @param maxEndStationIDFilter (optional) 
     * @param minEndStationIDFilter (optional) 
     * @param maxStartStationIDFilter (optional) 
     * @param minStartStationIDFilter (optional) 
     * @param startStationFilter (optional) 
     * @param endStationFilter (optional) 
     * @param maxTripDateFilter (optional) 
     * @param minTripDateFilter (optional) 
     * @param controlStartTimeFilter (optional) 
     * @param isdoneFilter (optional) 
     * @param routeLineNumberFilter (optional) 
     * @param calenderBusTenantIdFilter (optional) 
     * @param tripPlanedTenantIdFilter (optional) 
     * @param tripByMinistryTenantIdFilter (optional) 
     * @return Success
     */
    getTripActualToExcel(filter: string | null | undefined, timeSpanFilter: string | null | undefined, maxEndStationIDFilter: number | null | undefined, minEndStationIDFilter: number | null | undefined, maxStartStationIDFilter: number | null | undefined, minStartStationIDFilter: number | null | undefined, startStationFilter: string | null | undefined, endStationFilter: string | null | undefined, maxTripDateFilter: moment.Moment | null | undefined, minTripDateFilter: moment.Moment | null | undefined, controlStartTimeFilter: string | null | undefined, isdoneFilter: number | null | undefined, routeLineNumberFilter: string | null | undefined, calenderBusTenantIdFilter: string | null | undefined, tripPlanedTenantIdFilter: string | null | undefined, tripByMinistryTenantIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetTripActualToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (timeSpanFilter !== undefined)
            url_ += "TimeSpanFilter=" + encodeURIComponent("" + timeSpanFilter) + "&"; 
        if (maxEndStationIDFilter !== undefined)
            url_ += "MaxEndStationIDFilter=" + encodeURIComponent("" + maxEndStationIDFilter) + "&"; 
        if (minEndStationIDFilter !== undefined)
            url_ += "MinEndStationIDFilter=" + encodeURIComponent("" + minEndStationIDFilter) + "&"; 
        if (maxStartStationIDFilter !== undefined)
            url_ += "MaxStartStationIDFilter=" + encodeURIComponent("" + maxStartStationIDFilter) + "&"; 
        if (minStartStationIDFilter !== undefined)
            url_ += "MinStartStationIDFilter=" + encodeURIComponent("" + minStartStationIDFilter) + "&"; 
        if (startStationFilter !== undefined)
            url_ += "StartStationFilter=" + encodeURIComponent("" + startStationFilter) + "&"; 
        if (endStationFilter !== undefined)
            url_ += "EndStationFilter=" + encodeURIComponent("" + endStationFilter) + "&"; 
        if (maxTripDateFilter !== undefined)
            url_ += "MaxTripDateFilter=" + encodeURIComponent(maxTripDateFilter ? "" + maxTripDateFilter.toJSON() : "") + "&"; 
        if (minTripDateFilter !== undefined)
            url_ += "MinTripDateFilter=" + encodeURIComponent(minTripDateFilter ? "" + minTripDateFilter.toJSON() : "") + "&"; 
        if (controlStartTimeFilter !== undefined)
            url_ += "ControlStartTimeFilter=" + encodeURIComponent("" + controlStartTimeFilter) + "&"; 
        if (isdoneFilter !== undefined)
            url_ += "isdoneFilter=" + encodeURIComponent("" + isdoneFilter) + "&"; 
        if (routeLineNumberFilter !== undefined)
            url_ += "RouteLineNumberFilter=" + encodeURIComponent("" + routeLineNumberFilter) + "&"; 
        if (calenderBusTenantIdFilter !== undefined)
            url_ += "CalenderBusTenantIdFilter=" + encodeURIComponent("" + calenderBusTenantIdFilter) + "&"; 
        if (tripPlanedTenantIdFilter !== undefined)
            url_ += "TripPlanedTenantIdFilter=" + encodeURIComponent("" + tripPlanedTenantIdFilter) + "&"; 
        if (tripByMinistryTenantIdFilter !== undefined)
            url_ += "TripByMinistryTenantIdFilter=" + encodeURIComponent("" + tripByMinistryTenantIdFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripActualToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripActualToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripActualToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRouteForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRouteLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetAllRouteForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRouteForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRouteForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRouteLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRouteLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRouteForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRouteLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRouteLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRouteLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRouteLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCalenderBusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCalenderBusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetAllCalenderBusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCalenderBusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCalenderBusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCalenderBusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCalenderBusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCalenderBusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCalenderBusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCalenderBusLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfCalenderBusLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCalenderBusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTripPlanedForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTripPlanedLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetAllTripPlanedForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTripPlanedForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTripPlanedForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTripPlanedLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTripPlanedLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTripPlanedForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTripPlanedLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTripPlanedLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfTripPlanedLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTripPlanedLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTripByMinistryForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTripByMinistryLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActual/GetAllTripByMinistryForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTripByMinistryForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTripByMinistryForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTripByMinistryLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTripByMinistryLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTripByMinistryForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTripByMinistryLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTripByMinistryLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfTripByMinistryLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTripByMinistryLookupTableDto>(<any>null);
    }
}

@Injectable()
export class TripActualRoutes_StationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripActualRoutes_Station/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxRoutesIDFilter (optional) 
     * @param minRoutesIDFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param maxStationOrderFilter (optional) 
     * @param minStationOrderFilter (optional) 
     * @param maxDistanceFStartFilter (optional) 
     * @param minDistanceFStartFilter (optional) 
     * @param maxDistanceFPrviousStFilter (optional) 
     * @param minDistanceFPrviousStFilter (optional) 
     * @param timefrStartStationFilter (optional) 
     * @param timefrPrviousStationFilter (optional) 
     * @param timeSpendonStationFilter (optional) 
     * @param maxTripActualIDFilter (optional) 
     * @param minTripActualIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxRoutesIDFilter: number | null | undefined, minRoutesIDFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, maxStationOrderFilter: number | null | undefined, minStationOrderFilter: number | null | undefined, maxDistanceFStartFilter: number | null | undefined, minDistanceFStartFilter: number | null | undefined, maxDistanceFPrviousStFilter: number | null | undefined, minDistanceFPrviousStFilter: number | null | undefined, timefrStartStationFilter: string | null | undefined, timefrPrviousStationFilter: string | null | undefined, timeSpendonStationFilter: string | null | undefined, maxTripActualIDFilter: number | null | undefined, minTripActualIDFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripActualRoutes_StationForView> {
        let url_ = this.baseUrl + "/api/services/app/TripActualRoutes_Station/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxRoutesIDFilter !== undefined)
            url_ += "MaxRoutesIDFilter=" + encodeURIComponent("" + maxRoutesIDFilter) + "&"; 
        if (minRoutesIDFilter !== undefined)
            url_ += "MinRoutesIDFilter=" + encodeURIComponent("" + minRoutesIDFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (maxStationOrderFilter !== undefined)
            url_ += "MaxStationOrderFilter=" + encodeURIComponent("" + maxStationOrderFilter) + "&"; 
        if (minStationOrderFilter !== undefined)
            url_ += "MinStationOrderFilter=" + encodeURIComponent("" + minStationOrderFilter) + "&"; 
        if (maxDistanceFStartFilter !== undefined)
            url_ += "MaxDistanceFStartFilter=" + encodeURIComponent("" + maxDistanceFStartFilter) + "&"; 
        if (minDistanceFStartFilter !== undefined)
            url_ += "MinDistanceFStartFilter=" + encodeURIComponent("" + minDistanceFStartFilter) + "&"; 
        if (maxDistanceFPrviousStFilter !== undefined)
            url_ += "MaxDistanceFPrviousStFilter=" + encodeURIComponent("" + maxDistanceFPrviousStFilter) + "&"; 
        if (minDistanceFPrviousStFilter !== undefined)
            url_ += "MinDistanceFPrviousStFilter=" + encodeURIComponent("" + minDistanceFPrviousStFilter) + "&"; 
        if (timefrStartStationFilter !== undefined)
            url_ += "TimefrStartStationFilter=" + encodeURIComponent("" + timefrStartStationFilter) + "&"; 
        if (timefrPrviousStationFilter !== undefined)
            url_ += "TimefrPrviousStationFilter=" + encodeURIComponent("" + timefrPrviousStationFilter) + "&"; 
        if (timeSpendonStationFilter !== undefined)
            url_ += "TimeSpendonStationFilter=" + encodeURIComponent("" + timeSpendonStationFilter) + "&"; 
        if (maxTripActualIDFilter !== undefined)
            url_ += "MaxTripActualIDFilter=" + encodeURIComponent("" + maxTripActualIDFilter) + "&"; 
        if (minTripActualIDFilter !== undefined)
            url_ += "MinTripActualIDFilter=" + encodeURIComponent("" + minTripActualIDFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripActualRoutes_StationForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripActualRoutes_StationForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripActualRoutes_StationForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripActualRoutes_StationForView.fromJS(resultData200) : new PagedResultDtoOfGetTripActualRoutes_StationForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripActualRoutes_StationForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripActualRoutes_StationForEdit(id: number | null | undefined): Observable<GetTripActualRoutes_StationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripActualRoutes_Station/GetTripActualRoutes_StationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripActualRoutes_StationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripActualRoutes_StationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripActualRoutes_StationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripActualRoutes_StationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripActualRoutes_StationForEdit(response: HttpResponseBase): Observable<GetTripActualRoutes_StationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripActualRoutes_StationForEditOutput.fromJS(resultData200) : new GetTripActualRoutes_StationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripActualRoutes_StationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripActualRoutes_StationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripActualRoutes_Station/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripActualRoutes_Station/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxRoutesIDFilter (optional) 
     * @param minRoutesIDFilter (optional) 
     * @param maxStationCodeFilter (optional) 
     * @param minStationCodeFilter (optional) 
     * @param maxStationOrderFilter (optional) 
     * @param minStationOrderFilter (optional) 
     * @param maxDistanceFStartFilter (optional) 
     * @param minDistanceFStartFilter (optional) 
     * @param maxDistanceFPrviousStFilter (optional) 
     * @param minDistanceFPrviousStFilter (optional) 
     * @param timefrStartStationFilter (optional) 
     * @param timefrPrviousStationFilter (optional) 
     * @param timeSpendonStationFilter (optional) 
     * @param maxTripActualIDFilter (optional) 
     * @param minTripActualIDFilter (optional) 
     * @return Success
     */
    getTripActualRoutes_StationToExcel(filter: string | null | undefined, maxRoutesIDFilter: number | null | undefined, minRoutesIDFilter: number | null | undefined, maxStationCodeFilter: number | null | undefined, minStationCodeFilter: number | null | undefined, maxStationOrderFilter: number | null | undefined, minStationOrderFilter: number | null | undefined, maxDistanceFStartFilter: number | null | undefined, minDistanceFStartFilter: number | null | undefined, maxDistanceFPrviousStFilter: number | null | undefined, minDistanceFPrviousStFilter: number | null | undefined, timefrStartStationFilter: string | null | undefined, timefrPrviousStationFilter: string | null | undefined, timeSpendonStationFilter: string | null | undefined, maxTripActualIDFilter: number | null | undefined, minTripActualIDFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActualRoutes_Station/GetTripActualRoutes_StationToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxRoutesIDFilter !== undefined)
            url_ += "MaxRoutesIDFilter=" + encodeURIComponent("" + maxRoutesIDFilter) + "&"; 
        if (minRoutesIDFilter !== undefined)
            url_ += "MinRoutesIDFilter=" + encodeURIComponent("" + minRoutesIDFilter) + "&"; 
        if (maxStationCodeFilter !== undefined)
            url_ += "MaxStationCodeFilter=" + encodeURIComponent("" + maxStationCodeFilter) + "&"; 
        if (minStationCodeFilter !== undefined)
            url_ += "MinStationCodeFilter=" + encodeURIComponent("" + minStationCodeFilter) + "&"; 
        if (maxStationOrderFilter !== undefined)
            url_ += "MaxStationOrderFilter=" + encodeURIComponent("" + maxStationOrderFilter) + "&"; 
        if (minStationOrderFilter !== undefined)
            url_ += "MinStationOrderFilter=" + encodeURIComponent("" + minStationOrderFilter) + "&"; 
        if (maxDistanceFStartFilter !== undefined)
            url_ += "MaxDistanceFStartFilter=" + encodeURIComponent("" + maxDistanceFStartFilter) + "&"; 
        if (minDistanceFStartFilter !== undefined)
            url_ += "MinDistanceFStartFilter=" + encodeURIComponent("" + minDistanceFStartFilter) + "&"; 
        if (maxDistanceFPrviousStFilter !== undefined)
            url_ += "MaxDistanceFPrviousStFilter=" + encodeURIComponent("" + maxDistanceFPrviousStFilter) + "&"; 
        if (minDistanceFPrviousStFilter !== undefined)
            url_ += "MinDistanceFPrviousStFilter=" + encodeURIComponent("" + minDistanceFPrviousStFilter) + "&"; 
        if (timefrStartStationFilter !== undefined)
            url_ += "TimefrStartStationFilter=" + encodeURIComponent("" + timefrStartStationFilter) + "&"; 
        if (timefrPrviousStationFilter !== undefined)
            url_ += "TimefrPrviousStationFilter=" + encodeURIComponent("" + timefrPrviousStationFilter) + "&"; 
        if (timeSpendonStationFilter !== undefined)
            url_ += "TimeSpendonStationFilter=" + encodeURIComponent("" + timeSpendonStationFilter) + "&"; 
        if (maxTripActualIDFilter !== undefined)
            url_ += "MaxTripActualIDFilter=" + encodeURIComponent("" + maxTripActualIDFilter) + "&"; 
        if (minTripActualIDFilter !== undefined)
            url_ += "MinTripActualIDFilter=" + encodeURIComponent("" + minTripActualIDFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripActualRoutes_StationToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripActualRoutes_StationToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripActualRoutes_StationToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TripActualWitHDriverServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripActualWitHDriver/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTripPlanIDFilter (optional) 
     * @param minTripPlanIDFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param maxTaskNoFilter (optional) 
     * @param minTaskNoFilter (optional) 
     * @param maxTripDateFilter (optional) 
     * @param minTripDateFilter (optional) 
     * @param startTimeFilter (optional) 
     * @param endTimeFilter (optional) 
     * @param maxTotalHourFilter (optional) 
     * @param minTotalHourFilter (optional) 
     * @param maxTripLengthFilter (optional) 
     * @param minTripLengthFilter (optional) 
     * @param maxTripActualIDFilter (optional) 
     * @param minTripActualIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxTripPlanIDFilter: number | null | undefined, minTripPlanIDFilter: number | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, maxTaskNoFilter: number | null | undefined, minTaskNoFilter: number | null | undefined, maxTripDateFilter: moment.Moment | null | undefined, minTripDateFilter: moment.Moment | null | undefined, startTimeFilter: string | null | undefined, endTimeFilter: string | null | undefined, maxTotalHourFilter: number | null | undefined, minTotalHourFilter: number | null | undefined, maxTripLengthFilter: number | null | undefined, minTripLengthFilter: number | null | undefined, maxTripActualIDFilter: number | null | undefined, minTripActualIDFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripActualWitHDriverForView> {
        let url_ = this.baseUrl + "/api/services/app/TripActualWitHDriver/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTripPlanIDFilter !== undefined)
            url_ += "MaxTripPlanIDFilter=" + encodeURIComponent("" + maxTripPlanIDFilter) + "&"; 
        if (minTripPlanIDFilter !== undefined)
            url_ += "MinTripPlanIDFilter=" + encodeURIComponent("" + minTripPlanIDFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (maxTaskNoFilter !== undefined)
            url_ += "MaxTaskNoFilter=" + encodeURIComponent("" + maxTaskNoFilter) + "&"; 
        if (minTaskNoFilter !== undefined)
            url_ += "MinTaskNoFilter=" + encodeURIComponent("" + minTaskNoFilter) + "&"; 
        if (maxTripDateFilter !== undefined)
            url_ += "MaxTripDateFilter=" + encodeURIComponent(maxTripDateFilter ? "" + maxTripDateFilter.toJSON() : "") + "&"; 
        if (minTripDateFilter !== undefined)
            url_ += "MinTripDateFilter=" + encodeURIComponent(minTripDateFilter ? "" + minTripDateFilter.toJSON() : "") + "&"; 
        if (startTimeFilter !== undefined)
            url_ += "StartTimeFilter=" + encodeURIComponent("" + startTimeFilter) + "&"; 
        if (endTimeFilter !== undefined)
            url_ += "EndTimeFilter=" + encodeURIComponent("" + endTimeFilter) + "&"; 
        if (maxTotalHourFilter !== undefined)
            url_ += "MaxTotalHourFilter=" + encodeURIComponent("" + maxTotalHourFilter) + "&"; 
        if (minTotalHourFilter !== undefined)
            url_ += "MinTotalHourFilter=" + encodeURIComponent("" + minTotalHourFilter) + "&"; 
        if (maxTripLengthFilter !== undefined)
            url_ += "MaxTripLengthFilter=" + encodeURIComponent("" + maxTripLengthFilter) + "&"; 
        if (minTripLengthFilter !== undefined)
            url_ += "MinTripLengthFilter=" + encodeURIComponent("" + minTripLengthFilter) + "&"; 
        if (maxTripActualIDFilter !== undefined)
            url_ += "MaxTripActualIDFilter=" + encodeURIComponent("" + maxTripActualIDFilter) + "&"; 
        if (minTripActualIDFilter !== undefined)
            url_ += "MinTripActualIDFilter=" + encodeURIComponent("" + minTripActualIDFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripActualWitHDriverForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripActualWitHDriverForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripActualWitHDriverForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripActualWitHDriverForView.fromJS(resultData200) : new PagedResultDtoOfGetTripActualWitHDriverForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripActualWitHDriverForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripActualWitHDriverForEdit(id: number | null | undefined): Observable<GetTripActualWitHDriverForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripActualWitHDriver/GetTripActualWitHDriverForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripActualWitHDriverForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripActualWitHDriverForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripActualWitHDriverForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripActualWitHDriverForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripActualWitHDriverForEdit(response: HttpResponseBase): Observable<GetTripActualWitHDriverForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripActualWitHDriverForEditOutput.fromJS(resultData200) : new GetTripActualWitHDriverForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripActualWitHDriverForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripActualWitHDriverDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripActualWitHDriver/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripActualWitHDriver/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTripPlanIDFilter (optional) 
     * @param minTripPlanIDFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param maxTaskNoFilter (optional) 
     * @param minTaskNoFilter (optional) 
     * @param maxTripDateFilter (optional) 
     * @param minTripDateFilter (optional) 
     * @param startTimeFilter (optional) 
     * @param endTimeFilter (optional) 
     * @param maxTotalHourFilter (optional) 
     * @param minTotalHourFilter (optional) 
     * @param maxTripLengthFilter (optional) 
     * @param minTripLengthFilter (optional) 
     * @param maxTripActualIDFilter (optional) 
     * @param minTripActualIDFilter (optional) 
     * @return Success
     */
    getTripActualWitHDriverToExcel(filter: string | null | undefined, maxTripPlanIDFilter: number | null | undefined, minTripPlanIDFilter: number | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, maxTaskNoFilter: number | null | undefined, minTaskNoFilter: number | null | undefined, maxTripDateFilter: moment.Moment | null | undefined, minTripDateFilter: moment.Moment | null | undefined, startTimeFilter: string | null | undefined, endTimeFilter: string | null | undefined, maxTotalHourFilter: number | null | undefined, minTotalHourFilter: number | null | undefined, maxTripLengthFilter: number | null | undefined, minTripLengthFilter: number | null | undefined, maxTripActualIDFilter: number | null | undefined, minTripActualIDFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripActualWitHDriver/GetTripActualWitHDriverToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTripPlanIDFilter !== undefined)
            url_ += "MaxTripPlanIDFilter=" + encodeURIComponent("" + maxTripPlanIDFilter) + "&"; 
        if (minTripPlanIDFilter !== undefined)
            url_ += "MinTripPlanIDFilter=" + encodeURIComponent("" + minTripPlanIDFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (maxTaskNoFilter !== undefined)
            url_ += "MaxTaskNoFilter=" + encodeURIComponent("" + maxTaskNoFilter) + "&"; 
        if (minTaskNoFilter !== undefined)
            url_ += "MinTaskNoFilter=" + encodeURIComponent("" + minTaskNoFilter) + "&"; 
        if (maxTripDateFilter !== undefined)
            url_ += "MaxTripDateFilter=" + encodeURIComponent(maxTripDateFilter ? "" + maxTripDateFilter.toJSON() : "") + "&"; 
        if (minTripDateFilter !== undefined)
            url_ += "MinTripDateFilter=" + encodeURIComponent(minTripDateFilter ? "" + minTripDateFilter.toJSON() : "") + "&"; 
        if (startTimeFilter !== undefined)
            url_ += "StartTimeFilter=" + encodeURIComponent("" + startTimeFilter) + "&"; 
        if (endTimeFilter !== undefined)
            url_ += "EndTimeFilter=" + encodeURIComponent("" + endTimeFilter) + "&"; 
        if (maxTotalHourFilter !== undefined)
            url_ += "MaxTotalHourFilter=" + encodeURIComponent("" + maxTotalHourFilter) + "&"; 
        if (minTotalHourFilter !== undefined)
            url_ += "MinTotalHourFilter=" + encodeURIComponent("" + minTotalHourFilter) + "&"; 
        if (maxTripLengthFilter !== undefined)
            url_ += "MaxTripLengthFilter=" + encodeURIComponent("" + maxTripLengthFilter) + "&"; 
        if (minTripLengthFilter !== undefined)
            url_ += "MinTripLengthFilter=" + encodeURIComponent("" + minTripLengthFilter) + "&"; 
        if (maxTripActualIDFilter !== undefined)
            url_ += "MaxTripActualIDFilter=" + encodeURIComponent("" + maxTripActualIDFilter) + "&"; 
        if (minTripActualIDFilter !== undefined)
            url_ += "MinTripActualIDFilter=" + encodeURIComponent("" + minTripActualIDFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripActualWitHDriverToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripActualWitHDriverToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripActualWitHDriverToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TripByMinistriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTimeSpanFilter (optional) 
     * @param minTimeSpanFilter (optional) 
     * @param maxTimeSpanEndFilter (optional) 
     * @param minTimeSpanEndFilter (optional) 
     * @param routeLineNumberFilter (optional) 
     * @param calenderBusTenantIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxTimeSpanFilter: moment.Moment | null | undefined, minTimeSpanFilter: moment.Moment | null | undefined, maxTimeSpanEndFilter: moment.Moment | null | undefined, minTimeSpanEndFilter: moment.Moment | null | undefined, routeLineNumberFilter: string | null | undefined, calenderBusTenantIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripByMinistryForView> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTimeSpanFilter !== undefined)
            url_ += "MaxTimeSpanFilter=" + encodeURIComponent(maxTimeSpanFilter ? "" + maxTimeSpanFilter.toJSON() : "") + "&"; 
        if (minTimeSpanFilter !== undefined)
            url_ += "MinTimeSpanFilter=" + encodeURIComponent(minTimeSpanFilter ? "" + minTimeSpanFilter.toJSON() : "") + "&"; 
        if (maxTimeSpanEndFilter !== undefined)
            url_ += "MaxTimeSpanEndFilter=" + encodeURIComponent(maxTimeSpanEndFilter ? "" + maxTimeSpanEndFilter.toJSON() : "") + "&"; 
        if (minTimeSpanEndFilter !== undefined)
            url_ += "MinTimeSpanEndFilter=" + encodeURIComponent(minTimeSpanEndFilter ? "" + minTimeSpanEndFilter.toJSON() : "") + "&"; 
        if (routeLineNumberFilter !== undefined)
            url_ += "RouteLineNumberFilter=" + encodeURIComponent("" + routeLineNumberFilter) + "&"; 
        if (calenderBusTenantIdFilter !== undefined)
            url_ += "CalenderBusTenantIdFilter=" + encodeURIComponent("" + calenderBusTenantIdFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripByMinistryForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripByMinistryForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripByMinistryForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripByMinistryForView.fromJS(resultData200) : new PagedResultDtoOfGetTripByMinistryForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripByMinistryForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripByMinistryForEdit(id: number | null | undefined): Observable<GetTripByMinistryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/GetTripByMinistryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripByMinistryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripByMinistryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripByMinistryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripByMinistryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripByMinistryForEdit(response: HttpResponseBase): Observable<GetTripByMinistryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripByMinistryForEditOutput.fromJS(resultData200) : new GetTripByMinistryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripByMinistryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripByMinistryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTimeSpanFilter (optional) 
     * @param minTimeSpanFilter (optional) 
     * @param maxTimeSpanEndFilter (optional) 
     * @param minTimeSpanEndFilter (optional) 
     * @param routeLineNumberFilter (optional) 
     * @param calenderBusTenantIdFilter (optional) 
     * @return Success
     */
    getTripByMinistriesToExcel(filter: string | null | undefined, maxTimeSpanFilter: moment.Moment | null | undefined, minTimeSpanFilter: moment.Moment | null | undefined, maxTimeSpanEndFilter: moment.Moment | null | undefined, minTimeSpanEndFilter: moment.Moment | null | undefined, routeLineNumberFilter: string | null | undefined, calenderBusTenantIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/GetTripByMinistriesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTimeSpanFilter !== undefined)
            url_ += "MaxTimeSpanFilter=" + encodeURIComponent(maxTimeSpanFilter ? "" + maxTimeSpanFilter.toJSON() : "") + "&"; 
        if (minTimeSpanFilter !== undefined)
            url_ += "MinTimeSpanFilter=" + encodeURIComponent(minTimeSpanFilter ? "" + minTimeSpanFilter.toJSON() : "") + "&"; 
        if (maxTimeSpanEndFilter !== undefined)
            url_ += "MaxTimeSpanEndFilter=" + encodeURIComponent(maxTimeSpanEndFilter ? "" + maxTimeSpanEndFilter.toJSON() : "") + "&"; 
        if (minTimeSpanEndFilter !== undefined)
            url_ += "MinTimeSpanEndFilter=" + encodeURIComponent(minTimeSpanEndFilter ? "" + minTimeSpanEndFilter.toJSON() : "") + "&"; 
        if (routeLineNumberFilter !== undefined)
            url_ += "RouteLineNumberFilter=" + encodeURIComponent("" + routeLineNumberFilter) + "&"; 
        if (calenderBusTenantIdFilter !== undefined)
            url_ += "CalenderBusTenantIdFilter=" + encodeURIComponent("" + calenderBusTenantIdFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripByMinistriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripByMinistriesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripByMinistriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRouteForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRouteLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/GetAllRouteForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRouteForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRouteForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRouteLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRouteLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRouteForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRouteLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRouteLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfRouteLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRouteLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCalenderBusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCalenderBusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripByMinistries/GetAllCalenderBusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCalenderBusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCalenderBusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCalenderBusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCalenderBusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCalenderBusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCalenderBusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCalenderBusLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfCalenderBusLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCalenderBusLookupTableDto>(<any>null);
    }
}

@Injectable()
export class TripPlanedDailyWitHDriversServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTripPlanIDFilter (optional) 
     * @param minTripPlanIDFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param maxTaskNoFilter (optional) 
     * @param minTaskNoFilter (optional) 
     * @param maxWorkingdayFilter (optional) 
     * @param minWorkingdayFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxTripPlanIDFilter: number | null | undefined, minTripPlanIDFilter: number | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, maxTaskNoFilter: number | null | undefined, minTaskNoFilter: number | null | undefined, maxWorkingdayFilter: moment.Moment | null | undefined, minWorkingdayFilter: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripPlanedDailyWitHDriverForView> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTripPlanIDFilter !== undefined)
            url_ += "MaxTripPlanIDFilter=" + encodeURIComponent("" + maxTripPlanIDFilter) + "&"; 
        if (minTripPlanIDFilter !== undefined)
            url_ += "MinTripPlanIDFilter=" + encodeURIComponent("" + minTripPlanIDFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (maxTaskNoFilter !== undefined)
            url_ += "MaxTaskNoFilter=" + encodeURIComponent("" + maxTaskNoFilter) + "&"; 
        if (minTaskNoFilter !== undefined)
            url_ += "MinTaskNoFilter=" + encodeURIComponent("" + minTaskNoFilter) + "&"; 
        if (maxWorkingdayFilter !== undefined)
            url_ += "MaxWorkingdayFilter=" + encodeURIComponent(maxWorkingdayFilter ? "" + maxWorkingdayFilter.toJSON() : "") + "&"; 
        if (minWorkingdayFilter !== undefined)
            url_ += "MinWorkingdayFilter=" + encodeURIComponent(minWorkingdayFilter ? "" + minWorkingdayFilter.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripPlanedDailyWitHDriverForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripPlanedDailyWitHDriverForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripPlanedDailyWitHDriverForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripPlanedDailyWitHDriverForView.fromJS(resultData200) : new PagedResultDtoOfGetTripPlanedDailyWitHDriverForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripPlanedDailyWitHDriverForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripPlanedDailyWitHDriverForEdit(id: number | null | undefined): Observable<GetTripPlanedDailyWitHDriverForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/GetTripPlanedDailyWitHDriverForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripPlanedDailyWitHDriverForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripPlanedDailyWitHDriverForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripPlanedDailyWitHDriverForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripPlanedDailyWitHDriverForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripPlanedDailyWitHDriverForEdit(response: HttpResponseBase): Observable<GetTripPlanedDailyWitHDriverForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripPlanedDailyWitHDriverForEditOutput.fromJS(resultData200) : new GetTripPlanedDailyWitHDriverForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripPlanedDailyWitHDriverForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripPlanedDailyWitHDriverDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param taskno (optional) 
     * @param oldbusId (optional) 
     * @param oldDriverId (optional) 
     * @param newBusId (optional) 
     * @param newDriverID (optional) 
     * @return Success
     */
    replaceAllTaskNo(taskno: number | null | undefined, oldbusId: number | null | undefined, oldDriverId: number | null | undefined, newBusId: number | null | undefined, newDriverID: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/ReplaceAllTaskNo?";
        if (taskno !== undefined)
            url_ += "taskno=" + encodeURIComponent("" + taskno) + "&"; 
        if (oldbusId !== undefined)
            url_ += "oldbusId=" + encodeURIComponent("" + oldbusId) + "&"; 
        if (oldDriverId !== undefined)
            url_ += "oldDriverId=" + encodeURIComponent("" + oldDriverId) + "&"; 
        if (newBusId !== undefined)
            url_ += "newBusId=" + encodeURIComponent("" + newBusId) + "&"; 
        if (newDriverID !== undefined)
            url_ += "newDriverID=" + encodeURIComponent("" + newDriverID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceAllTaskNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceAllTaskNo(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceAllTaskNo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTripPlanIDFilter (optional) 
     * @param minTripPlanIDFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param maxTaskNoFilter (optional) 
     * @param minTaskNoFilter (optional) 
     * @param maxWorkingdayFilter (optional) 
     * @param minWorkingdayFilter (optional) 
     * @return Success
     */
    getTripPlanedDailyWitHDriversToExcel(filter: string | null | undefined, maxTripPlanIDFilter: number | null | undefined, minTripPlanIDFilter: number | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, maxTaskNoFilter: number | null | undefined, minTaskNoFilter: number | null | undefined, maxWorkingdayFilter: moment.Moment | null | undefined, minWorkingdayFilter: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedDailyWitHDrivers/GetTripPlanedDailyWitHDriversToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTripPlanIDFilter !== undefined)
            url_ += "MaxTripPlanIDFilter=" + encodeURIComponent("" + maxTripPlanIDFilter) + "&"; 
        if (minTripPlanIDFilter !== undefined)
            url_ += "MinTripPlanIDFilter=" + encodeURIComponent("" + minTripPlanIDFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (maxTaskNoFilter !== undefined)
            url_ += "MaxTaskNoFilter=" + encodeURIComponent("" + maxTaskNoFilter) + "&"; 
        if (minTaskNoFilter !== undefined)
            url_ += "MinTaskNoFilter=" + encodeURIComponent("" + minTaskNoFilter) + "&"; 
        if (maxWorkingdayFilter !== undefined)
            url_ += "MaxWorkingdayFilter=" + encodeURIComponent(maxWorkingdayFilter ? "" + maxWorkingdayFilter.toJSON() : "") + "&"; 
        if (minWorkingdayFilter !== undefined)
            url_ += "MinWorkingdayFilter=" + encodeURIComponent(minWorkingdayFilter ? "" + minWorkingdayFilter.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripPlanedDailyWitHDriversToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripPlanedDailyWitHDriversToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripPlanedDailyWitHDriversToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TripPlanedsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxCalenderIDFilter (optional) 
     * @param minCalenderIDFilter (optional) 
     * @param maxRouteIDFilter (optional) 
     * @param minRouteIDFilter (optional) 
     * @param timeSpanFilter (optional) 
     * @param maxTripMinistryFilter (optional) 
     * @param minTripMinistryFilter (optional) 
     * @param iSValidFilter (optional) 
     * @param endTimeSpanFilter (optional) 
     * @param tripTypeNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxCalenderIDFilter: number | null | undefined, minCalenderIDFilter: number | null | undefined, maxRouteIDFilter: number | null | undefined, minRouteIDFilter: number | null | undefined, timeSpanFilter: string | null | undefined, maxTripMinistryFilter: number | null | undefined, minTripMinistryFilter: number | null | undefined, iSValidFilter: number | null | undefined, endTimeSpanFilter: string | null | undefined, tripTypeNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripPlanedForView> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxCalenderIDFilter !== undefined)
            url_ += "MaxCalenderIDFilter=" + encodeURIComponent("" + maxCalenderIDFilter) + "&"; 
        if (minCalenderIDFilter !== undefined)
            url_ += "MinCalenderIDFilter=" + encodeURIComponent("" + minCalenderIDFilter) + "&"; 
        if (maxRouteIDFilter !== undefined)
            url_ += "MaxRouteIDFilter=" + encodeURIComponent("" + maxRouteIDFilter) + "&"; 
        if (minRouteIDFilter !== undefined)
            url_ += "MinRouteIDFilter=" + encodeURIComponent("" + minRouteIDFilter) + "&"; 
        if (timeSpanFilter !== undefined)
            url_ += "TimeSpanFilter=" + encodeURIComponent("" + timeSpanFilter) + "&"; 
        if (maxTripMinistryFilter !== undefined)
            url_ += "MaxTripMinistryFilter=" + encodeURIComponent("" + maxTripMinistryFilter) + "&"; 
        if (minTripMinistryFilter !== undefined)
            url_ += "MinTripMinistryFilter=" + encodeURIComponent("" + minTripMinistryFilter) + "&"; 
        if (iSValidFilter !== undefined)
            url_ += "ISValidFilter=" + encodeURIComponent("" + iSValidFilter) + "&"; 
        if (endTimeSpanFilter !== undefined)
            url_ += "EndTimeSpanFilter=" + encodeURIComponent("" + endTimeSpanFilter) + "&"; 
        if (tripTypeNameFilter !== undefined)
            url_ += "TripTypeNameFilter=" + encodeURIComponent("" + tripTypeNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripPlanedForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripPlanedForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripPlanedForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripPlanedForView.fromJS(resultData200) : new PagedResultDtoOfGetTripPlanedForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripPlanedForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripPlanedForEdit(id: number | null | undefined): Observable<GetTripPlanedForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/GetTripPlanedForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripPlanedForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripPlanedForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripPlanedForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripPlanedForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripPlanedForEdit(response: HttpResponseBase): Observable<GetTripPlanedForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripPlanedForEditOutput.fromJS(resultData200) : new GetTripPlanedForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripPlanedForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripPlanedDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxCalenderIDFilter (optional) 
     * @param minCalenderIDFilter (optional) 
     * @param maxRouteIDFilter (optional) 
     * @param minRouteIDFilter (optional) 
     * @param timeSpanFilter (optional) 
     * @param maxTripMinistryFilter (optional) 
     * @param minTripMinistryFilter (optional) 
     * @param iSValidFilter (optional) 
     * @param endTimeSpanFilter (optional) 
     * @param tripTypeNameFilter (optional) 
     * @return Success
     */
    getTripPlanedsToExcel(filter: string | null | undefined, maxCalenderIDFilter: number | null | undefined, minCalenderIDFilter: number | null | undefined, maxRouteIDFilter: number | null | undefined, minRouteIDFilter: number | null | undefined, timeSpanFilter: string | null | undefined, maxTripMinistryFilter: number | null | undefined, minTripMinistryFilter: number | null | undefined, iSValidFilter: number | null | undefined, endTimeSpanFilter: string | null | undefined, tripTypeNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/GetTripPlanedsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxCalenderIDFilter !== undefined)
            url_ += "MaxCalenderIDFilter=" + encodeURIComponent("" + maxCalenderIDFilter) + "&"; 
        if (minCalenderIDFilter !== undefined)
            url_ += "MinCalenderIDFilter=" + encodeURIComponent("" + minCalenderIDFilter) + "&"; 
        if (maxRouteIDFilter !== undefined)
            url_ += "MaxRouteIDFilter=" + encodeURIComponent("" + maxRouteIDFilter) + "&"; 
        if (minRouteIDFilter !== undefined)
            url_ += "MinRouteIDFilter=" + encodeURIComponent("" + minRouteIDFilter) + "&"; 
        if (timeSpanFilter !== undefined)
            url_ += "TimeSpanFilter=" + encodeURIComponent("" + timeSpanFilter) + "&"; 
        if (maxTripMinistryFilter !== undefined)
            url_ += "MaxTripMinistryFilter=" + encodeURIComponent("" + maxTripMinistryFilter) + "&"; 
        if (minTripMinistryFilter !== undefined)
            url_ += "MinTripMinistryFilter=" + encodeURIComponent("" + minTripMinistryFilter) + "&"; 
        if (iSValidFilter !== undefined)
            url_ += "ISValidFilter=" + encodeURIComponent("" + iSValidFilter) + "&"; 
        if (endTimeSpanFilter !== undefined)
            url_ += "EndTimeSpanFilter=" + encodeURIComponent("" + endTimeSpanFilter) + "&"; 
        if (tripTypeNameFilter !== undefined)
            url_ += "TripTypeNameFilter=" + encodeURIComponent("" + tripTypeNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripPlanedsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripPlanedsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripPlanedsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTripTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTripTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TripPlaneds/GetAllTripTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTripTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTripTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTripTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTripTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTripTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTripTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTripTypeLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfTripTypeLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTripTypeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class TripPlanedWitHDriversServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param workingDay (optional) 
     * @return Success
     */
    createTripPlanByDate(workingDay: moment.Moment | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/CreateTripPlanByDate?";
        if (workingDay !== undefined)
            url_ += "WorkingDay=" + encodeURIComponent(workingDay ? "" + workingDay.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTripPlanByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTripPlanByDate(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTripPlanByDate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTripPlanIDFilter (optional) 
     * @param minTripPlanIDFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param maxTaskNoFilter (optional) 
     * @param minTaskNoFilter (optional) 
     * @param notesFilter (optional) 
     * @param busGroupFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxTripPlanIDFilter: number | null | undefined, minTripPlanIDFilter: number | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, maxTaskNoFilter: number | null | undefined, minTaskNoFilter: number | null | undefined, notesFilter: string | null | undefined, busGroupFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripPlanedWitHDriverForView> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTripPlanIDFilter !== undefined)
            url_ += "MaxTripPlanIDFilter=" + encodeURIComponent("" + maxTripPlanIDFilter) + "&"; 
        if (minTripPlanIDFilter !== undefined)
            url_ += "MinTripPlanIDFilter=" + encodeURIComponent("" + minTripPlanIDFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (maxTaskNoFilter !== undefined)
            url_ += "MaxTaskNoFilter=" + encodeURIComponent("" + maxTaskNoFilter) + "&"; 
        if (minTaskNoFilter !== undefined)
            url_ += "MinTaskNoFilter=" + encodeURIComponent("" + minTaskNoFilter) + "&"; 
        if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripPlanedWitHDriverForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripPlanedWitHDriverForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripPlanedWitHDriverForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripPlanedWitHDriverForView.fromJS(resultData200) : new PagedResultDtoOfGetTripPlanedWitHDriverForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripPlanedWitHDriverForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripPlanedWitHDriverForEdit(id: number | null | undefined): Observable<GetTripPlanedWitHDriverForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/GetTripPlanedWitHDriverForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripPlanedWitHDriverForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripPlanedWitHDriverForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripPlanedWitHDriverForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripPlanedWitHDriverForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripPlanedWitHDriverForEdit(response: HttpResponseBase): Observable<GetTripPlanedWitHDriverForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripPlanedWitHDriverForEditOutput.fromJS(resultData200) : new GetTripPlanedWitHDriverForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripPlanedWitHDriverForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripPlanedWitHDriverDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTripPlanIDFilter (optional) 
     * @param minTripPlanIDFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param maxTaskNoFilter (optional) 
     * @param minTaskNoFilter (optional) 
     * @param notesFilter (optional) 
     * @param busGroupFilter (optional) 
     * @return Success
     */
    getTripPlanedWitHDriversToExcel(filter: string | null | undefined, maxTripPlanIDFilter: number | null | undefined, minTripPlanIDFilter: number | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, maxTaskNoFilter: number | null | undefined, minTaskNoFilter: number | null | undefined, notesFilter: string | null | undefined, busGroupFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripPlanedWitHDrivers/GetTripPlanedWitHDriversToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTripPlanIDFilter !== undefined)
            url_ += "MaxTripPlanIDFilter=" + encodeURIComponent("" + maxTripPlanIDFilter) + "&"; 
        if (minTripPlanIDFilter !== undefined)
            url_ += "MinTripPlanIDFilter=" + encodeURIComponent("" + minTripPlanIDFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (maxTaskNoFilter !== undefined)
            url_ += "MaxTaskNoFilter=" + encodeURIComponent("" + maxTaskNoFilter) + "&"; 
        if (minTaskNoFilter !== undefined)
            url_ += "MinTaskNoFilter=" + encodeURIComponent("" + minTaskNoFilter) + "&"; 
        if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripPlanedWitHDriversToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripPlanedWitHDriversToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripPlanedWitHDriversToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class TripTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/TripTypes/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTripTypeForView> {
        let url_ = this.baseUrl + "/api/services/app/TripTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTripTypeForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTripTypeForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTripTypeForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetTripTypeForView.fromJS(resultData200) : new PagedResultDtoOfGetTripTypeForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTripTypeForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTripTypeForEdit(id: number | null | undefined): Observable<GetTripTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TripTypes/GetTripTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTripTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTripTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripTypeForEdit(response: HttpResponseBase): Observable<GetTripTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTripTypeForEditOutput.fromJS(resultData200) : new GetTripTypeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTripTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditTripTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TripTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @return Success
     */
    getTripTypesToExcel(filter: string | null | undefined, nameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TripTypes/GetTripTypesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTripTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTripTypesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTripTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permission (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permission (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VechileGpsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxVechileIDFilter (optional) 
     * @param minVechileIDFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param maxangleFilter (optional) 
     * @param minangleFilter (optional) 
     * @param maxLocationDateTimeFilter (optional) 
     * @param minLocationDateTimeFilter (optional) 
     * @param maxSatellitesFilter (optional) 
     * @param minSatellitesFilter (optional) 
     * @param maxHdopFilter (optional) 
     * @param minHdopFilter (optional) 
     * @param maxCreatedFilter (optional) 
     * @param minCreatedFilter (optional) 
     * @param maxModifiedFilter (optional) 
     * @param minModifiedFilter (optional) 
     * @param maxGPSSpeedFilter (optional) 
     * @param minGPSSpeedFilter (optional) 
     * @param maxSpeedFilter (optional) 
     * @param minSpeedFilter (optional) 
     * @param maxBearingFilter (optional) 
     * @param minBearingFilter (optional) 
     * @param maxVehicleNumberFilter (optional) 
     * @param minVehicleNumberFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxVechileIDFilter: number | null | undefined, minVechileIDFilter: number | null | undefined, maxLatitudeFilter: number | null | undefined, minLatitudeFilter: number | null | undefined, maxLongitudeFilter: number | null | undefined, minLongitudeFilter: number | null | undefined, maxangleFilter: number | null | undefined, minangleFilter: number | null | undefined, maxLocationDateTimeFilter: moment.Moment | null | undefined, minLocationDateTimeFilter: moment.Moment | null | undefined, maxSatellitesFilter: number | null | undefined, minSatellitesFilter: number | null | undefined, maxHdopFilter: number | null | undefined, minHdopFilter: number | null | undefined, maxCreatedFilter: moment.Moment | null | undefined, minCreatedFilter: moment.Moment | null | undefined, maxModifiedFilter: moment.Moment | null | undefined, minModifiedFilter: moment.Moment | null | undefined, maxGPSSpeedFilter: number | null | undefined, minGPSSpeedFilter: number | null | undefined, maxSpeedFilter: number | null | undefined, minSpeedFilter: number | null | undefined, maxBearingFilter: number | null | undefined, minBearingFilter: number | null | undefined, maxVehicleNumberFilter: number | null | undefined, minVehicleNumberFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVechileGpsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VechileGps/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxVechileIDFilter !== undefined)
            url_ += "MaxVechileIDFilter=" + encodeURIComponent("" + maxVechileIDFilter) + "&"; 
        if (minVechileIDFilter !== undefined)
            url_ += "MinVechileIDFilter=" + encodeURIComponent("" + minVechileIDFilter) + "&"; 
        if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&"; 
        if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&"; 
        if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&"; 
        if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&"; 
        if (maxangleFilter !== undefined)
            url_ += "MaxangleFilter=" + encodeURIComponent("" + maxangleFilter) + "&"; 
        if (minangleFilter !== undefined)
            url_ += "MinangleFilter=" + encodeURIComponent("" + minangleFilter) + "&"; 
        if (maxLocationDateTimeFilter !== undefined)
            url_ += "MaxLocationDateTimeFilter=" + encodeURIComponent(maxLocationDateTimeFilter ? "" + maxLocationDateTimeFilter.toJSON() : "") + "&"; 
        if (minLocationDateTimeFilter !== undefined)
            url_ += "MinLocationDateTimeFilter=" + encodeURIComponent(minLocationDateTimeFilter ? "" + minLocationDateTimeFilter.toJSON() : "") + "&"; 
        if (maxSatellitesFilter !== undefined)
            url_ += "MaxSatellitesFilter=" + encodeURIComponent("" + maxSatellitesFilter) + "&"; 
        if (minSatellitesFilter !== undefined)
            url_ += "MinSatellitesFilter=" + encodeURIComponent("" + minSatellitesFilter) + "&"; 
        if (maxHdopFilter !== undefined)
            url_ += "MaxHdopFilter=" + encodeURIComponent("" + maxHdopFilter) + "&"; 
        if (minHdopFilter !== undefined)
            url_ += "MinHdopFilter=" + encodeURIComponent("" + minHdopFilter) + "&"; 
        if (maxCreatedFilter !== undefined)
            url_ += "MaxCreatedFilter=" + encodeURIComponent(maxCreatedFilter ? "" + maxCreatedFilter.toJSON() : "") + "&"; 
        if (minCreatedFilter !== undefined)
            url_ += "MinCreatedFilter=" + encodeURIComponent(minCreatedFilter ? "" + minCreatedFilter.toJSON() : "") + "&"; 
        if (maxModifiedFilter !== undefined)
            url_ += "MaxModifiedFilter=" + encodeURIComponent(maxModifiedFilter ? "" + maxModifiedFilter.toJSON() : "") + "&"; 
        if (minModifiedFilter !== undefined)
            url_ += "MinModifiedFilter=" + encodeURIComponent(minModifiedFilter ? "" + minModifiedFilter.toJSON() : "") + "&"; 
        if (maxGPSSpeedFilter !== undefined)
            url_ += "MaxGPSSpeedFilter=" + encodeURIComponent("" + maxGPSSpeedFilter) + "&"; 
        if (minGPSSpeedFilter !== undefined)
            url_ += "MinGPSSpeedFilter=" + encodeURIComponent("" + minGPSSpeedFilter) + "&"; 
        if (maxSpeedFilter !== undefined)
            url_ += "MaxSpeedFilter=" + encodeURIComponent("" + maxSpeedFilter) + "&"; 
        if (minSpeedFilter !== undefined)
            url_ += "MinSpeedFilter=" + encodeURIComponent("" + minSpeedFilter) + "&"; 
        if (maxBearingFilter !== undefined)
            url_ += "MaxBearingFilter=" + encodeURIComponent("" + maxBearingFilter) + "&"; 
        if (minBearingFilter !== undefined)
            url_ += "MinBearingFilter=" + encodeURIComponent("" + minBearingFilter) + "&"; 
        if (maxVehicleNumberFilter !== undefined)
            url_ += "MaxVehicleNumberFilter=" + encodeURIComponent("" + maxVehicleNumberFilter) + "&"; 
        if (minVehicleNumberFilter !== undefined)
            url_ += "MinVehicleNumberFilter=" + encodeURIComponent("" + minVehicleNumberFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVechileGpsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVechileGpsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVechileGpsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetVechileGpsForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetVechileGpsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVechileGpsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVechileGpsForView(id: number | null | undefined): Observable<GetVechileGpsForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VechileGps/GetVechileGpsForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVechileGpsForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVechileGpsForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVechileGpsForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVechileGpsForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVechileGpsForView(response: HttpResponseBase): Observable<GetVechileGpsForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVechileGpsForViewDto.fromJS(resultData200) : new GetVechileGpsForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVechileGpsForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVechileGpsForEdit(id: number | null | undefined): Observable<GetVechileGpsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VechileGps/GetVechileGpsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVechileGpsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVechileGpsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVechileGpsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVechileGpsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVechileGpsForEdit(response: HttpResponseBase): Observable<GetVechileGpsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVechileGpsForEditOutput.fromJS(resultData200) : new GetVechileGpsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVechileGpsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVechileGpsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VechileGps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VechileGps/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxVechileIDFilter (optional) 
     * @param minVechileIDFilter (optional) 
     * @param maxLatitudeFilter (optional) 
     * @param minLatitudeFilter (optional) 
     * @param maxLongitudeFilter (optional) 
     * @param minLongitudeFilter (optional) 
     * @param maxangleFilter (optional) 
     * @param minangleFilter (optional) 
     * @param maxLocationDateTimeFilter (optional) 
     * @param minLocationDateTimeFilter (optional) 
     * @param maxSatellitesFilter (optional) 
     * @param minSatellitesFilter (optional) 
     * @param maxHdopFilter (optional) 
     * @param minHdopFilter (optional) 
     * @param maxCreatedFilter (optional) 
     * @param minCreatedFilter (optional) 
     * @param maxModifiedFilter (optional) 
     * @param minModifiedFilter (optional) 
     * @param maxGPSSpeedFilter (optional) 
     * @param minGPSSpeedFilter (optional) 
     * @param maxSpeedFilter (optional) 
     * @param minSpeedFilter (optional) 
     * @param maxBearingFilter (optional) 
     * @param minBearingFilter (optional) 
     * @param maxVehicleNumberFilter (optional) 
     * @param minVehicleNumberFilter (optional) 
     * @return Success
     */
    getVechileGpsToExcel(filter: string | null | undefined, maxVechileIDFilter: number | null | undefined, minVechileIDFilter: number | null | undefined, maxLatitudeFilter: number | null | undefined, minLatitudeFilter: number | null | undefined, maxLongitudeFilter: number | null | undefined, minLongitudeFilter: number | null | undefined, maxangleFilter: number | null | undefined, minangleFilter: number | null | undefined, maxLocationDateTimeFilter: moment.Moment | null | undefined, minLocationDateTimeFilter: moment.Moment | null | undefined, maxSatellitesFilter: number | null | undefined, minSatellitesFilter: number | null | undefined, maxHdopFilter: number | null | undefined, minHdopFilter: number | null | undefined, maxCreatedFilter: moment.Moment | null | undefined, minCreatedFilter: moment.Moment | null | undefined, maxModifiedFilter: moment.Moment | null | undefined, minModifiedFilter: moment.Moment | null | undefined, maxGPSSpeedFilter: number | null | undefined, minGPSSpeedFilter: number | null | undefined, maxSpeedFilter: number | null | undefined, minSpeedFilter: number | null | undefined, maxBearingFilter: number | null | undefined, minBearingFilter: number | null | undefined, maxVehicleNumberFilter: number | null | undefined, minVehicleNumberFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/VechileGps/GetVechileGpsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxVechileIDFilter !== undefined)
            url_ += "MaxVechileIDFilter=" + encodeURIComponent("" + maxVechileIDFilter) + "&"; 
        if (minVechileIDFilter !== undefined)
            url_ += "MinVechileIDFilter=" + encodeURIComponent("" + minVechileIDFilter) + "&"; 
        if (maxLatitudeFilter !== undefined)
            url_ += "MaxLatitudeFilter=" + encodeURIComponent("" + maxLatitudeFilter) + "&"; 
        if (minLatitudeFilter !== undefined)
            url_ += "MinLatitudeFilter=" + encodeURIComponent("" + minLatitudeFilter) + "&"; 
        if (maxLongitudeFilter !== undefined)
            url_ += "MaxLongitudeFilter=" + encodeURIComponent("" + maxLongitudeFilter) + "&"; 
        if (minLongitudeFilter !== undefined)
            url_ += "MinLongitudeFilter=" + encodeURIComponent("" + minLongitudeFilter) + "&"; 
        if (maxangleFilter !== undefined)
            url_ += "MaxangleFilter=" + encodeURIComponent("" + maxangleFilter) + "&"; 
        if (minangleFilter !== undefined)
            url_ += "MinangleFilter=" + encodeURIComponent("" + minangleFilter) + "&"; 
        if (maxLocationDateTimeFilter !== undefined)
            url_ += "MaxLocationDateTimeFilter=" + encodeURIComponent(maxLocationDateTimeFilter ? "" + maxLocationDateTimeFilter.toJSON() : "") + "&"; 
        if (minLocationDateTimeFilter !== undefined)
            url_ += "MinLocationDateTimeFilter=" + encodeURIComponent(minLocationDateTimeFilter ? "" + minLocationDateTimeFilter.toJSON() : "") + "&"; 
        if (maxSatellitesFilter !== undefined)
            url_ += "MaxSatellitesFilter=" + encodeURIComponent("" + maxSatellitesFilter) + "&"; 
        if (minSatellitesFilter !== undefined)
            url_ += "MinSatellitesFilter=" + encodeURIComponent("" + minSatellitesFilter) + "&"; 
        if (maxHdopFilter !== undefined)
            url_ += "MaxHdopFilter=" + encodeURIComponent("" + maxHdopFilter) + "&"; 
        if (minHdopFilter !== undefined)
            url_ += "MinHdopFilter=" + encodeURIComponent("" + minHdopFilter) + "&"; 
        if (maxCreatedFilter !== undefined)
            url_ += "MaxCreatedFilter=" + encodeURIComponent(maxCreatedFilter ? "" + maxCreatedFilter.toJSON() : "") + "&"; 
        if (minCreatedFilter !== undefined)
            url_ += "MinCreatedFilter=" + encodeURIComponent(minCreatedFilter ? "" + minCreatedFilter.toJSON() : "") + "&"; 
        if (maxModifiedFilter !== undefined)
            url_ += "MaxModifiedFilter=" + encodeURIComponent(maxModifiedFilter ? "" + maxModifiedFilter.toJSON() : "") + "&"; 
        if (minModifiedFilter !== undefined)
            url_ += "MinModifiedFilter=" + encodeURIComponent(minModifiedFilter ? "" + minModifiedFilter.toJSON() : "") + "&"; 
        if (maxGPSSpeedFilter !== undefined)
            url_ += "MaxGPSSpeedFilter=" + encodeURIComponent("" + maxGPSSpeedFilter) + "&"; 
        if (minGPSSpeedFilter !== undefined)
            url_ += "MinGPSSpeedFilter=" + encodeURIComponent("" + minGPSSpeedFilter) + "&"; 
        if (maxSpeedFilter !== undefined)
            url_ += "MaxSpeedFilter=" + encodeURIComponent("" + maxSpeedFilter) + "&"; 
        if (minSpeedFilter !== undefined)
            url_ += "MinSpeedFilter=" + encodeURIComponent("" + minSpeedFilter) + "&"; 
        if (maxBearingFilter !== undefined)
            url_ += "MaxBearingFilter=" + encodeURIComponent("" + maxBearingFilter) + "&"; 
        if (minBearingFilter !== undefined)
            url_ += "MinBearingFilter=" + encodeURIComponent("" + minBearingFilter) + "&"; 
        if (maxVehicleNumberFilter !== undefined)
            url_ += "MaxVehicleNumberFilter=" + encodeURIComponent("" + maxVehicleNumberFilter) + "&"; 
        if (minVehicleNumberFilter !== undefined)
            url_ += "MinVehicleNumberFilter=" + encodeURIComponent("" + minVehicleNumberFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVechileGpsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVechileGpsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVechileGpsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class VehiclesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxInternalIDFilter (optional) 
     * @param minInternalIDFilter (optional) 
     * @param maxVehicleNumberFilter (optional) 
     * @param minVehicleNumberFilter (optional) 
     * @param maxShortVehicleNumberFilter (optional) 
     * @param minShortVehicleNumberFilter (optional) 
     * @param maxVehicleTypeFilter (optional) 
     * @param minVehicleTypeFilter (optional) 
     * @param maxStatusFilter (optional) 
     * @param minStatusFilter (optional) 
     * @param maxStatusDateFilter (optional) 
     * @param minStatusDateFilter (optional) 
     * @param maxParkingFilter (optional) 
     * @param minParkingFilter (optional) 
     * @param maxGarageFilter (optional) 
     * @param minGarageFilter (optional) 
     * @param maxKMFilter (optional) 
     * @param minKMFilter (optional) 
     * @param maxTestDateFilter (optional) 
     * @param minTestDateFilter (optional) 
     * @param maxInsuranceDateFilter (optional) 
     * @param minInsuranceDateFilter (optional) 
     * @param maxLastHandleDateFilter (optional) 
     * @param minLastHandleDateFilter (optional) 
     * @param maxNextHandleDateFilter (optional) 
     * @param minNextHandleDateFilter (optional) 
     * @param maxUpdatedFilter (optional) 
     * @param minUpdatedFilter (optional) 
     * @param maxOperatorIDFilter (optional) 
     * @param minOperatorIDFilter (optional) 
     * @param maxIsBusInTripFilter (optional) 
     * @param minIsBusInTripFilter (optional) 
     * @param maxIsBusInTripLastUpdatedFilter (optional) 
     * @param minIsBusInTripLastUpdatedFilter (optional) 
     * @param vehiclesTypeTypeDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxInternalIDFilter: number | null | undefined, minInternalIDFilter: number | null | undefined, maxVehicleNumberFilter: number | null | undefined, minVehicleNumberFilter: number | null | undefined, maxShortVehicleNumberFilter: number | null | undefined, minShortVehicleNumberFilter: number | null | undefined, maxVehicleTypeFilter: number | null | undefined, minVehicleTypeFilter: number | null | undefined, maxStatusFilter: number | null | undefined, minStatusFilter: number | null | undefined, maxStatusDateFilter: moment.Moment | null | undefined, minStatusDateFilter: moment.Moment | null | undefined, maxParkingFilter: number | null | undefined, minParkingFilter: number | null | undefined, maxGarageFilter: number | null | undefined, minGarageFilter: number | null | undefined, maxKMFilter: number | null | undefined, minKMFilter: number | null | undefined, maxTestDateFilter: moment.Moment | null | undefined, minTestDateFilter: moment.Moment | null | undefined, maxInsuranceDateFilter: moment.Moment | null | undefined, minInsuranceDateFilter: moment.Moment | null | undefined, maxLastHandleDateFilter: moment.Moment | null | undefined, minLastHandleDateFilter: moment.Moment | null | undefined, maxNextHandleDateFilter: moment.Moment | null | undefined, minNextHandleDateFilter: moment.Moment | null | undefined, maxUpdatedFilter: moment.Moment | null | undefined, minUpdatedFilter: moment.Moment | null | undefined, maxOperatorIDFilter: number | null | undefined, minOperatorIDFilter: number | null | undefined, maxIsBusInTripFilter: number | null | undefined, minIsBusInTripFilter: number | null | undefined, maxIsBusInTripLastUpdatedFilter: moment.Moment | null | undefined, minIsBusInTripLastUpdatedFilter: moment.Moment | null | undefined, vehiclesTypeTypeDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVehiclesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxInternalIDFilter !== undefined)
            url_ += "MaxInternalIDFilter=" + encodeURIComponent("" + maxInternalIDFilter) + "&"; 
        if (minInternalIDFilter !== undefined)
            url_ += "MinInternalIDFilter=" + encodeURIComponent("" + minInternalIDFilter) + "&"; 
        if (maxVehicleNumberFilter !== undefined)
            url_ += "MaxVehicleNumberFilter=" + encodeURIComponent("" + maxVehicleNumberFilter) + "&"; 
        if (minVehicleNumberFilter !== undefined)
            url_ += "MinVehicleNumberFilter=" + encodeURIComponent("" + minVehicleNumberFilter) + "&"; 
        if (maxShortVehicleNumberFilter !== undefined)
            url_ += "MaxShortVehicleNumberFilter=" + encodeURIComponent("" + maxShortVehicleNumberFilter) + "&"; 
        if (minShortVehicleNumberFilter !== undefined)
            url_ += "MinShortVehicleNumberFilter=" + encodeURIComponent("" + minShortVehicleNumberFilter) + "&"; 
        if (maxVehicleTypeFilter !== undefined)
            url_ += "MaxVehicleTypeFilter=" + encodeURIComponent("" + maxVehicleTypeFilter) + "&"; 
        if (minVehicleTypeFilter !== undefined)
            url_ += "MinVehicleTypeFilter=" + encodeURIComponent("" + minVehicleTypeFilter) + "&"; 
        if (maxStatusFilter !== undefined)
            url_ += "MaxStatusFilter=" + encodeURIComponent("" + maxStatusFilter) + "&"; 
        if (minStatusFilter !== undefined)
            url_ += "MinStatusFilter=" + encodeURIComponent("" + minStatusFilter) + "&"; 
        if (maxStatusDateFilter !== undefined)
            url_ += "MaxStatusDateFilter=" + encodeURIComponent(maxStatusDateFilter ? "" + maxStatusDateFilter.toJSON() : "") + "&"; 
        if (minStatusDateFilter !== undefined)
            url_ += "MinStatusDateFilter=" + encodeURIComponent(minStatusDateFilter ? "" + minStatusDateFilter.toJSON() : "") + "&"; 
        if (maxParkingFilter !== undefined)
            url_ += "MaxParkingFilter=" + encodeURIComponent("" + maxParkingFilter) + "&"; 
        if (minParkingFilter !== undefined)
            url_ += "MinParkingFilter=" + encodeURIComponent("" + minParkingFilter) + "&"; 
        if (maxGarageFilter !== undefined)
            url_ += "MaxGarageFilter=" + encodeURIComponent("" + maxGarageFilter) + "&"; 
        if (minGarageFilter !== undefined)
            url_ += "MinGarageFilter=" + encodeURIComponent("" + minGarageFilter) + "&"; 
        if (maxKMFilter !== undefined)
            url_ += "MaxKMFilter=" + encodeURIComponent("" + maxKMFilter) + "&"; 
        if (minKMFilter !== undefined)
            url_ += "MinKMFilter=" + encodeURIComponent("" + minKMFilter) + "&"; 
        if (maxTestDateFilter !== undefined)
            url_ += "MaxTestDateFilter=" + encodeURIComponent(maxTestDateFilter ? "" + maxTestDateFilter.toJSON() : "") + "&"; 
        if (minTestDateFilter !== undefined)
            url_ += "MinTestDateFilter=" + encodeURIComponent(minTestDateFilter ? "" + minTestDateFilter.toJSON() : "") + "&"; 
        if (maxInsuranceDateFilter !== undefined)
            url_ += "MaxInsuranceDateFilter=" + encodeURIComponent(maxInsuranceDateFilter ? "" + maxInsuranceDateFilter.toJSON() : "") + "&"; 
        if (minInsuranceDateFilter !== undefined)
            url_ += "MinInsuranceDateFilter=" + encodeURIComponent(minInsuranceDateFilter ? "" + minInsuranceDateFilter.toJSON() : "") + "&"; 
        if (maxLastHandleDateFilter !== undefined)
            url_ += "MaxLastHandleDateFilter=" + encodeURIComponent(maxLastHandleDateFilter ? "" + maxLastHandleDateFilter.toJSON() : "") + "&"; 
        if (minLastHandleDateFilter !== undefined)
            url_ += "MinLastHandleDateFilter=" + encodeURIComponent(minLastHandleDateFilter ? "" + minLastHandleDateFilter.toJSON() : "") + "&"; 
        if (maxNextHandleDateFilter !== undefined)
            url_ += "MaxNextHandleDateFilter=" + encodeURIComponent(maxNextHandleDateFilter ? "" + maxNextHandleDateFilter.toJSON() : "") + "&"; 
        if (minNextHandleDateFilter !== undefined)
            url_ += "MinNextHandleDateFilter=" + encodeURIComponent(minNextHandleDateFilter ? "" + minNextHandleDateFilter.toJSON() : "") + "&"; 
        if (maxUpdatedFilter !== undefined)
            url_ += "MaxUpdatedFilter=" + encodeURIComponent(maxUpdatedFilter ? "" + maxUpdatedFilter.toJSON() : "") + "&"; 
        if (minUpdatedFilter !== undefined)
            url_ += "MinUpdatedFilter=" + encodeURIComponent(minUpdatedFilter ? "" + minUpdatedFilter.toJSON() : "") + "&"; 
        if (maxOperatorIDFilter !== undefined)
            url_ += "MaxOperatorIDFilter=" + encodeURIComponent("" + maxOperatorIDFilter) + "&"; 
        if (minOperatorIDFilter !== undefined)
            url_ += "MinOperatorIDFilter=" + encodeURIComponent("" + minOperatorIDFilter) + "&"; 
        if (maxIsBusInTripFilter !== undefined)
            url_ += "MaxIsBusInTripFilter=" + encodeURIComponent("" + maxIsBusInTripFilter) + "&"; 
        if (minIsBusInTripFilter !== undefined)
            url_ += "MinIsBusInTripFilter=" + encodeURIComponent("" + minIsBusInTripFilter) + "&"; 
        if (maxIsBusInTripLastUpdatedFilter !== undefined)
            url_ += "MaxIsBusInTripLastUpdatedFilter=" + encodeURIComponent(maxIsBusInTripLastUpdatedFilter ? "" + maxIsBusInTripLastUpdatedFilter.toJSON() : "") + "&"; 
        if (minIsBusInTripLastUpdatedFilter !== undefined)
            url_ += "MinIsBusInTripLastUpdatedFilter=" + encodeURIComponent(minIsBusInTripLastUpdatedFilter ? "" + minIsBusInTripLastUpdatedFilter.toJSON() : "") + "&"; 
        if (vehiclesTypeTypeDescriptionFilter !== undefined)
            url_ += "VehiclesTypeTypeDescriptionFilter=" + encodeURIComponent("" + vehiclesTypeTypeDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVehiclesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVehiclesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVehiclesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetVehiclesForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetVehiclesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVehiclesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVehiclesForView(id: number | null | undefined): Observable<GetVehiclesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/GetVehiclesForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVehiclesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVehiclesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehiclesForView(response: HttpResponseBase): Observable<GetVehiclesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVehiclesForViewDto.fromJS(resultData200) : new GetVehiclesForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVehiclesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVehiclesForEdit(id: number | null | undefined): Observable<GetVehiclesForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/GetVehiclesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVehiclesForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVehiclesForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehiclesForEdit(response: HttpResponseBase): Observable<GetVehiclesForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVehiclesForEditOutput.fromJS(resultData200) : new GetVehiclesForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVehiclesForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVehiclesDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxInternalIDFilter (optional) 
     * @param minInternalIDFilter (optional) 
     * @param maxVehicleNumberFilter (optional) 
     * @param minVehicleNumberFilter (optional) 
     * @param maxShortVehicleNumberFilter (optional) 
     * @param minShortVehicleNumberFilter (optional) 
     * @param maxVehicleTypeFilter (optional) 
     * @param minVehicleTypeFilter (optional) 
     * @param maxStatusFilter (optional) 
     * @param minStatusFilter (optional) 
     * @param maxStatusDateFilter (optional) 
     * @param minStatusDateFilter (optional) 
     * @param maxParkingFilter (optional) 
     * @param minParkingFilter (optional) 
     * @param maxGarageFilter (optional) 
     * @param minGarageFilter (optional) 
     * @param maxKMFilter (optional) 
     * @param minKMFilter (optional) 
     * @param maxTestDateFilter (optional) 
     * @param minTestDateFilter (optional) 
     * @param maxInsuranceDateFilter (optional) 
     * @param minInsuranceDateFilter (optional) 
     * @param maxLastHandleDateFilter (optional) 
     * @param minLastHandleDateFilter (optional) 
     * @param maxNextHandleDateFilter (optional) 
     * @param minNextHandleDateFilter (optional) 
     * @param maxUpdatedFilter (optional) 
     * @param minUpdatedFilter (optional) 
     * @param maxOperatorIDFilter (optional) 
     * @param minOperatorIDFilter (optional) 
     * @param maxIsBusInTripFilter (optional) 
     * @param minIsBusInTripFilter (optional) 
     * @param maxIsBusInTripLastUpdatedFilter (optional) 
     * @param minIsBusInTripLastUpdatedFilter (optional) 
     * @param vehiclesTypeTypeDescriptionFilter (optional) 
     * @return Success
     */
    getVehiclesToExcel(filter: string | null | undefined, maxInternalIDFilter: number | null | undefined, minInternalIDFilter: number | null | undefined, maxVehicleNumberFilter: number | null | undefined, minVehicleNumberFilter: number | null | undefined, maxShortVehicleNumberFilter: number | null | undefined, minShortVehicleNumberFilter: number | null | undefined, maxVehicleTypeFilter: number | null | undefined, minVehicleTypeFilter: number | null | undefined, maxStatusFilter: number | null | undefined, minStatusFilter: number | null | undefined, maxStatusDateFilter: moment.Moment | null | undefined, minStatusDateFilter: moment.Moment | null | undefined, maxParkingFilter: number | null | undefined, minParkingFilter: number | null | undefined, maxGarageFilter: number | null | undefined, minGarageFilter: number | null | undefined, maxKMFilter: number | null | undefined, minKMFilter: number | null | undefined, maxTestDateFilter: moment.Moment | null | undefined, minTestDateFilter: moment.Moment | null | undefined, maxInsuranceDateFilter: moment.Moment | null | undefined, minInsuranceDateFilter: moment.Moment | null | undefined, maxLastHandleDateFilter: moment.Moment | null | undefined, minLastHandleDateFilter: moment.Moment | null | undefined, maxNextHandleDateFilter: moment.Moment | null | undefined, minNextHandleDateFilter: moment.Moment | null | undefined, maxUpdatedFilter: moment.Moment | null | undefined, minUpdatedFilter: moment.Moment | null | undefined, maxOperatorIDFilter: number | null | undefined, minOperatorIDFilter: number | null | undefined, maxIsBusInTripFilter: number | null | undefined, minIsBusInTripFilter: number | null | undefined, maxIsBusInTripLastUpdatedFilter: moment.Moment | null | undefined, minIsBusInTripLastUpdatedFilter: moment.Moment | null | undefined, vehiclesTypeTypeDescriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/GetVehiclesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxInternalIDFilter !== undefined)
            url_ += "MaxInternalIDFilter=" + encodeURIComponent("" + maxInternalIDFilter) + "&"; 
        if (minInternalIDFilter !== undefined)
            url_ += "MinInternalIDFilter=" + encodeURIComponent("" + minInternalIDFilter) + "&"; 
        if (maxVehicleNumberFilter !== undefined)
            url_ += "MaxVehicleNumberFilter=" + encodeURIComponent("" + maxVehicleNumberFilter) + "&"; 
        if (minVehicleNumberFilter !== undefined)
            url_ += "MinVehicleNumberFilter=" + encodeURIComponent("" + minVehicleNumberFilter) + "&"; 
        if (maxShortVehicleNumberFilter !== undefined)
            url_ += "MaxShortVehicleNumberFilter=" + encodeURIComponent("" + maxShortVehicleNumberFilter) + "&"; 
        if (minShortVehicleNumberFilter !== undefined)
            url_ += "MinShortVehicleNumberFilter=" + encodeURIComponent("" + minShortVehicleNumberFilter) + "&"; 
        if (maxVehicleTypeFilter !== undefined)
            url_ += "MaxVehicleTypeFilter=" + encodeURIComponent("" + maxVehicleTypeFilter) + "&"; 
        if (minVehicleTypeFilter !== undefined)
            url_ += "MinVehicleTypeFilter=" + encodeURIComponent("" + minVehicleTypeFilter) + "&"; 
        if (maxStatusFilter !== undefined)
            url_ += "MaxStatusFilter=" + encodeURIComponent("" + maxStatusFilter) + "&"; 
        if (minStatusFilter !== undefined)
            url_ += "MinStatusFilter=" + encodeURIComponent("" + minStatusFilter) + "&"; 
        if (maxStatusDateFilter !== undefined)
            url_ += "MaxStatusDateFilter=" + encodeURIComponent(maxStatusDateFilter ? "" + maxStatusDateFilter.toJSON() : "") + "&"; 
        if (minStatusDateFilter !== undefined)
            url_ += "MinStatusDateFilter=" + encodeURIComponent(minStatusDateFilter ? "" + minStatusDateFilter.toJSON() : "") + "&"; 
        if (maxParkingFilter !== undefined)
            url_ += "MaxParkingFilter=" + encodeURIComponent("" + maxParkingFilter) + "&"; 
        if (minParkingFilter !== undefined)
            url_ += "MinParkingFilter=" + encodeURIComponent("" + minParkingFilter) + "&"; 
        if (maxGarageFilter !== undefined)
            url_ += "MaxGarageFilter=" + encodeURIComponent("" + maxGarageFilter) + "&"; 
        if (minGarageFilter !== undefined)
            url_ += "MinGarageFilter=" + encodeURIComponent("" + minGarageFilter) + "&"; 
        if (maxKMFilter !== undefined)
            url_ += "MaxKMFilter=" + encodeURIComponent("" + maxKMFilter) + "&"; 
        if (minKMFilter !== undefined)
            url_ += "MinKMFilter=" + encodeURIComponent("" + minKMFilter) + "&"; 
        if (maxTestDateFilter !== undefined)
            url_ += "MaxTestDateFilter=" + encodeURIComponent(maxTestDateFilter ? "" + maxTestDateFilter.toJSON() : "") + "&"; 
        if (minTestDateFilter !== undefined)
            url_ += "MinTestDateFilter=" + encodeURIComponent(minTestDateFilter ? "" + minTestDateFilter.toJSON() : "") + "&"; 
        if (maxInsuranceDateFilter !== undefined)
            url_ += "MaxInsuranceDateFilter=" + encodeURIComponent(maxInsuranceDateFilter ? "" + maxInsuranceDateFilter.toJSON() : "") + "&"; 
        if (minInsuranceDateFilter !== undefined)
            url_ += "MinInsuranceDateFilter=" + encodeURIComponent(minInsuranceDateFilter ? "" + minInsuranceDateFilter.toJSON() : "") + "&"; 
        if (maxLastHandleDateFilter !== undefined)
            url_ += "MaxLastHandleDateFilter=" + encodeURIComponent(maxLastHandleDateFilter ? "" + maxLastHandleDateFilter.toJSON() : "") + "&"; 
        if (minLastHandleDateFilter !== undefined)
            url_ += "MinLastHandleDateFilter=" + encodeURIComponent(minLastHandleDateFilter ? "" + minLastHandleDateFilter.toJSON() : "") + "&"; 
        if (maxNextHandleDateFilter !== undefined)
            url_ += "MaxNextHandleDateFilter=" + encodeURIComponent(maxNextHandleDateFilter ? "" + maxNextHandleDateFilter.toJSON() : "") + "&"; 
        if (minNextHandleDateFilter !== undefined)
            url_ += "MinNextHandleDateFilter=" + encodeURIComponent(minNextHandleDateFilter ? "" + minNextHandleDateFilter.toJSON() : "") + "&"; 
        if (maxUpdatedFilter !== undefined)
            url_ += "MaxUpdatedFilter=" + encodeURIComponent(maxUpdatedFilter ? "" + maxUpdatedFilter.toJSON() : "") + "&"; 
        if (minUpdatedFilter !== undefined)
            url_ += "MinUpdatedFilter=" + encodeURIComponent(minUpdatedFilter ? "" + minUpdatedFilter.toJSON() : "") + "&"; 
        if (maxOperatorIDFilter !== undefined)
            url_ += "MaxOperatorIDFilter=" + encodeURIComponent("" + maxOperatorIDFilter) + "&"; 
        if (minOperatorIDFilter !== undefined)
            url_ += "MinOperatorIDFilter=" + encodeURIComponent("" + minOperatorIDFilter) + "&"; 
        if (maxIsBusInTripFilter !== undefined)
            url_ += "MaxIsBusInTripFilter=" + encodeURIComponent("" + maxIsBusInTripFilter) + "&"; 
        if (minIsBusInTripFilter !== undefined)
            url_ += "MinIsBusInTripFilter=" + encodeURIComponent("" + minIsBusInTripFilter) + "&"; 
        if (maxIsBusInTripLastUpdatedFilter !== undefined)
            url_ += "MaxIsBusInTripLastUpdatedFilter=" + encodeURIComponent(maxIsBusInTripLastUpdatedFilter ? "" + maxIsBusInTripLastUpdatedFilter.toJSON() : "") + "&"; 
        if (minIsBusInTripLastUpdatedFilter !== undefined)
            url_ += "MinIsBusInTripLastUpdatedFilter=" + encodeURIComponent(minIsBusInTripLastUpdatedFilter ? "" + minIsBusInTripLastUpdatedFilter.toJSON() : "") + "&"; 
        if (vehiclesTypeTypeDescriptionFilter !== undefined)
            url_ += "VehiclesTypeTypeDescriptionFilter=" + encodeURIComponent("" + vehiclesTypeTypeDescriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehiclesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVehiclesTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Vehicles/GetAllVehiclesTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVehiclesTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVehiclesTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVehiclesTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class VehiclesTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param typeDescriptionFilter (optional) 
     * @param maxManufacturerFilter (optional) 
     * @param minManufacturerFilter (optional) 
     * @param maxMotorTypeFilter (optional) 
     * @param minMotorTypeFilter (optional) 
     * @param maxPassengersCountFilter (optional) 
     * @param minPassengersCountFilter (optional) 
     * @param maxDoorsCountFilter (optional) 
     * @param minDoorsCountFilter (optional) 
     * @param maxDoorsTypesFilter (optional) 
     * @param minDoorsTypesFilter (optional) 
     * @param maxGarageFrequencyKMFilter (optional) 
     * @param minGarageFrequencyKMFilter (optional) 
     * @param maxSeatsNumberFilter (optional) 
     * @param minSeatsNumberFilter (optional) 
     * @param noInterurbanFilter (optional) 
     * @param maxBusTypeFilter (optional) 
     * @param minBusTypeFilter (optional) 
     * @param maxTiresCountFilter (optional) 
     * @param minTiresCountFilter (optional) 
     * @param maxStatusFilter (optional) 
     * @param minStatusFilter (optional) 
     * @param maxModifiedByFilter (optional) 
     * @param minModifiedByFilter (optional) 
     * @param maxModificationDateFilter (optional) 
     * @param minModificationDateFilter (optional) 
     * @param maxCreatedByFilter (optional) 
     * @param minCreatedByFilter (optional) 
     * @param maxCreationDateFilter (optional) 
     * @param minCreationDateFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, typeDescriptionFilter: string | null | undefined, maxManufacturerFilter: number | null | undefined, minManufacturerFilter: number | null | undefined, maxMotorTypeFilter: number | null | undefined, minMotorTypeFilter: number | null | undefined, maxPassengersCountFilter: number | null | undefined, minPassengersCountFilter: number | null | undefined, maxDoorsCountFilter: number | null | undefined, minDoorsCountFilter: number | null | undefined, maxDoorsTypesFilter: number | null | undefined, minDoorsTypesFilter: number | null | undefined, maxGarageFrequencyKMFilter: number | null | undefined, minGarageFrequencyKMFilter: number | null | undefined, maxSeatsNumberFilter: number | null | undefined, minSeatsNumberFilter: number | null | undefined, noInterurbanFilter: number | null | undefined, maxBusTypeFilter: number | null | undefined, minBusTypeFilter: number | null | undefined, maxTiresCountFilter: number | null | undefined, minTiresCountFilter: number | null | undefined, maxStatusFilter: number | null | undefined, minStatusFilter: number | null | undefined, maxModifiedByFilter: number | null | undefined, minModifiedByFilter: number | null | undefined, maxModificationDateFilter: moment.Moment | null | undefined, minModificationDateFilter: moment.Moment | null | undefined, maxCreatedByFilter: number | null | undefined, minCreatedByFilter: number | null | undefined, maxCreationDateFilter: moment.Moment | null | undefined, minCreationDateFilter: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVehiclesTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeDescriptionFilter !== undefined)
            url_ += "TypeDescriptionFilter=" + encodeURIComponent("" + typeDescriptionFilter) + "&"; 
        if (maxManufacturerFilter !== undefined)
            url_ += "MaxManufacturerFilter=" + encodeURIComponent("" + maxManufacturerFilter) + "&"; 
        if (minManufacturerFilter !== undefined)
            url_ += "MinManufacturerFilter=" + encodeURIComponent("" + minManufacturerFilter) + "&"; 
        if (maxMotorTypeFilter !== undefined)
            url_ += "MaxMotorTypeFilter=" + encodeURIComponent("" + maxMotorTypeFilter) + "&"; 
        if (minMotorTypeFilter !== undefined)
            url_ += "MinMotorTypeFilter=" + encodeURIComponent("" + minMotorTypeFilter) + "&"; 
        if (maxPassengersCountFilter !== undefined)
            url_ += "MaxPassengersCountFilter=" + encodeURIComponent("" + maxPassengersCountFilter) + "&"; 
        if (minPassengersCountFilter !== undefined)
            url_ += "MinPassengersCountFilter=" + encodeURIComponent("" + minPassengersCountFilter) + "&"; 
        if (maxDoorsCountFilter !== undefined)
            url_ += "MaxDoorsCountFilter=" + encodeURIComponent("" + maxDoorsCountFilter) + "&"; 
        if (minDoorsCountFilter !== undefined)
            url_ += "MinDoorsCountFilter=" + encodeURIComponent("" + minDoorsCountFilter) + "&"; 
        if (maxDoorsTypesFilter !== undefined)
            url_ += "MaxDoorsTypesFilter=" + encodeURIComponent("" + maxDoorsTypesFilter) + "&"; 
        if (minDoorsTypesFilter !== undefined)
            url_ += "MinDoorsTypesFilter=" + encodeURIComponent("" + minDoorsTypesFilter) + "&"; 
        if (maxGarageFrequencyKMFilter !== undefined)
            url_ += "MaxGarageFrequencyKMFilter=" + encodeURIComponent("" + maxGarageFrequencyKMFilter) + "&"; 
        if (minGarageFrequencyKMFilter !== undefined)
            url_ += "MinGarageFrequencyKMFilter=" + encodeURIComponent("" + minGarageFrequencyKMFilter) + "&"; 
        if (maxSeatsNumberFilter !== undefined)
            url_ += "MaxSeatsNumberFilter=" + encodeURIComponent("" + maxSeatsNumberFilter) + "&"; 
        if (minSeatsNumberFilter !== undefined)
            url_ += "MinSeatsNumberFilter=" + encodeURIComponent("" + minSeatsNumberFilter) + "&"; 
        if (noInterurbanFilter !== undefined)
            url_ += "NoInterurbanFilter=" + encodeURIComponent("" + noInterurbanFilter) + "&"; 
        if (maxBusTypeFilter !== undefined)
            url_ += "MaxBusTypeFilter=" + encodeURIComponent("" + maxBusTypeFilter) + "&"; 
        if (minBusTypeFilter !== undefined)
            url_ += "MinBusTypeFilter=" + encodeURIComponent("" + minBusTypeFilter) + "&"; 
        if (maxTiresCountFilter !== undefined)
            url_ += "MaxTiresCountFilter=" + encodeURIComponent("" + maxTiresCountFilter) + "&"; 
        if (minTiresCountFilter !== undefined)
            url_ += "MinTiresCountFilter=" + encodeURIComponent("" + minTiresCountFilter) + "&"; 
        if (maxStatusFilter !== undefined)
            url_ += "MaxStatusFilter=" + encodeURIComponent("" + maxStatusFilter) + "&"; 
        if (minStatusFilter !== undefined)
            url_ += "MinStatusFilter=" + encodeURIComponent("" + minStatusFilter) + "&"; 
        if (maxModifiedByFilter !== undefined)
            url_ += "MaxModifiedByFilter=" + encodeURIComponent("" + maxModifiedByFilter) + "&"; 
        if (minModifiedByFilter !== undefined)
            url_ += "MinModifiedByFilter=" + encodeURIComponent("" + minModifiedByFilter) + "&"; 
        if (maxModificationDateFilter !== undefined)
            url_ += "MaxModificationDateFilter=" + encodeURIComponent(maxModificationDateFilter ? "" + maxModificationDateFilter.toJSON() : "") + "&"; 
        if (minModificationDateFilter !== undefined)
            url_ += "MinModificationDateFilter=" + encodeURIComponent(minModificationDateFilter ? "" + minModificationDateFilter.toJSON() : "") + "&"; 
        if (maxCreatedByFilter !== undefined)
            url_ += "MaxCreatedByFilter=" + encodeURIComponent("" + maxCreatedByFilter) + "&"; 
        if (minCreatedByFilter !== undefined)
            url_ += "MinCreatedByFilter=" + encodeURIComponent("" + minCreatedByFilter) + "&"; 
        if (maxCreationDateFilter !== undefined)
            url_ += "MaxCreationDateFilter=" + encodeURIComponent(maxCreationDateFilter ? "" + maxCreationDateFilter.toJSON() : "") + "&"; 
        if (minCreationDateFilter !== undefined)
            url_ += "MinCreationDateFilter=" + encodeURIComponent(minCreationDateFilter ? "" + minCreationDateFilter.toJSON() : "") + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVehiclesTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVehiclesTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVehiclesTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetVehiclesTypeForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetVehiclesTypeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVehiclesTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVehiclesTypeForView(id: number | null | undefined): Observable<GetVehiclesTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/GetVehiclesTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVehiclesTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVehiclesTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehiclesTypeForView(response: HttpResponseBase): Observable<GetVehiclesTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVehiclesTypeForViewDto.fromJS(resultData200) : new GetVehiclesTypeForViewDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVehiclesTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVehiclesTypeForEdit(id: number | null | undefined): Observable<GetVehiclesTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/GetVehiclesTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVehiclesTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVehiclesTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehiclesTypeForEdit(response: HttpResponseBase): Observable<GetVehiclesTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVehiclesTypeForEditOutput.fromJS(resultData200) : new GetVehiclesTypeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVehiclesTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVehiclesTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param typeDescriptionFilter (optional) 
     * @param maxManufacturerFilter (optional) 
     * @param minManufacturerFilter (optional) 
     * @param maxMotorTypeFilter (optional) 
     * @param minMotorTypeFilter (optional) 
     * @param maxPassengersCountFilter (optional) 
     * @param minPassengersCountFilter (optional) 
     * @param maxDoorsCountFilter (optional) 
     * @param minDoorsCountFilter (optional) 
     * @param maxDoorsTypesFilter (optional) 
     * @param minDoorsTypesFilter (optional) 
     * @param maxGarageFrequencyKMFilter (optional) 
     * @param minGarageFrequencyKMFilter (optional) 
     * @param maxSeatsNumberFilter (optional) 
     * @param minSeatsNumberFilter (optional) 
     * @param noInterurbanFilter (optional) 
     * @param maxBusTypeFilter (optional) 
     * @param minBusTypeFilter (optional) 
     * @param maxTiresCountFilter (optional) 
     * @param minTiresCountFilter (optional) 
     * @param maxStatusFilter (optional) 
     * @param minStatusFilter (optional) 
     * @param maxModifiedByFilter (optional) 
     * @param minModifiedByFilter (optional) 
     * @param maxModificationDateFilter (optional) 
     * @param minModificationDateFilter (optional) 
     * @param maxCreatedByFilter (optional) 
     * @param minCreatedByFilter (optional) 
     * @param maxCreationDateFilter (optional) 
     * @param minCreationDateFilter (optional) 
     * @return Success
     */
    getVehiclesTypeToExcel(filter: string | null | undefined, typeDescriptionFilter: string | null | undefined, maxManufacturerFilter: number | null | undefined, minManufacturerFilter: number | null | undefined, maxMotorTypeFilter: number | null | undefined, minMotorTypeFilter: number | null | undefined, maxPassengersCountFilter: number | null | undefined, minPassengersCountFilter: number | null | undefined, maxDoorsCountFilter: number | null | undefined, minDoorsCountFilter: number | null | undefined, maxDoorsTypesFilter: number | null | undefined, minDoorsTypesFilter: number | null | undefined, maxGarageFrequencyKMFilter: number | null | undefined, minGarageFrequencyKMFilter: number | null | undefined, maxSeatsNumberFilter: number | null | undefined, minSeatsNumberFilter: number | null | undefined, noInterurbanFilter: number | null | undefined, maxBusTypeFilter: number | null | undefined, minBusTypeFilter: number | null | undefined, maxTiresCountFilter: number | null | undefined, minTiresCountFilter: number | null | undefined, maxStatusFilter: number | null | undefined, minStatusFilter: number | null | undefined, maxModifiedByFilter: number | null | undefined, minModifiedByFilter: number | null | undefined, maxModificationDateFilter: moment.Moment | null | undefined, minModificationDateFilter: moment.Moment | null | undefined, maxCreatedByFilter: number | null | undefined, minCreatedByFilter: number | null | undefined, maxCreationDateFilter: moment.Moment | null | undefined, minCreationDateFilter: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/VehiclesType/GetVehiclesTypeToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeDescriptionFilter !== undefined)
            url_ += "TypeDescriptionFilter=" + encodeURIComponent("" + typeDescriptionFilter) + "&"; 
        if (maxManufacturerFilter !== undefined)
            url_ += "MaxManufacturerFilter=" + encodeURIComponent("" + maxManufacturerFilter) + "&"; 
        if (minManufacturerFilter !== undefined)
            url_ += "MinManufacturerFilter=" + encodeURIComponent("" + minManufacturerFilter) + "&"; 
        if (maxMotorTypeFilter !== undefined)
            url_ += "MaxMotorTypeFilter=" + encodeURIComponent("" + maxMotorTypeFilter) + "&"; 
        if (minMotorTypeFilter !== undefined)
            url_ += "MinMotorTypeFilter=" + encodeURIComponent("" + minMotorTypeFilter) + "&"; 
        if (maxPassengersCountFilter !== undefined)
            url_ += "MaxPassengersCountFilter=" + encodeURIComponent("" + maxPassengersCountFilter) + "&"; 
        if (minPassengersCountFilter !== undefined)
            url_ += "MinPassengersCountFilter=" + encodeURIComponent("" + minPassengersCountFilter) + "&"; 
        if (maxDoorsCountFilter !== undefined)
            url_ += "MaxDoorsCountFilter=" + encodeURIComponent("" + maxDoorsCountFilter) + "&"; 
        if (minDoorsCountFilter !== undefined)
            url_ += "MinDoorsCountFilter=" + encodeURIComponent("" + minDoorsCountFilter) + "&"; 
        if (maxDoorsTypesFilter !== undefined)
            url_ += "MaxDoorsTypesFilter=" + encodeURIComponent("" + maxDoorsTypesFilter) + "&"; 
        if (minDoorsTypesFilter !== undefined)
            url_ += "MinDoorsTypesFilter=" + encodeURIComponent("" + minDoorsTypesFilter) + "&"; 
        if (maxGarageFrequencyKMFilter !== undefined)
            url_ += "MaxGarageFrequencyKMFilter=" + encodeURIComponent("" + maxGarageFrequencyKMFilter) + "&"; 
        if (minGarageFrequencyKMFilter !== undefined)
            url_ += "MinGarageFrequencyKMFilter=" + encodeURIComponent("" + minGarageFrequencyKMFilter) + "&"; 
        if (maxSeatsNumberFilter !== undefined)
            url_ += "MaxSeatsNumberFilter=" + encodeURIComponent("" + maxSeatsNumberFilter) + "&"; 
        if (minSeatsNumberFilter !== undefined)
            url_ += "MinSeatsNumberFilter=" + encodeURIComponent("" + minSeatsNumberFilter) + "&"; 
        if (noInterurbanFilter !== undefined)
            url_ += "NoInterurbanFilter=" + encodeURIComponent("" + noInterurbanFilter) + "&"; 
        if (maxBusTypeFilter !== undefined)
            url_ += "MaxBusTypeFilter=" + encodeURIComponent("" + maxBusTypeFilter) + "&"; 
        if (minBusTypeFilter !== undefined)
            url_ += "MinBusTypeFilter=" + encodeURIComponent("" + minBusTypeFilter) + "&"; 
        if (maxTiresCountFilter !== undefined)
            url_ += "MaxTiresCountFilter=" + encodeURIComponent("" + maxTiresCountFilter) + "&"; 
        if (minTiresCountFilter !== undefined)
            url_ += "MinTiresCountFilter=" + encodeURIComponent("" + minTiresCountFilter) + "&"; 
        if (maxStatusFilter !== undefined)
            url_ += "MaxStatusFilter=" + encodeURIComponent("" + maxStatusFilter) + "&"; 
        if (minStatusFilter !== undefined)
            url_ += "MinStatusFilter=" + encodeURIComponent("" + minStatusFilter) + "&"; 
        if (maxModifiedByFilter !== undefined)
            url_ += "MaxModifiedByFilter=" + encodeURIComponent("" + maxModifiedByFilter) + "&"; 
        if (minModifiedByFilter !== undefined)
            url_ += "MinModifiedByFilter=" + encodeURIComponent("" + minModifiedByFilter) + "&"; 
        if (maxModificationDateFilter !== undefined)
            url_ += "MaxModificationDateFilter=" + encodeURIComponent(maxModificationDateFilter ? "" + maxModificationDateFilter.toJSON() : "") + "&"; 
        if (minModificationDateFilter !== undefined)
            url_ += "MinModificationDateFilter=" + encodeURIComponent(minModificationDateFilter ? "" + minModificationDateFilter.toJSON() : "") + "&"; 
        if (maxCreatedByFilter !== undefined)
            url_ += "MaxCreatedByFilter=" + encodeURIComponent("" + maxCreatedByFilter) + "&"; 
        if (minCreatedByFilter !== undefined)
            url_ += "MinCreatedByFilter=" + encodeURIComponent("" + minCreatedByFilter) + "&"; 
        if (maxCreationDateFilter !== undefined)
            url_ += "MaxCreationDateFilter=" + encodeURIComponent(maxCreationDateFilter ? "" + maxCreationDateFilter.toJSON() : "") + "&"; 
        if (minCreationDateFilter !== undefined)
            url_ += "MinCreationDateFilter=" + encodeURIComponent(minCreationDateFilter ? "" + minCreationDateFilter.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVehiclesTypeToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVehiclesTypeToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVehiclesTypeToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ViwTripPlanedServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlaned/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTrpPlanCalnderIDFilter (optional) 
     * @param minTrpPlanCalnderIDFilter (optional) 
     * @param trpPlanStartTimeFilter (optional) 
     * @param maxTrpPlanLineNumberFilter (optional) 
     * @param minTrpPlanLineNumberFilter (optional) 
     * @param maxTrpPlanDirectionFilter (optional) 
     * @param minTrpPlanDirectionFilter (optional) 
     * @param trpPlanDriverNameFilter (optional) 
     * @param trpPlanBusNumberFilter (optional) 
     * @param maxTripMinistryIDFilter (optional) 
     * @param minTripMinistryIDFilter (optional) 
     * @param maxTripMinistryLineNumberFilter (optional) 
     * @param minTripMinistryLineNumberFilter (optional) 
     * @param maxTripMinistryDirectionFilter (optional) 
     * @param minTripMinistryDirectionFilter (optional) 
     * @param maxTripMinistryCalenderIDFilter (optional) 
     * @param minTripMinistryCalenderIDFilter (optional) 
     * @param tripMinistryTimeSpanFilter (optional) 
     * @param tripMinistryMondayFilter (optional) 
     * @param tripMinistryTuesdayFilter (optional) 
     * @param tripMinistryWensdayFilter (optional) 
     * @param tripMinistryFridayFilter (optional) 
     * @param tripMinistryThursdayFilter (optional) 
     * @param tripMinistrySaturdayFilter (optional) 
     * @param tripMinistrySundayFilter (optional) 
     * @param maxTripMinistryStart_dateFilter (optional) 
     * @param minTripMinistryStart_dateFilter (optional) 
     * @param maxTripMinistryRouteIDFilter (optional) 
     * @param minTripMinistryRouteIDFilter (optional) 
     * @param trpPlanmondayFilter (optional) 
     * @param trpPlanTuesdayFilter (optional) 
     * @param trpPlanWensdayFilter (optional) 
     * @param trpPlanthursdayFilter (optional) 
     * @param trpPlanfridayFilter (optional) 
     * @param trpPlansaturdayFilter (optional) 
     * @param trpPlansundayFilter (optional) 
     * @param maxTrpPlanStart_dateFilter (optional) 
     * @param minTrpPlanStart_dateFilter (optional) 
     * @param maxTrpPlanEnd_dateFilter (optional) 
     * @param minTrpPlanEnd_dateFilter (optional) 
     * @param maxTrpPlanTaskNoFilter (optional) 
     * @param minTrpPlanTaskNoFilter (optional) 
     * @param maxTripPlanedIDFilter (optional) 
     * @param minTripPlanedIDFilter (optional) 
     * @param maxDriverIDPPlanedFilter (optional) 
     * @param minDriverIDPPlanedFilter (optional) 
     * @param maxBUSIDPlanlnedFilter (optional) 
     * @param minBUSIDPlanlnedFilter (optional) 
     * @param trpPlanISValidFilter (optional) 
     * @param trpPlanEndTimeFilter (optional) 
     * @param maxTrpPlanRouteIDFilter (optional) 
     * @param minTrpPlanRouteIDFilter (optional) 
     * @param maxCalenderIDFilter (optional) 
     * @param minCalenderIDFilter (optional) 
     * @param maxViwTripPlanedDailyFilter (optional) 
     * @param minViwTripPlanedDailyFilter (optional) 
     * @param catSedorFilter (optional) 
     * @param notesFilter (optional) 
     * @param busGroupFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxTrpPlanCalnderIDFilter: number | null | undefined, minTrpPlanCalnderIDFilter: number | null | undefined, trpPlanStartTimeFilter: string | null | undefined, maxTrpPlanLineNumberFilter: number | null | undefined, minTrpPlanLineNumberFilter: number | null | undefined, maxTrpPlanDirectionFilter: number | null | undefined, minTrpPlanDirectionFilter: number | null | undefined, trpPlanDriverNameFilter: string | null | undefined, trpPlanBusNumberFilter: string | null | undefined, maxTripMinistryIDFilter: number | null | undefined, minTripMinistryIDFilter: number | null | undefined, maxTripMinistryLineNumberFilter: number | null | undefined, minTripMinistryLineNumberFilter: number | null | undefined, maxTripMinistryDirectionFilter: number | null | undefined, minTripMinistryDirectionFilter: number | null | undefined, maxTripMinistryCalenderIDFilter: number | null | undefined, minTripMinistryCalenderIDFilter: number | null | undefined, tripMinistryTimeSpanFilter: string | null | undefined, tripMinistryMondayFilter: number | null | undefined, tripMinistryTuesdayFilter: number | null | undefined, tripMinistryWensdayFilter: number | null | undefined, tripMinistryFridayFilter: number | null | undefined, tripMinistryThursdayFilter: number | null | undefined, tripMinistrySaturdayFilter: number | null | undefined, tripMinistrySundayFilter: number | null | undefined, maxTripMinistryStart_dateFilter: moment.Moment | null | undefined, minTripMinistryStart_dateFilter: moment.Moment | null | undefined, maxTripMinistryRouteIDFilter: number | null | undefined, minTripMinistryRouteIDFilter: number | null | undefined, trpPlanmondayFilter: number | null | undefined, trpPlanTuesdayFilter: number | null | undefined, trpPlanWensdayFilter: number | null | undefined, trpPlanthursdayFilter: number | null | undefined, trpPlanfridayFilter: number | null | undefined, trpPlansaturdayFilter: number | null | undefined, trpPlansundayFilter: number | null | undefined, maxTrpPlanStart_dateFilter: moment.Moment | null | undefined, minTrpPlanStart_dateFilter: moment.Moment | null | undefined, maxTrpPlanEnd_dateFilter: moment.Moment | null | undefined, minTrpPlanEnd_dateFilter: moment.Moment | null | undefined, maxTrpPlanTaskNoFilter: number | null | undefined, minTrpPlanTaskNoFilter: number | null | undefined, maxTripPlanedIDFilter: number | null | undefined, minTripPlanedIDFilter: number | null | undefined, maxDriverIDPPlanedFilter: number | null | undefined, minDriverIDPPlanedFilter: number | null | undefined, maxBUSIDPlanlnedFilter: number | null | undefined, minBUSIDPlanlnedFilter: number | null | undefined, trpPlanISValidFilter: number | null | undefined, trpPlanEndTimeFilter: string | null | undefined, maxTrpPlanRouteIDFilter: number | null | undefined, minTrpPlanRouteIDFilter: number | null | undefined, maxCalenderIDFilter: number | null | undefined, minCalenderIDFilter: number | null | undefined, maxViwTripPlanedDailyFilter: number | null | undefined, minViwTripPlanedDailyFilter: number | null | undefined, catSedorFilter: string | null | undefined, notesFilter: string | null | undefined, busGroupFilter: string | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetViwTripPlanedForView> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlaned/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTrpPlanCalnderIDFilter !== undefined)
            url_ += "MaxTrpPlanCalnderIDFilter=" + encodeURIComponent("" + maxTrpPlanCalnderIDFilter) + "&"; 
        if (minTrpPlanCalnderIDFilter !== undefined)
            url_ += "MinTrpPlanCalnderIDFilter=" + encodeURIComponent("" + minTrpPlanCalnderIDFilter) + "&"; 
        if (trpPlanStartTimeFilter !== undefined)
            url_ += "TrpPlanStartTimeFilter=" + encodeURIComponent("" + trpPlanStartTimeFilter) + "&"; 
        if (maxTrpPlanLineNumberFilter !== undefined)
            url_ += "MaxTrpPlanLineNumberFilter=" + encodeURIComponent("" + maxTrpPlanLineNumberFilter) + "&"; 
        if (minTrpPlanLineNumberFilter !== undefined)
            url_ += "MinTrpPlanLineNumberFilter=" + encodeURIComponent("" + minTrpPlanLineNumberFilter) + "&"; 
        if (maxTrpPlanDirectionFilter !== undefined)
            url_ += "MaxTrpPlanDirectionFilter=" + encodeURIComponent("" + maxTrpPlanDirectionFilter) + "&"; 
        if (minTrpPlanDirectionFilter !== undefined)
            url_ += "MinTrpPlanDirectionFilter=" + encodeURIComponent("" + minTrpPlanDirectionFilter) + "&"; 
        if (trpPlanDriverNameFilter !== undefined)
            url_ += "TrpPlanDriverNameFilter=" + encodeURIComponent("" + trpPlanDriverNameFilter) + "&"; 
        if (trpPlanBusNumberFilter !== undefined)
            url_ += "TrpPlanBusNumberFilter=" + encodeURIComponent("" + trpPlanBusNumberFilter) + "&"; 
        if (maxTripMinistryIDFilter !== undefined)
            url_ += "MaxTripMinistryIDFilter=" + encodeURIComponent("" + maxTripMinistryIDFilter) + "&"; 
        if (minTripMinistryIDFilter !== undefined)
            url_ += "MinTripMinistryIDFilter=" + encodeURIComponent("" + minTripMinistryIDFilter) + "&"; 
        if (maxTripMinistryLineNumberFilter !== undefined)
            url_ += "MaxTripMinistryLineNumberFilter=" + encodeURIComponent("" + maxTripMinistryLineNumberFilter) + "&"; 
        if (minTripMinistryLineNumberFilter !== undefined)
            url_ += "MinTripMinistryLineNumberFilter=" + encodeURIComponent("" + minTripMinistryLineNumberFilter) + "&"; 
        if (maxTripMinistryDirectionFilter !== undefined)
            url_ += "MaxTripMinistryDirectionFilter=" + encodeURIComponent("" + maxTripMinistryDirectionFilter) + "&"; 
        if (minTripMinistryDirectionFilter !== undefined)
            url_ += "MinTripMinistryDirectionFilter=" + encodeURIComponent("" + minTripMinistryDirectionFilter) + "&"; 
        if (maxTripMinistryCalenderIDFilter !== undefined)
            url_ += "MaxTripMinistryCalenderIDFilter=" + encodeURIComponent("" + maxTripMinistryCalenderIDFilter) + "&"; 
        if (minTripMinistryCalenderIDFilter !== undefined)
            url_ += "MinTripMinistryCalenderIDFilter=" + encodeURIComponent("" + minTripMinistryCalenderIDFilter) + "&"; 
        if (tripMinistryTimeSpanFilter !== undefined)
            url_ += "TripMinistryTimeSpanFilter=" + encodeURIComponent("" + tripMinistryTimeSpanFilter) + "&"; 
        if (tripMinistryMondayFilter !== undefined)
            url_ += "TripMinistryMondayFilter=" + encodeURIComponent("" + tripMinistryMondayFilter) + "&"; 
        if (tripMinistryTuesdayFilter !== undefined)
            url_ += "TripMinistryTuesdayFilter=" + encodeURIComponent("" + tripMinistryTuesdayFilter) + "&"; 
        if (tripMinistryWensdayFilter !== undefined)
            url_ += "TripMinistryWensdayFilter=" + encodeURIComponent("" + tripMinistryWensdayFilter) + "&"; 
        if (tripMinistryFridayFilter !== undefined)
            url_ += "TripMinistryFridayFilter=" + encodeURIComponent("" + tripMinistryFridayFilter) + "&"; 
        if (tripMinistryThursdayFilter !== undefined)
            url_ += "TripMinistryThursdayFilter=" + encodeURIComponent("" + tripMinistryThursdayFilter) + "&"; 
        if (tripMinistrySaturdayFilter !== undefined)
            url_ += "TripMinistrySaturdayFilter=" + encodeURIComponent("" + tripMinistrySaturdayFilter) + "&"; 
        if (tripMinistrySundayFilter !== undefined)
            url_ += "TripMinistrySundayFilter=" + encodeURIComponent("" + tripMinistrySundayFilter) + "&"; 
        if (maxTripMinistryStart_dateFilter !== undefined)
            url_ += "MaxTripMinistryStart_dateFilter=" + encodeURIComponent(maxTripMinistryStart_dateFilter ? "" + maxTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (minTripMinistryStart_dateFilter !== undefined)
            url_ += "MinTripMinistryStart_dateFilter=" + encodeURIComponent(minTripMinistryStart_dateFilter ? "" + minTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTripMinistryRouteIDFilter !== undefined)
            url_ += "MaxTripMinistryRouteIDFilter=" + encodeURIComponent("" + maxTripMinistryRouteIDFilter) + "&"; 
        if (minTripMinistryRouteIDFilter !== undefined)
            url_ += "MinTripMinistryRouteIDFilter=" + encodeURIComponent("" + minTripMinistryRouteIDFilter) + "&"; 
        if (trpPlanmondayFilter !== undefined)
            url_ += "TrpPlanmondayFilter=" + encodeURIComponent("" + trpPlanmondayFilter) + "&"; 
        if (trpPlanTuesdayFilter !== undefined)
            url_ += "TrpPlanTuesdayFilter=" + encodeURIComponent("" + trpPlanTuesdayFilter) + "&"; 
        if (trpPlanWensdayFilter !== undefined)
            url_ += "TrpPlanWensdayFilter=" + encodeURIComponent("" + trpPlanWensdayFilter) + "&"; 
        if (trpPlanthursdayFilter !== undefined)
            url_ += "TrpPlanthursdayFilter=" + encodeURIComponent("" + trpPlanthursdayFilter) + "&"; 
        if (trpPlanfridayFilter !== undefined)
            url_ += "TrpPlanfridayFilter=" + encodeURIComponent("" + trpPlanfridayFilter) + "&"; 
        if (trpPlansaturdayFilter !== undefined)
            url_ += "TrpPlansaturdayFilter=" + encodeURIComponent("" + trpPlansaturdayFilter) + "&"; 
        if (trpPlansundayFilter !== undefined)
            url_ += "TrpPlansundayFilter=" + encodeURIComponent("" + trpPlansundayFilter) + "&"; 
        if (maxTrpPlanStart_dateFilter !== undefined)
            url_ += "MaxTrpPlanStart_dateFilter=" + encodeURIComponent(maxTrpPlanStart_dateFilter ? "" + maxTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanStart_dateFilter !== undefined)
            url_ += "MinTrpPlanStart_dateFilter=" + encodeURIComponent(minTrpPlanStart_dateFilter ? "" + minTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanEnd_dateFilter !== undefined)
            url_ += "MaxTrpPlanEnd_dateFilter=" + encodeURIComponent(maxTrpPlanEnd_dateFilter ? "" + maxTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanEnd_dateFilter !== undefined)
            url_ += "MinTrpPlanEnd_dateFilter=" + encodeURIComponent(minTrpPlanEnd_dateFilter ? "" + minTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanTaskNoFilter !== undefined)
            url_ += "MaxTrpPlanTaskNoFilter=" + encodeURIComponent("" + maxTrpPlanTaskNoFilter) + "&"; 
        if (minTrpPlanTaskNoFilter !== undefined)
            url_ += "MinTrpPlanTaskNoFilter=" + encodeURIComponent("" + minTrpPlanTaskNoFilter) + "&"; 
        if (maxTripPlanedIDFilter !== undefined)
            url_ += "MaxTripPlanedIDFilter=" + encodeURIComponent("" + maxTripPlanedIDFilter) + "&"; 
        if (minTripPlanedIDFilter !== undefined)
            url_ += "MinTripPlanedIDFilter=" + encodeURIComponent("" + minTripPlanedIDFilter) + "&"; 
        if (maxDriverIDPPlanedFilter !== undefined)
            url_ += "MaxDriverIDPPlanedFilter=" + encodeURIComponent("" + maxDriverIDPPlanedFilter) + "&"; 
        if (minDriverIDPPlanedFilter !== undefined)
            url_ += "MinDriverIDPPlanedFilter=" + encodeURIComponent("" + minDriverIDPPlanedFilter) + "&"; 
        if (maxBUSIDPlanlnedFilter !== undefined)
            url_ += "MaxBUSIDPlanlnedFilter=" + encodeURIComponent("" + maxBUSIDPlanlnedFilter) + "&"; 
        if (minBUSIDPlanlnedFilter !== undefined)
            url_ += "MinBUSIDPlanlnedFilter=" + encodeURIComponent("" + minBUSIDPlanlnedFilter) + "&"; 
        if (trpPlanISValidFilter !== undefined)
            url_ += "TrpPlanISValidFilter=" + encodeURIComponent("" + trpPlanISValidFilter) + "&"; 
        if (trpPlanEndTimeFilter !== undefined)
            url_ += "TrpPlanEndTimeFilter=" + encodeURIComponent("" + trpPlanEndTimeFilter) + "&"; 
        if (maxTrpPlanRouteIDFilter !== undefined)
            url_ += "MaxTrpPlanRouteIDFilter=" + encodeURIComponent("" + maxTrpPlanRouteIDFilter) + "&"; 
        if (minTrpPlanRouteIDFilter !== undefined)
            url_ += "MinTrpPlanRouteIDFilter=" + encodeURIComponent("" + minTrpPlanRouteIDFilter) + "&"; 
        if (maxCalenderIDFilter !== undefined)
            url_ += "MaxCalenderIDFilter=" + encodeURIComponent("" + maxCalenderIDFilter) + "&"; 
        if (minCalenderIDFilter !== undefined)
            url_ += "MinCalenderIDFilter=" + encodeURIComponent("" + minCalenderIDFilter) + "&"; 
        if (maxViwTripPlanedDailyFilter !== undefined)
            url_ += "MaxViwTripPlanedDailyFilter=" + encodeURIComponent("" + maxViwTripPlanedDailyFilter) + "&"; 
        if (minViwTripPlanedDailyFilter !== undefined)
            url_ += "MinViwTripPlanedDailyFilter=" + encodeURIComponent("" + minViwTripPlanedDailyFilter) + "&"; 
        if (catSedorFilter !== undefined)
            url_ += "CatSedorFilter=" + encodeURIComponent("" + catSedorFilter) + "&"; 
        if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetViwTripPlanedForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetViwTripPlanedForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetViwTripPlanedForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetViwTripPlanedForView.fromJS(resultData200) : new PagedResultDtoOfGetViwTripPlanedForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetViwTripPlanedForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getViwTripPlanedForEdit(id: number | null | undefined): Observable<GetViwTripPlanedForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlaned/GetViwTripPlanedForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViwTripPlanedForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViwTripPlanedForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetViwTripPlanedForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetViwTripPlanedForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetViwTripPlanedForEdit(response: HttpResponseBase): Observable<GetViwTripPlanedForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetViwTripPlanedForEditOutput.fromJS(resultData200) : new GetViwTripPlanedForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetViwTripPlanedForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditViwTripPlanedDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlaned/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlaned/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTrpPlanCalnderIDFilter (optional) 
     * @param minTrpPlanCalnderIDFilter (optional) 
     * @param trpPlanStartTimeFilter (optional) 
     * @param maxTrpPlanLineNumberFilter (optional) 
     * @param minTrpPlanLineNumberFilter (optional) 
     * @param maxTrpPlanDirectionFilter (optional) 
     * @param minTrpPlanDirectionFilter (optional) 
     * @param trpPlanDriverNameFilter (optional) 
     * @param trpPlanBusNumberFilter (optional) 
     * @param maxTripMinistryIDFilter (optional) 
     * @param minTripMinistryIDFilter (optional) 
     * @param maxTripMinistryLineNumberFilter (optional) 
     * @param minTripMinistryLineNumberFilter (optional) 
     * @param maxTripMinistryDirectionFilter (optional) 
     * @param minTripMinistryDirectionFilter (optional) 
     * @param maxTripMinistryCalenderIDFilter (optional) 
     * @param minTripMinistryCalenderIDFilter (optional) 
     * @param tripMinistryTimeSpanFilter (optional) 
     * @param tripMinistryMondayFilter (optional) 
     * @param tripMinistryTuesdayFilter (optional) 
     * @param tripMinistryWensdayFilter (optional) 
     * @param tripMinistryFridayFilter (optional) 
     * @param tripMinistryThursdayFilter (optional) 
     * @param tripMinistrySaturdayFilter (optional) 
     * @param tripMinistrySundayFilter (optional) 
     * @param maxTripMinistryStart_dateFilter (optional) 
     * @param minTripMinistryStart_dateFilter (optional) 
     * @param maxTripMinistryRouteIDFilter (optional) 
     * @param minTripMinistryRouteIDFilter (optional) 
     * @param trpPlanmondayFilter (optional) 
     * @param trpPlanTuesdayFilter (optional) 
     * @param trpPlanWensdayFilter (optional) 
     * @param trpPlanthursdayFilter (optional) 
     * @param trpPlanfridayFilter (optional) 
     * @param trpPlansaturdayFilter (optional) 
     * @param trpPlansundayFilter (optional) 
     * @param maxTrpPlanStart_dateFilter (optional) 
     * @param minTrpPlanStart_dateFilter (optional) 
     * @param maxTrpPlanEnd_dateFilter (optional) 
     * @param minTrpPlanEnd_dateFilter (optional) 
     * @param maxTrpPlanTaskNoFilter (optional) 
     * @param minTrpPlanTaskNoFilter (optional) 
     * @param maxTripPlanedIDFilter (optional) 
     * @param minTripPlanedIDFilter (optional) 
     * @param maxDriverIDPPlanedFilter (optional) 
     * @param minDriverIDPPlanedFilter (optional) 
     * @param maxBUSIDPlanlnedFilter (optional) 
     * @param minBUSIDPlanlnedFilter (optional) 
     * @param trpPlanISValidFilter (optional) 
     * @param trpPlanEndTimeFilter (optional) 
     * @param maxTrpPlanRouteIDFilter (optional) 
     * @param minTrpPlanRouteIDFilter (optional) 
     * @param maxCalenderIDFilter (optional) 
     * @param minCalenderIDFilter (optional) 
     * @param maxViwTripPlanedDailyFilter (optional) 
     * @param minViwTripPlanedDailyFilter (optional) 
     * @param catSedorFilter (optional) 
     * @param notesFilter (optional) 
     * @param busGroupFilter (optional) 
     * @param maxDriverFilter (optional) 
     * @param minDriverFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @return Success
     */
    getViwTripPlanedToExcel(filter: string | null | undefined, maxTrpPlanCalnderIDFilter: number | null | undefined, minTrpPlanCalnderIDFilter: number | null | undefined, trpPlanStartTimeFilter: string | null | undefined, maxTrpPlanLineNumberFilter: number | null | undefined, minTrpPlanLineNumberFilter: number | null | undefined, maxTrpPlanDirectionFilter: number | null | undefined, minTrpPlanDirectionFilter: number | null | undefined, trpPlanDriverNameFilter: string | null | undefined, trpPlanBusNumberFilter: string | null | undefined, maxTripMinistryIDFilter: number | null | undefined, minTripMinistryIDFilter: number | null | undefined, maxTripMinistryLineNumberFilter: number | null | undefined, minTripMinistryLineNumberFilter: number | null | undefined, maxTripMinistryDirectionFilter: number | null | undefined, minTripMinistryDirectionFilter: number | null | undefined, maxTripMinistryCalenderIDFilter: number | null | undefined, minTripMinistryCalenderIDFilter: number | null | undefined, tripMinistryTimeSpanFilter: string | null | undefined, tripMinistryMondayFilter: number | null | undefined, tripMinistryTuesdayFilter: number | null | undefined, tripMinistryWensdayFilter: number | null | undefined, tripMinistryFridayFilter: number | null | undefined, tripMinistryThursdayFilter: number | null | undefined, tripMinistrySaturdayFilter: number | null | undefined, tripMinistrySundayFilter: number | null | undefined, maxTripMinistryStart_dateFilter: moment.Moment | null | undefined, minTripMinistryStart_dateFilter: moment.Moment | null | undefined, maxTripMinistryRouteIDFilter: number | null | undefined, minTripMinistryRouteIDFilter: number | null | undefined, trpPlanmondayFilter: number | null | undefined, trpPlanTuesdayFilter: number | null | undefined, trpPlanWensdayFilter: number | null | undefined, trpPlanthursdayFilter: number | null | undefined, trpPlanfridayFilter: number | null | undefined, trpPlansaturdayFilter: number | null | undefined, trpPlansundayFilter: number | null | undefined, maxTrpPlanStart_dateFilter: moment.Moment | null | undefined, minTrpPlanStart_dateFilter: moment.Moment | null | undefined, maxTrpPlanEnd_dateFilter: moment.Moment | null | undefined, minTrpPlanEnd_dateFilter: moment.Moment | null | undefined, maxTrpPlanTaskNoFilter: number | null | undefined, minTrpPlanTaskNoFilter: number | null | undefined, maxTripPlanedIDFilter: number | null | undefined, minTripPlanedIDFilter: number | null | undefined, maxDriverIDPPlanedFilter: number | null | undefined, minDriverIDPPlanedFilter: number | null | undefined, maxBUSIDPlanlnedFilter: number | null | undefined, minBUSIDPlanlnedFilter: number | null | undefined, trpPlanISValidFilter: number | null | undefined, trpPlanEndTimeFilter: string | null | undefined, maxTrpPlanRouteIDFilter: number | null | undefined, minTrpPlanRouteIDFilter: number | null | undefined, maxCalenderIDFilter: number | null | undefined, minCalenderIDFilter: number | null | undefined, maxViwTripPlanedDailyFilter: number | null | undefined, minViwTripPlanedDailyFilter: number | null | undefined, catSedorFilter: string | null | undefined, notesFilter: string | null | undefined, busGroupFilter: string | null | undefined, maxDriverFilter: number | null | undefined, minDriverFilter: number | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlaned/GetViwTripPlanedToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTrpPlanCalnderIDFilter !== undefined)
            url_ += "MaxTrpPlanCalnderIDFilter=" + encodeURIComponent("" + maxTrpPlanCalnderIDFilter) + "&"; 
        if (minTrpPlanCalnderIDFilter !== undefined)
            url_ += "MinTrpPlanCalnderIDFilter=" + encodeURIComponent("" + minTrpPlanCalnderIDFilter) + "&"; 
        if (trpPlanStartTimeFilter !== undefined)
            url_ += "TrpPlanStartTimeFilter=" + encodeURIComponent("" + trpPlanStartTimeFilter) + "&"; 
        if (maxTrpPlanLineNumberFilter !== undefined)
            url_ += "MaxTrpPlanLineNumberFilter=" + encodeURIComponent("" + maxTrpPlanLineNumberFilter) + "&"; 
        if (minTrpPlanLineNumberFilter !== undefined)
            url_ += "MinTrpPlanLineNumberFilter=" + encodeURIComponent("" + minTrpPlanLineNumberFilter) + "&"; 
        if (maxTrpPlanDirectionFilter !== undefined)
            url_ += "MaxTrpPlanDirectionFilter=" + encodeURIComponent("" + maxTrpPlanDirectionFilter) + "&"; 
        if (minTrpPlanDirectionFilter !== undefined)
            url_ += "MinTrpPlanDirectionFilter=" + encodeURIComponent("" + minTrpPlanDirectionFilter) + "&"; 
        if (trpPlanDriverNameFilter !== undefined)
            url_ += "TrpPlanDriverNameFilter=" + encodeURIComponent("" + trpPlanDriverNameFilter) + "&"; 
        if (trpPlanBusNumberFilter !== undefined)
            url_ += "TrpPlanBusNumberFilter=" + encodeURIComponent("" + trpPlanBusNumberFilter) + "&"; 
        if (maxTripMinistryIDFilter !== undefined)
            url_ += "MaxTripMinistryIDFilter=" + encodeURIComponent("" + maxTripMinistryIDFilter) + "&"; 
        if (minTripMinistryIDFilter !== undefined)
            url_ += "MinTripMinistryIDFilter=" + encodeURIComponent("" + minTripMinistryIDFilter) + "&"; 
        if (maxTripMinistryLineNumberFilter !== undefined)
            url_ += "MaxTripMinistryLineNumberFilter=" + encodeURIComponent("" + maxTripMinistryLineNumberFilter) + "&"; 
        if (minTripMinistryLineNumberFilter !== undefined)
            url_ += "MinTripMinistryLineNumberFilter=" + encodeURIComponent("" + minTripMinistryLineNumberFilter) + "&"; 
        if (maxTripMinistryDirectionFilter !== undefined)
            url_ += "MaxTripMinistryDirectionFilter=" + encodeURIComponent("" + maxTripMinistryDirectionFilter) + "&"; 
        if (minTripMinistryDirectionFilter !== undefined)
            url_ += "MinTripMinistryDirectionFilter=" + encodeURIComponent("" + minTripMinistryDirectionFilter) + "&"; 
        if (maxTripMinistryCalenderIDFilter !== undefined)
            url_ += "MaxTripMinistryCalenderIDFilter=" + encodeURIComponent("" + maxTripMinistryCalenderIDFilter) + "&"; 
        if (minTripMinistryCalenderIDFilter !== undefined)
            url_ += "MinTripMinistryCalenderIDFilter=" + encodeURIComponent("" + minTripMinistryCalenderIDFilter) + "&"; 
        if (tripMinistryTimeSpanFilter !== undefined)
            url_ += "TripMinistryTimeSpanFilter=" + encodeURIComponent("" + tripMinistryTimeSpanFilter) + "&"; 
        if (tripMinistryMondayFilter !== undefined)
            url_ += "TripMinistryMondayFilter=" + encodeURIComponent("" + tripMinistryMondayFilter) + "&"; 
        if (tripMinistryTuesdayFilter !== undefined)
            url_ += "TripMinistryTuesdayFilter=" + encodeURIComponent("" + tripMinistryTuesdayFilter) + "&"; 
        if (tripMinistryWensdayFilter !== undefined)
            url_ += "TripMinistryWensdayFilter=" + encodeURIComponent("" + tripMinistryWensdayFilter) + "&"; 
        if (tripMinistryFridayFilter !== undefined)
            url_ += "TripMinistryFridayFilter=" + encodeURIComponent("" + tripMinistryFridayFilter) + "&"; 
        if (tripMinistryThursdayFilter !== undefined)
            url_ += "TripMinistryThursdayFilter=" + encodeURIComponent("" + tripMinistryThursdayFilter) + "&"; 
        if (tripMinistrySaturdayFilter !== undefined)
            url_ += "TripMinistrySaturdayFilter=" + encodeURIComponent("" + tripMinistrySaturdayFilter) + "&"; 
        if (tripMinistrySundayFilter !== undefined)
            url_ += "TripMinistrySundayFilter=" + encodeURIComponent("" + tripMinistrySundayFilter) + "&"; 
        if (maxTripMinistryStart_dateFilter !== undefined)
            url_ += "MaxTripMinistryStart_dateFilter=" + encodeURIComponent(maxTripMinistryStart_dateFilter ? "" + maxTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (minTripMinistryStart_dateFilter !== undefined)
            url_ += "MinTripMinistryStart_dateFilter=" + encodeURIComponent(minTripMinistryStart_dateFilter ? "" + minTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTripMinistryRouteIDFilter !== undefined)
            url_ += "MaxTripMinistryRouteIDFilter=" + encodeURIComponent("" + maxTripMinistryRouteIDFilter) + "&"; 
        if (minTripMinistryRouteIDFilter !== undefined)
            url_ += "MinTripMinistryRouteIDFilter=" + encodeURIComponent("" + minTripMinistryRouteIDFilter) + "&"; 
        if (trpPlanmondayFilter !== undefined)
            url_ += "TrpPlanmondayFilter=" + encodeURIComponent("" + trpPlanmondayFilter) + "&"; 
        if (trpPlanTuesdayFilter !== undefined)
            url_ += "TrpPlanTuesdayFilter=" + encodeURIComponent("" + trpPlanTuesdayFilter) + "&"; 
        if (trpPlanWensdayFilter !== undefined)
            url_ += "TrpPlanWensdayFilter=" + encodeURIComponent("" + trpPlanWensdayFilter) + "&"; 
        if (trpPlanthursdayFilter !== undefined)
            url_ += "TrpPlanthursdayFilter=" + encodeURIComponent("" + trpPlanthursdayFilter) + "&"; 
        if (trpPlanfridayFilter !== undefined)
            url_ += "TrpPlanfridayFilter=" + encodeURIComponent("" + trpPlanfridayFilter) + "&"; 
        if (trpPlansaturdayFilter !== undefined)
            url_ += "TrpPlansaturdayFilter=" + encodeURIComponent("" + trpPlansaturdayFilter) + "&"; 
        if (trpPlansundayFilter !== undefined)
            url_ += "TrpPlansundayFilter=" + encodeURIComponent("" + trpPlansundayFilter) + "&"; 
        if (maxTrpPlanStart_dateFilter !== undefined)
            url_ += "MaxTrpPlanStart_dateFilter=" + encodeURIComponent(maxTrpPlanStart_dateFilter ? "" + maxTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanStart_dateFilter !== undefined)
            url_ += "MinTrpPlanStart_dateFilter=" + encodeURIComponent(minTrpPlanStart_dateFilter ? "" + minTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanEnd_dateFilter !== undefined)
            url_ += "MaxTrpPlanEnd_dateFilter=" + encodeURIComponent(maxTrpPlanEnd_dateFilter ? "" + maxTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanEnd_dateFilter !== undefined)
            url_ += "MinTrpPlanEnd_dateFilter=" + encodeURIComponent(minTrpPlanEnd_dateFilter ? "" + minTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanTaskNoFilter !== undefined)
            url_ += "MaxTrpPlanTaskNoFilter=" + encodeURIComponent("" + maxTrpPlanTaskNoFilter) + "&"; 
        if (minTrpPlanTaskNoFilter !== undefined)
            url_ += "MinTrpPlanTaskNoFilter=" + encodeURIComponent("" + minTrpPlanTaskNoFilter) + "&"; 
        if (maxTripPlanedIDFilter !== undefined)
            url_ += "MaxTripPlanedIDFilter=" + encodeURIComponent("" + maxTripPlanedIDFilter) + "&"; 
        if (minTripPlanedIDFilter !== undefined)
            url_ += "MinTripPlanedIDFilter=" + encodeURIComponent("" + minTripPlanedIDFilter) + "&"; 
        if (maxDriverIDPPlanedFilter !== undefined)
            url_ += "MaxDriverIDPPlanedFilter=" + encodeURIComponent("" + maxDriverIDPPlanedFilter) + "&"; 
        if (minDriverIDPPlanedFilter !== undefined)
            url_ += "MinDriverIDPPlanedFilter=" + encodeURIComponent("" + minDriverIDPPlanedFilter) + "&"; 
        if (maxBUSIDPlanlnedFilter !== undefined)
            url_ += "MaxBUSIDPlanlnedFilter=" + encodeURIComponent("" + maxBUSIDPlanlnedFilter) + "&"; 
        if (minBUSIDPlanlnedFilter !== undefined)
            url_ += "MinBUSIDPlanlnedFilter=" + encodeURIComponent("" + minBUSIDPlanlnedFilter) + "&"; 
        if (trpPlanISValidFilter !== undefined)
            url_ += "TrpPlanISValidFilter=" + encodeURIComponent("" + trpPlanISValidFilter) + "&"; 
        if (trpPlanEndTimeFilter !== undefined)
            url_ += "TrpPlanEndTimeFilter=" + encodeURIComponent("" + trpPlanEndTimeFilter) + "&"; 
        if (maxTrpPlanRouteIDFilter !== undefined)
            url_ += "MaxTrpPlanRouteIDFilter=" + encodeURIComponent("" + maxTrpPlanRouteIDFilter) + "&"; 
        if (minTrpPlanRouteIDFilter !== undefined)
            url_ += "MinTrpPlanRouteIDFilter=" + encodeURIComponent("" + minTrpPlanRouteIDFilter) + "&"; 
        if (maxCalenderIDFilter !== undefined)
            url_ += "MaxCalenderIDFilter=" + encodeURIComponent("" + maxCalenderIDFilter) + "&"; 
        if (minCalenderIDFilter !== undefined)
            url_ += "MinCalenderIDFilter=" + encodeURIComponent("" + minCalenderIDFilter) + "&"; 
        if (maxViwTripPlanedDailyFilter !== undefined)
            url_ += "MaxViwTripPlanedDailyFilter=" + encodeURIComponent("" + maxViwTripPlanedDailyFilter) + "&"; 
        if (minViwTripPlanedDailyFilter !== undefined)
            url_ += "MinViwTripPlanedDailyFilter=" + encodeURIComponent("" + minViwTripPlanedDailyFilter) + "&"; 
        if (catSedorFilter !== undefined)
            url_ += "CatSedorFilter=" + encodeURIComponent("" + catSedorFilter) + "&"; 
        if (notesFilter !== undefined)
            url_ += "NotesFilter=" + encodeURIComponent("" + notesFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        if (maxDriverFilter !== undefined)
            url_ += "MaxDriverFilter=" + encodeURIComponent("" + maxDriverFilter) + "&"; 
        if (minDriverFilter !== undefined)
            url_ += "MinDriverFilter=" + encodeURIComponent("" + minDriverFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViwTripPlanedToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViwTripPlanedToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetViwTripPlanedToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class ViwTripPlanedDailyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllHeaders(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetAllHeaders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHeaders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHeaders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHeaders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param workingdate (optional) 
     * @param trpPlanBusNumber (optional) 
     * @param busGroup (optional) 
     * @param busID (optional) 
     * @return Success
     */
    getAllByBus(workingdate: moment.Moment | null | undefined, trpPlanBusNumber: string | null | undefined, busGroup: string | null | undefined, busID: number | null | undefined): Observable<PagedResultDtoOfFilterReturnPlanByBus> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetAllByBus?";
        if (workingdate !== undefined)
            url_ += "Workingdate=" + encodeURIComponent(workingdate ? "" + workingdate.toJSON() : "") + "&"; 
        if (trpPlanBusNumber !== undefined)
            url_ += "TrpPlanBusNumber=" + encodeURIComponent("" + trpPlanBusNumber) + "&"; 
        if (busGroup !== undefined)
            url_ += "BusGroup=" + encodeURIComponent("" + busGroup) + "&"; 
        if (busID !== undefined)
            url_ += "BusID=" + encodeURIComponent("" + busID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByBus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByBus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFilterReturnPlanByBus>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFilterReturnPlanByBus>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByBus(response: HttpResponseBase): Observable<PagedResultDtoOfFilterReturnPlanByBus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfFilterReturnPlanByBus.fromJS(resultData200) : new PagedResultDtoOfFilterReturnPlanByBus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFilterReturnPlanByBus>(<any>null);
    }

    /**
     * @param workingdate (optional) 
     * @param trpPlanDriverName (optional) 
     * @param trpPlanBusNumber (optional) 
     * @param trpPlanTaskNo (optional) 
     * @param busGroup (optional) 
     * @param driverIDPPlaned (optional) 
     * @param busID (optional) 
     * @return Success
     */
    getAllTripByTaskNo(workingdate: moment.Moment | null | undefined, trpPlanDriverName: string | null | undefined, trpPlanBusNumber: string | null | undefined, trpPlanTaskNo: number | null | undefined, busGroup: string | null | undefined, driverIDPPlaned: number | null | undefined, busID: number | null | undefined): Observable<PagedResultDtoOfFilterReturnPlanByTaskno> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetAllTripByTaskNo?";
        if (workingdate !== undefined)
            url_ += "Workingdate=" + encodeURIComponent(workingdate ? "" + workingdate.toJSON() : "") + "&"; 
        if (trpPlanDriverName !== undefined)
            url_ += "TrpPlanDriverName=" + encodeURIComponent("" + trpPlanDriverName) + "&"; 
        if (trpPlanBusNumber !== undefined)
            url_ += "TrpPlanBusNumber=" + encodeURIComponent("" + trpPlanBusNumber) + "&"; 
        if (trpPlanTaskNo !== undefined)
            url_ += "TrpPlanTaskNo=" + encodeURIComponent("" + trpPlanTaskNo) + "&"; 
        if (busGroup !== undefined)
            url_ += "BusGroup=" + encodeURIComponent("" + busGroup) + "&"; 
        if (driverIDPPlaned !== undefined)
            url_ += "DriverIDPPlaned=" + encodeURIComponent("" + driverIDPPlaned) + "&"; 
        if (busID !== undefined)
            url_ += "BusID=" + encodeURIComponent("" + busID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTripByTaskNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTripByTaskNo(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFilterReturnPlanByTaskno>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFilterReturnPlanByTaskno>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTripByTaskNo(response: HttpResponseBase): Observable<PagedResultDtoOfFilterReturnPlanByTaskno> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfFilterReturnPlanByTaskno.fromJS(resultData200) : new PagedResultDtoOfFilterReturnPlanByTaskno();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFilterReturnPlanByTaskno>(<any>null);
    }

    /**
     * @param workingdate (optional) 
     * @param filter (optional) 
     * @param tripIDGTFSFilter (optional) 
     * @param trpPlanBusNumberFilter (optional) 
     * @param maxTrpPlanCalnderIDFilter (optional) 
     * @param minTrpPlanCalnderIDFilter (optional) 
     * @param trpPlanStartTimeFilter (optional) 
     * @param maxTrpPlanLineNumberFilter (optional) 
     * @param minTrpPlanLineNumberFilter (optional) 
     * @param maxTrpPlanDirectionFilter (optional) 
     * @param minTrpPlanDirectionFilter (optional) 
     * @param trpPlanDriverNameFilter (optional) 
     * @param maxTripMinistryIDFilter (optional) 
     * @param minTripMinistryIDFilter (optional) 
     * @param maxTripMinistryLineNumberFilter (optional) 
     * @param minTripMinistryLineNumberFilter (optional) 
     * @param maxTripMinistryDirectionFilter (optional) 
     * @param minTripMinistryDirectionFilter (optional) 
     * @param maxTripMinistryCalenderIDFilter (optional) 
     * @param minTripMinistryCalenderIDFilter (optional) 
     * @param tripMinistryTimeSpanFilter (optional) 
     * @param tripMinistryMondayFilter (optional) 
     * @param tripMinistryTuesdayFilter (optional) 
     * @param tripMinistryWensdayFilter (optional) 
     * @param tripMinistryFridayFilter (optional) 
     * @param tripMinistryThursdayFilter (optional) 
     * @param tripMinistrySaturdayFilter (optional) 
     * @param tripMinistrySundayFilter (optional) 
     * @param maxTripMinistryStart_dateFilter (optional) 
     * @param minTripMinistryStart_dateFilter (optional) 
     * @param maxTripMinistryRouteIDFilter (optional) 
     * @param minTripMinistryRouteIDFilter (optional) 
     * @param trpPlanmondayFilter (optional) 
     * @param trpPlanTuesdayFilter (optional) 
     * @param trpPlanWensdayFilter (optional) 
     * @param trpPlanthursdayFilter (optional) 
     * @param trpPlanfridayFilter (optional) 
     * @param trpPlansaturdayFilter (optional) 
     * @param trpPlansundayFilter (optional) 
     * @param maxTrpPlanStart_dateFilter (optional) 
     * @param minTrpPlanStart_dateFilter (optional) 
     * @param maxTrpPlanEnd_dateFilter (optional) 
     * @param minTrpPlanEnd_dateFilter (optional) 
     * @param maxTrpPlanTaskNoFilter (optional) 
     * @param minTrpPlanTaskNoFilter (optional) 
     * @param maxTripPlanedIDFilter (optional) 
     * @param minTripPlanedIDFilter (optional) 
     * @param maxDriverIDPPlanedFilter (optional) 
     * @param minDriverIDPPlanedFilter (optional) 
     * @param maxBUSIDPlanlnedFilter (optional) 
     * @param minBUSIDPlanlnedFilter (optional) 
     * @param trpPlanISValidFilter (optional) 
     * @param trpPlanEndTimeFilter (optional) 
     * @param maxTrpPlanRouteIDFilter (optional) 
     * @param minTrpPlanRouteIDFilter (optional) 
     * @param maxWorkingdayFilter (optional) 
     * @param minWorkingdayFilter (optional) 
     * @param maxAutranFilter (optional) 
     * @param minAutranFilter (optional) 
     * @param startLocationNameFilter (optional) 
     * @param startLocationNameHebFilter (optional) 
     * @param maxStartLocationCodeFilter (optional) 
     * @param minStartLocationCodeFilter (optional) 
     * @param maxStartLocationLatitudeFilter (optional) 
     * @param minStartLocationLatitudeFilter (optional) 
     * @param maxStartLocationLongitudeFilter (optional) 
     * @param minStartLocationLongitudeFilter (optional) 
     * @param maxRouteTotalKMFilter (optional) 
     * @param minRouteTotalKMFilter (optional) 
     * @param maxRouteTotalMinutesFilter (optional) 
     * @param minRouteTotalMinutesFilter (optional) 
     * @param isMinistryFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param routeIDGTFSFilter (optional) 
     * @param controlStartTimeFilter (optional) 
     * @param tripTypesNameFilter (optional) 
     * @param busGroupFilter (optional) 
     * @param maxDriverOrginalFilter (optional) 
     * @param minDriverOrginalFilter (optional) 
     * @param maxBusOrginalFilter (optional) 
     * @param minBusOrginalFilter (optional) 
     * @param endLocationNameFilter (optional) 
     * @param endLocationNameHebrewFilter (optional) 
     * @param maxEndStationCodeFilter (optional) 
     * @param minEndStationCodeFilter (optional) 
     * @param maxEndLatitudeFilter (optional) 
     * @param minEndLatitudeFilter (optional) 
     * @param maxEndLongitudeFilter (optional) 
     * @param minEndLongitudeFilter (optional) 
     * @param maxTripPlannedWothDriverIDFilter (optional) 
     * @param minTripPlannedWothDriverIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWithBuilWorkingDate(workingdate: moment.Moment | null | undefined, filter: string | null | undefined, tripIDGTFSFilter: string | null | undefined, trpPlanBusNumberFilter: string | null | undefined, maxTrpPlanCalnderIDFilter: number | null | undefined, minTrpPlanCalnderIDFilter: number | null | undefined, trpPlanStartTimeFilter: string | null | undefined, maxTrpPlanLineNumberFilter: number | null | undefined, minTrpPlanLineNumberFilter: number | null | undefined, maxTrpPlanDirectionFilter: number | null | undefined, minTrpPlanDirectionFilter: number | null | undefined, trpPlanDriverNameFilter: string | null | undefined, maxTripMinistryIDFilter: number | null | undefined, minTripMinistryIDFilter: number | null | undefined, maxTripMinistryLineNumberFilter: number | null | undefined, minTripMinistryLineNumberFilter: number | null | undefined, maxTripMinistryDirectionFilter: number | null | undefined, minTripMinistryDirectionFilter: number | null | undefined, maxTripMinistryCalenderIDFilter: number | null | undefined, minTripMinistryCalenderIDFilter: number | null | undefined, tripMinistryTimeSpanFilter: string | null | undefined, tripMinistryMondayFilter: number | null | undefined, tripMinistryTuesdayFilter: number | null | undefined, tripMinistryWensdayFilter: number | null | undefined, tripMinistryFridayFilter: number | null | undefined, tripMinistryThursdayFilter: number | null | undefined, tripMinistrySaturdayFilter: number | null | undefined, tripMinistrySundayFilter: number | null | undefined, maxTripMinistryStart_dateFilter: moment.Moment | null | undefined, minTripMinistryStart_dateFilter: moment.Moment | null | undefined, maxTripMinistryRouteIDFilter: number | null | undefined, minTripMinistryRouteIDFilter: number | null | undefined, trpPlanmondayFilter: number | null | undefined, trpPlanTuesdayFilter: number | null | undefined, trpPlanWensdayFilter: number | null | undefined, trpPlanthursdayFilter: number | null | undefined, trpPlanfridayFilter: number | null | undefined, trpPlansaturdayFilter: number | null | undefined, trpPlansundayFilter: number | null | undefined, maxTrpPlanStart_dateFilter: moment.Moment | null | undefined, minTrpPlanStart_dateFilter: moment.Moment | null | undefined, maxTrpPlanEnd_dateFilter: moment.Moment | null | undefined, minTrpPlanEnd_dateFilter: moment.Moment | null | undefined, maxTrpPlanTaskNoFilter: number | null | undefined, minTrpPlanTaskNoFilter: number | null | undefined, maxTripPlanedIDFilter: number | null | undefined, minTripPlanedIDFilter: number | null | undefined, maxDriverIDPPlanedFilter: number | null | undefined, minDriverIDPPlanedFilter: number | null | undefined, maxBUSIDPlanlnedFilter: number | null | undefined, minBUSIDPlanlnedFilter: number | null | undefined, trpPlanISValidFilter: number | null | undefined, trpPlanEndTimeFilter: string | null | undefined, maxTrpPlanRouteIDFilter: number | null | undefined, minTrpPlanRouteIDFilter: number | null | undefined, maxWorkingdayFilter: moment.Moment | null | undefined, minWorkingdayFilter: moment.Moment | null | undefined, maxAutranFilter: number | null | undefined, minAutranFilter: number | null | undefined, startLocationNameFilter: string | null | undefined, startLocationNameHebFilter: string | null | undefined, maxStartLocationCodeFilter: number | null | undefined, minStartLocationCodeFilter: number | null | undefined, maxStartLocationLatitudeFilter: number | null | undefined, minStartLocationLatitudeFilter: number | null | undefined, maxStartLocationLongitudeFilter: number | null | undefined, minStartLocationLongitudeFilter: number | null | undefined, maxRouteTotalKMFilter: number | null | undefined, minRouteTotalKMFilter: number | null | undefined, maxRouteTotalMinutesFilter: number | null | undefined, minRouteTotalMinutesFilter: number | null | undefined, isMinistryFilter: string | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, routeIDGTFSFilter: string | null | undefined, controlStartTimeFilter: string | null | undefined, tripTypesNameFilter: string | null | undefined, busGroupFilter: string | null | undefined, maxDriverOrginalFilter: number | null | undefined, minDriverOrginalFilter: number | null | undefined, maxBusOrginalFilter: number | null | undefined, minBusOrginalFilter: number | null | undefined, endLocationNameFilter: string | null | undefined, endLocationNameHebrewFilter: string | null | undefined, maxEndStationCodeFilter: number | null | undefined, minEndStationCodeFilter: number | null | undefined, maxEndLatitudeFilter: number | null | undefined, minEndLatitudeFilter: number | null | undefined, maxEndLongitudeFilter: number | null | undefined, minEndLongitudeFilter: number | null | undefined, maxTripPlannedWothDriverIDFilter: number | null | undefined, minTripPlannedWothDriverIDFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetViwTripPlanedDailyForView> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetAllWithBuilWorkingDate?";
        if (workingdate !== undefined)
            url_ += "Workingdate=" + encodeURIComponent(workingdate ? "" + workingdate.toJSON() : "") + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tripIDGTFSFilter !== undefined)
            url_ += "TripIDGTFSFilter=" + encodeURIComponent("" + tripIDGTFSFilter) + "&"; 
        if (trpPlanBusNumberFilter !== undefined)
            url_ += "TrpPlanBusNumberFilter=" + encodeURIComponent("" + trpPlanBusNumberFilter) + "&"; 
        if (maxTrpPlanCalnderIDFilter !== undefined)
            url_ += "MaxTrpPlanCalnderIDFilter=" + encodeURIComponent("" + maxTrpPlanCalnderIDFilter) + "&"; 
        if (minTrpPlanCalnderIDFilter !== undefined)
            url_ += "MinTrpPlanCalnderIDFilter=" + encodeURIComponent("" + minTrpPlanCalnderIDFilter) + "&"; 
        if (trpPlanStartTimeFilter !== undefined)
            url_ += "TrpPlanStartTimeFilter=" + encodeURIComponent("" + trpPlanStartTimeFilter) + "&"; 
        if (maxTrpPlanLineNumberFilter !== undefined)
            url_ += "MaxTrpPlanLineNumberFilter=" + encodeURIComponent("" + maxTrpPlanLineNumberFilter) + "&"; 
        if (minTrpPlanLineNumberFilter !== undefined)
            url_ += "MinTrpPlanLineNumberFilter=" + encodeURIComponent("" + minTrpPlanLineNumberFilter) + "&"; 
        if (maxTrpPlanDirectionFilter !== undefined)
            url_ += "MaxTrpPlanDirectionFilter=" + encodeURIComponent("" + maxTrpPlanDirectionFilter) + "&"; 
        if (minTrpPlanDirectionFilter !== undefined)
            url_ += "MinTrpPlanDirectionFilter=" + encodeURIComponent("" + minTrpPlanDirectionFilter) + "&"; 
        if (trpPlanDriverNameFilter !== undefined)
            url_ += "TrpPlanDriverNameFilter=" + encodeURIComponent("" + trpPlanDriverNameFilter) + "&"; 
        if (maxTripMinistryIDFilter !== undefined)
            url_ += "MaxTripMinistryIDFilter=" + encodeURIComponent("" + maxTripMinistryIDFilter) + "&"; 
        if (minTripMinistryIDFilter !== undefined)
            url_ += "MinTripMinistryIDFilter=" + encodeURIComponent("" + minTripMinistryIDFilter) + "&"; 
        if (maxTripMinistryLineNumberFilter !== undefined)
            url_ += "MaxTripMinistryLineNumberFilter=" + encodeURIComponent("" + maxTripMinistryLineNumberFilter) + "&"; 
        if (minTripMinistryLineNumberFilter !== undefined)
            url_ += "MinTripMinistryLineNumberFilter=" + encodeURIComponent("" + minTripMinistryLineNumberFilter) + "&"; 
        if (maxTripMinistryDirectionFilter !== undefined)
            url_ += "MaxTripMinistryDirectionFilter=" + encodeURIComponent("" + maxTripMinistryDirectionFilter) + "&"; 
        if (minTripMinistryDirectionFilter !== undefined)
            url_ += "MinTripMinistryDirectionFilter=" + encodeURIComponent("" + minTripMinistryDirectionFilter) + "&"; 
        if (maxTripMinistryCalenderIDFilter !== undefined)
            url_ += "MaxTripMinistryCalenderIDFilter=" + encodeURIComponent("" + maxTripMinistryCalenderIDFilter) + "&"; 
        if (minTripMinistryCalenderIDFilter !== undefined)
            url_ += "MinTripMinistryCalenderIDFilter=" + encodeURIComponent("" + minTripMinistryCalenderIDFilter) + "&"; 
        if (tripMinistryTimeSpanFilter !== undefined)
            url_ += "TripMinistryTimeSpanFilter=" + encodeURIComponent("" + tripMinistryTimeSpanFilter) + "&"; 
        if (tripMinistryMondayFilter !== undefined)
            url_ += "TripMinistryMondayFilter=" + encodeURIComponent("" + tripMinistryMondayFilter) + "&"; 
        if (tripMinistryTuesdayFilter !== undefined)
            url_ += "TripMinistryTuesdayFilter=" + encodeURIComponent("" + tripMinistryTuesdayFilter) + "&"; 
        if (tripMinistryWensdayFilter !== undefined)
            url_ += "TripMinistryWensdayFilter=" + encodeURIComponent("" + tripMinistryWensdayFilter) + "&"; 
        if (tripMinistryFridayFilter !== undefined)
            url_ += "TripMinistryFridayFilter=" + encodeURIComponent("" + tripMinistryFridayFilter) + "&"; 
        if (tripMinistryThursdayFilter !== undefined)
            url_ += "TripMinistryThursdayFilter=" + encodeURIComponent("" + tripMinistryThursdayFilter) + "&"; 
        if (tripMinistrySaturdayFilter !== undefined)
            url_ += "TripMinistrySaturdayFilter=" + encodeURIComponent("" + tripMinistrySaturdayFilter) + "&"; 
        if (tripMinistrySundayFilter !== undefined)
            url_ += "TripMinistrySundayFilter=" + encodeURIComponent("" + tripMinistrySundayFilter) + "&"; 
        if (maxTripMinistryStart_dateFilter !== undefined)
            url_ += "MaxTripMinistryStart_dateFilter=" + encodeURIComponent(maxTripMinistryStart_dateFilter ? "" + maxTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (minTripMinistryStart_dateFilter !== undefined)
            url_ += "MinTripMinistryStart_dateFilter=" + encodeURIComponent(minTripMinistryStart_dateFilter ? "" + minTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTripMinistryRouteIDFilter !== undefined)
            url_ += "MaxTripMinistryRouteIDFilter=" + encodeURIComponent("" + maxTripMinistryRouteIDFilter) + "&"; 
        if (minTripMinistryRouteIDFilter !== undefined)
            url_ += "MinTripMinistryRouteIDFilter=" + encodeURIComponent("" + minTripMinistryRouteIDFilter) + "&"; 
        if (trpPlanmondayFilter !== undefined)
            url_ += "TrpPlanmondayFilter=" + encodeURIComponent("" + trpPlanmondayFilter) + "&"; 
        if (trpPlanTuesdayFilter !== undefined)
            url_ += "TrpPlanTuesdayFilter=" + encodeURIComponent("" + trpPlanTuesdayFilter) + "&"; 
        if (trpPlanWensdayFilter !== undefined)
            url_ += "TrpPlanWensdayFilter=" + encodeURIComponent("" + trpPlanWensdayFilter) + "&"; 
        if (trpPlanthursdayFilter !== undefined)
            url_ += "TrpPlanthursdayFilter=" + encodeURIComponent("" + trpPlanthursdayFilter) + "&"; 
        if (trpPlanfridayFilter !== undefined)
            url_ += "TrpPlanfridayFilter=" + encodeURIComponent("" + trpPlanfridayFilter) + "&"; 
        if (trpPlansaturdayFilter !== undefined)
            url_ += "TrpPlansaturdayFilter=" + encodeURIComponent("" + trpPlansaturdayFilter) + "&"; 
        if (trpPlansundayFilter !== undefined)
            url_ += "TrpPlansundayFilter=" + encodeURIComponent("" + trpPlansundayFilter) + "&"; 
        if (maxTrpPlanStart_dateFilter !== undefined)
            url_ += "MaxTrpPlanStart_dateFilter=" + encodeURIComponent(maxTrpPlanStart_dateFilter ? "" + maxTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanStart_dateFilter !== undefined)
            url_ += "MinTrpPlanStart_dateFilter=" + encodeURIComponent(minTrpPlanStart_dateFilter ? "" + minTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanEnd_dateFilter !== undefined)
            url_ += "MaxTrpPlanEnd_dateFilter=" + encodeURIComponent(maxTrpPlanEnd_dateFilter ? "" + maxTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanEnd_dateFilter !== undefined)
            url_ += "MinTrpPlanEnd_dateFilter=" + encodeURIComponent(minTrpPlanEnd_dateFilter ? "" + minTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanTaskNoFilter !== undefined)
            url_ += "MaxTrpPlanTaskNoFilter=" + encodeURIComponent("" + maxTrpPlanTaskNoFilter) + "&"; 
        if (minTrpPlanTaskNoFilter !== undefined)
            url_ += "MinTrpPlanTaskNoFilter=" + encodeURIComponent("" + minTrpPlanTaskNoFilter) + "&"; 
        if (maxTripPlanedIDFilter !== undefined)
            url_ += "MaxTripPlanedIDFilter=" + encodeURIComponent("" + maxTripPlanedIDFilter) + "&"; 
        if (minTripPlanedIDFilter !== undefined)
            url_ += "MinTripPlanedIDFilter=" + encodeURIComponent("" + minTripPlanedIDFilter) + "&"; 
        if (maxDriverIDPPlanedFilter !== undefined)
            url_ += "MaxDriverIDPPlanedFilter=" + encodeURIComponent("" + maxDriverIDPPlanedFilter) + "&"; 
        if (minDriverIDPPlanedFilter !== undefined)
            url_ += "MinDriverIDPPlanedFilter=" + encodeURIComponent("" + minDriverIDPPlanedFilter) + "&"; 
        if (maxBUSIDPlanlnedFilter !== undefined)
            url_ += "MaxBUSIDPlanlnedFilter=" + encodeURIComponent("" + maxBUSIDPlanlnedFilter) + "&"; 
        if (minBUSIDPlanlnedFilter !== undefined)
            url_ += "MinBUSIDPlanlnedFilter=" + encodeURIComponent("" + minBUSIDPlanlnedFilter) + "&"; 
        if (trpPlanISValidFilter !== undefined)
            url_ += "TrpPlanISValidFilter=" + encodeURIComponent("" + trpPlanISValidFilter) + "&"; 
        if (trpPlanEndTimeFilter !== undefined)
            url_ += "TrpPlanEndTimeFilter=" + encodeURIComponent("" + trpPlanEndTimeFilter) + "&"; 
        if (maxTrpPlanRouteIDFilter !== undefined)
            url_ += "MaxTrpPlanRouteIDFilter=" + encodeURIComponent("" + maxTrpPlanRouteIDFilter) + "&"; 
        if (minTrpPlanRouteIDFilter !== undefined)
            url_ += "MinTrpPlanRouteIDFilter=" + encodeURIComponent("" + minTrpPlanRouteIDFilter) + "&"; 
        if (maxWorkingdayFilter !== undefined)
            url_ += "MaxWorkingdayFilter=" + encodeURIComponent(maxWorkingdayFilter ? "" + maxWorkingdayFilter.toJSON() : "") + "&"; 
        if (minWorkingdayFilter !== undefined)
            url_ += "MinWorkingdayFilter=" + encodeURIComponent(minWorkingdayFilter ? "" + minWorkingdayFilter.toJSON() : "") + "&"; 
        if (maxAutranFilter !== undefined)
            url_ += "MaxAutranFilter=" + encodeURIComponent("" + maxAutranFilter) + "&"; 
        if (minAutranFilter !== undefined)
            url_ += "MinAutranFilter=" + encodeURIComponent("" + minAutranFilter) + "&"; 
        if (startLocationNameFilter !== undefined)
            url_ += "StartLocationNameFilter=" + encodeURIComponent("" + startLocationNameFilter) + "&"; 
        if (startLocationNameHebFilter !== undefined)
            url_ += "StartLocationNameHebFilter=" + encodeURIComponent("" + startLocationNameHebFilter) + "&"; 
        if (maxStartLocationCodeFilter !== undefined)
            url_ += "MaxStartLocationCodeFilter=" + encodeURIComponent("" + maxStartLocationCodeFilter) + "&"; 
        if (minStartLocationCodeFilter !== undefined)
            url_ += "MinStartLocationCodeFilter=" + encodeURIComponent("" + minStartLocationCodeFilter) + "&"; 
        if (maxStartLocationLatitudeFilter !== undefined)
            url_ += "MaxStartLocationLatitudeFilter=" + encodeURIComponent("" + maxStartLocationLatitudeFilter) + "&"; 
        if (minStartLocationLatitudeFilter !== undefined)
            url_ += "MinStartLocationLatitudeFilter=" + encodeURIComponent("" + minStartLocationLatitudeFilter) + "&"; 
        if (maxStartLocationLongitudeFilter !== undefined)
            url_ += "MaxStartLocationLongitudeFilter=" + encodeURIComponent("" + maxStartLocationLongitudeFilter) + "&"; 
        if (minStartLocationLongitudeFilter !== undefined)
            url_ += "MinStartLocationLongitudeFilter=" + encodeURIComponent("" + minStartLocationLongitudeFilter) + "&"; 
        if (maxRouteTotalKMFilter !== undefined)
            url_ += "MaxRouteTotalKMFilter=" + encodeURIComponent("" + maxRouteTotalKMFilter) + "&"; 
        if (minRouteTotalKMFilter !== undefined)
            url_ += "MinRouteTotalKMFilter=" + encodeURIComponent("" + minRouteTotalKMFilter) + "&"; 
        if (maxRouteTotalMinutesFilter !== undefined)
            url_ += "MaxRouteTotalMinutesFilter=" + encodeURIComponent("" + maxRouteTotalMinutesFilter) + "&"; 
        if (minRouteTotalMinutesFilter !== undefined)
            url_ += "MinRouteTotalMinutesFilter=" + encodeURIComponent("" + minRouteTotalMinutesFilter) + "&"; 
        if (isMinistryFilter !== undefined)
            url_ += "IsMinistryFilter=" + encodeURIComponent("" + isMinistryFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (routeIDGTFSFilter !== undefined)
            url_ += "RouteIDGTFSFilter=" + encodeURIComponent("" + routeIDGTFSFilter) + "&"; 
        if (controlStartTimeFilter !== undefined)
            url_ += "ControlStartTimeFilter=" + encodeURIComponent("" + controlStartTimeFilter) + "&"; 
        if (tripTypesNameFilter !== undefined)
            url_ += "TripTypesNameFilter=" + encodeURIComponent("" + tripTypesNameFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        if (maxDriverOrginalFilter !== undefined)
            url_ += "MaxDriverOrginalFilter=" + encodeURIComponent("" + maxDriverOrginalFilter) + "&"; 
        if (minDriverOrginalFilter !== undefined)
            url_ += "MinDriverOrginalFilter=" + encodeURIComponent("" + minDriverOrginalFilter) + "&"; 
        if (maxBusOrginalFilter !== undefined)
            url_ += "MaxBusOrginalFilter=" + encodeURIComponent("" + maxBusOrginalFilter) + "&"; 
        if (minBusOrginalFilter !== undefined)
            url_ += "MinBusOrginalFilter=" + encodeURIComponent("" + minBusOrginalFilter) + "&"; 
        if (endLocationNameFilter !== undefined)
            url_ += "EndLocationNameFilter=" + encodeURIComponent("" + endLocationNameFilter) + "&"; 
        if (endLocationNameHebrewFilter !== undefined)
            url_ += "EndLocationNameHebrewFilter=" + encodeURIComponent("" + endLocationNameHebrewFilter) + "&"; 
        if (maxEndStationCodeFilter !== undefined)
            url_ += "MaxEndStationCodeFilter=" + encodeURIComponent("" + maxEndStationCodeFilter) + "&"; 
        if (minEndStationCodeFilter !== undefined)
            url_ += "MinEndStationCodeFilter=" + encodeURIComponent("" + minEndStationCodeFilter) + "&"; 
        if (maxEndLatitudeFilter !== undefined)
            url_ += "MaxEndLatitudeFilter=" + encodeURIComponent("" + maxEndLatitudeFilter) + "&"; 
        if (minEndLatitudeFilter !== undefined)
            url_ += "MinEndLatitudeFilter=" + encodeURIComponent("" + minEndLatitudeFilter) + "&"; 
        if (maxEndLongitudeFilter !== undefined)
            url_ += "MaxEndLongitudeFilter=" + encodeURIComponent("" + maxEndLongitudeFilter) + "&"; 
        if (minEndLongitudeFilter !== undefined)
            url_ += "MinEndLongitudeFilter=" + encodeURIComponent("" + minEndLongitudeFilter) + "&"; 
        if (maxTripPlannedWothDriverIDFilter !== undefined)
            url_ += "MaxTripPlannedWothDriverIDFilter=" + encodeURIComponent("" + maxTripPlannedWothDriverIDFilter) + "&"; 
        if (minTripPlannedWothDriverIDFilter !== undefined)
            url_ += "MinTripPlannedWothDriverIDFilter=" + encodeURIComponent("" + minTripPlannedWothDriverIDFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithBuilWorkingDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithBuilWorkingDate(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetViwTripPlanedDailyForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetViwTripPlanedDailyForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWithBuilWorkingDate(response: HttpResponseBase): Observable<PagedResultDtoOfGetViwTripPlanedDailyForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetViwTripPlanedDailyForView.fromJS(resultData200) : new PagedResultDtoOfGetViwTripPlanedDailyForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetViwTripPlanedDailyForView>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tripIDGTFSFilter (optional) 
     * @param trpPlanBusNumberFilter (optional) 
     * @param maxTrpPlanCalnderIDFilter (optional) 
     * @param minTrpPlanCalnderIDFilter (optional) 
     * @param trpPlanStartTimeFilter (optional) 
     * @param maxTrpPlanLineNumberFilter (optional) 
     * @param minTrpPlanLineNumberFilter (optional) 
     * @param maxTrpPlanDirectionFilter (optional) 
     * @param minTrpPlanDirectionFilter (optional) 
     * @param trpPlanDriverNameFilter (optional) 
     * @param maxTripMinistryIDFilter (optional) 
     * @param minTripMinistryIDFilter (optional) 
     * @param maxTripMinistryLineNumberFilter (optional) 
     * @param minTripMinistryLineNumberFilter (optional) 
     * @param maxTripMinistryDirectionFilter (optional) 
     * @param minTripMinistryDirectionFilter (optional) 
     * @param maxTripMinistryCalenderIDFilter (optional) 
     * @param minTripMinistryCalenderIDFilter (optional) 
     * @param tripMinistryTimeSpanFilter (optional) 
     * @param tripMinistryMondayFilter (optional) 
     * @param tripMinistryTuesdayFilter (optional) 
     * @param tripMinistryWensdayFilter (optional) 
     * @param tripMinistryFridayFilter (optional) 
     * @param tripMinistryThursdayFilter (optional) 
     * @param tripMinistrySaturdayFilter (optional) 
     * @param tripMinistrySundayFilter (optional) 
     * @param maxTripMinistryStart_dateFilter (optional) 
     * @param minTripMinistryStart_dateFilter (optional) 
     * @param maxTripMinistryRouteIDFilter (optional) 
     * @param minTripMinistryRouteIDFilter (optional) 
     * @param trpPlanmondayFilter (optional) 
     * @param trpPlanTuesdayFilter (optional) 
     * @param trpPlanWensdayFilter (optional) 
     * @param trpPlanthursdayFilter (optional) 
     * @param trpPlanfridayFilter (optional) 
     * @param trpPlansaturdayFilter (optional) 
     * @param trpPlansundayFilter (optional) 
     * @param maxTrpPlanStart_dateFilter (optional) 
     * @param minTrpPlanStart_dateFilter (optional) 
     * @param maxTrpPlanEnd_dateFilter (optional) 
     * @param minTrpPlanEnd_dateFilter (optional) 
     * @param maxTrpPlanTaskNoFilter (optional) 
     * @param minTrpPlanTaskNoFilter (optional) 
     * @param maxTripPlanedIDFilter (optional) 
     * @param minTripPlanedIDFilter (optional) 
     * @param maxDriverIDPPlanedFilter (optional) 
     * @param minDriverIDPPlanedFilter (optional) 
     * @param maxBUSIDPlanlnedFilter (optional) 
     * @param minBUSIDPlanlnedFilter (optional) 
     * @param trpPlanISValidFilter (optional) 
     * @param trpPlanEndTimeFilter (optional) 
     * @param maxTrpPlanRouteIDFilter (optional) 
     * @param minTrpPlanRouteIDFilter (optional) 
     * @param maxWorkingdayFilter (optional) 
     * @param minWorkingdayFilter (optional) 
     * @param maxAutranFilter (optional) 
     * @param minAutranFilter (optional) 
     * @param startLocationNameFilter (optional) 
     * @param startLocationNameHebFilter (optional) 
     * @param maxStartLocationCodeFilter (optional) 
     * @param minStartLocationCodeFilter (optional) 
     * @param maxStartLocationLatitudeFilter (optional) 
     * @param minStartLocationLatitudeFilter (optional) 
     * @param maxStartLocationLongitudeFilter (optional) 
     * @param minStartLocationLongitudeFilter (optional) 
     * @param maxRouteTotalKMFilter (optional) 
     * @param minRouteTotalKMFilter (optional) 
     * @param maxRouteTotalMinutesFilter (optional) 
     * @param minRouteTotalMinutesFilter (optional) 
     * @param isMinistryFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param routeIDGTFSFilter (optional) 
     * @param controlStartTimeFilter (optional) 
     * @param tripTypesNameFilter (optional) 
     * @param busGroupFilter (optional) 
     * @param maxDriverOrginalFilter (optional) 
     * @param minDriverOrginalFilter (optional) 
     * @param maxBusOrginalFilter (optional) 
     * @param minBusOrginalFilter (optional) 
     * @param endLocationNameFilter (optional) 
     * @param endLocationNameHebrewFilter (optional) 
     * @param maxEndStationCodeFilter (optional) 
     * @param minEndStationCodeFilter (optional) 
     * @param maxEndLatitudeFilter (optional) 
     * @param minEndLatitudeFilter (optional) 
     * @param maxEndLongitudeFilter (optional) 
     * @param minEndLongitudeFilter (optional) 
     * @param maxTripPlannedWothDriverIDFilter (optional) 
     * @param minTripPlannedWothDriverIDFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, tripIDGTFSFilter: string | null | undefined, trpPlanBusNumberFilter: string | null | undefined, maxTrpPlanCalnderIDFilter: number | null | undefined, minTrpPlanCalnderIDFilter: number | null | undefined, trpPlanStartTimeFilter: string | null | undefined, maxTrpPlanLineNumberFilter: number | null | undefined, minTrpPlanLineNumberFilter: number | null | undefined, maxTrpPlanDirectionFilter: number | null | undefined, minTrpPlanDirectionFilter: number | null | undefined, trpPlanDriverNameFilter: string | null | undefined, maxTripMinistryIDFilter: number | null | undefined, minTripMinistryIDFilter: number | null | undefined, maxTripMinistryLineNumberFilter: number | null | undefined, minTripMinistryLineNumberFilter: number | null | undefined, maxTripMinistryDirectionFilter: number | null | undefined, minTripMinistryDirectionFilter: number | null | undefined, maxTripMinistryCalenderIDFilter: number | null | undefined, minTripMinistryCalenderIDFilter: number | null | undefined, tripMinistryTimeSpanFilter: string | null | undefined, tripMinistryMondayFilter: number | null | undefined, tripMinistryTuesdayFilter: number | null | undefined, tripMinistryWensdayFilter: number | null | undefined, tripMinistryFridayFilter: number | null | undefined, tripMinistryThursdayFilter: number | null | undefined, tripMinistrySaturdayFilter: number | null | undefined, tripMinistrySundayFilter: number | null | undefined, maxTripMinistryStart_dateFilter: moment.Moment | null | undefined, minTripMinistryStart_dateFilter: moment.Moment | null | undefined, maxTripMinistryRouteIDFilter: number | null | undefined, minTripMinistryRouteIDFilter: number | null | undefined, trpPlanmondayFilter: number | null | undefined, trpPlanTuesdayFilter: number | null | undefined, trpPlanWensdayFilter: number | null | undefined, trpPlanthursdayFilter: number | null | undefined, trpPlanfridayFilter: number | null | undefined, trpPlansaturdayFilter: number | null | undefined, trpPlansundayFilter: number | null | undefined, maxTrpPlanStart_dateFilter: moment.Moment | null | undefined, minTrpPlanStart_dateFilter: moment.Moment | null | undefined, maxTrpPlanEnd_dateFilter: moment.Moment | null | undefined, minTrpPlanEnd_dateFilter: moment.Moment | null | undefined, maxTrpPlanTaskNoFilter: number | null | undefined, minTrpPlanTaskNoFilter: number | null | undefined, maxTripPlanedIDFilter: number | null | undefined, minTripPlanedIDFilter: number | null | undefined, maxDriverIDPPlanedFilter: number | null | undefined, minDriverIDPPlanedFilter: number | null | undefined, maxBUSIDPlanlnedFilter: number | null | undefined, minBUSIDPlanlnedFilter: number | null | undefined, trpPlanISValidFilter: number | null | undefined, trpPlanEndTimeFilter: string | null | undefined, maxTrpPlanRouteIDFilter: number | null | undefined, minTrpPlanRouteIDFilter: number | null | undefined, maxWorkingdayFilter: moment.Moment | null | undefined, minWorkingdayFilter: moment.Moment | null | undefined, maxAutranFilter: number | null | undefined, minAutranFilter: number | null | undefined, startLocationNameFilter: string | null | undefined, startLocationNameHebFilter: string | null | undefined, maxStartLocationCodeFilter: number | null | undefined, minStartLocationCodeFilter: number | null | undefined, maxStartLocationLatitudeFilter: number | null | undefined, minStartLocationLatitudeFilter: number | null | undefined, maxStartLocationLongitudeFilter: number | null | undefined, minStartLocationLongitudeFilter: number | null | undefined, maxRouteTotalKMFilter: number | null | undefined, minRouteTotalKMFilter: number | null | undefined, maxRouteTotalMinutesFilter: number | null | undefined, minRouteTotalMinutesFilter: number | null | undefined, isMinistryFilter: string | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, routeIDGTFSFilter: string | null | undefined, controlStartTimeFilter: string | null | undefined, tripTypesNameFilter: string | null | undefined, busGroupFilter: string | null | undefined, maxDriverOrginalFilter: number | null | undefined, minDriverOrginalFilter: number | null | undefined, maxBusOrginalFilter: number | null | undefined, minBusOrginalFilter: number | null | undefined, endLocationNameFilter: string | null | undefined, endLocationNameHebrewFilter: string | null | undefined, maxEndStationCodeFilter: number | null | undefined, minEndStationCodeFilter: number | null | undefined, maxEndLatitudeFilter: number | null | undefined, minEndLatitudeFilter: number | null | undefined, maxEndLongitudeFilter: number | null | undefined, minEndLongitudeFilter: number | null | undefined, maxTripPlannedWothDriverIDFilter: number | null | undefined, minTripPlannedWothDriverIDFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetViwTripPlanedDailyForView> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tripIDGTFSFilter !== undefined)
            url_ += "TripIDGTFSFilter=" + encodeURIComponent("" + tripIDGTFSFilter) + "&"; 
        if (trpPlanBusNumberFilter !== undefined)
            url_ += "TrpPlanBusNumberFilter=" + encodeURIComponent("" + trpPlanBusNumberFilter) + "&"; 
        if (maxTrpPlanCalnderIDFilter !== undefined)
            url_ += "MaxTrpPlanCalnderIDFilter=" + encodeURIComponent("" + maxTrpPlanCalnderIDFilter) + "&"; 
        if (minTrpPlanCalnderIDFilter !== undefined)
            url_ += "MinTrpPlanCalnderIDFilter=" + encodeURIComponent("" + minTrpPlanCalnderIDFilter) + "&"; 
        if (trpPlanStartTimeFilter !== undefined)
            url_ += "TrpPlanStartTimeFilter=" + encodeURIComponent("" + trpPlanStartTimeFilter) + "&"; 
        if (maxTrpPlanLineNumberFilter !== undefined)
            url_ += "MaxTrpPlanLineNumberFilter=" + encodeURIComponent("" + maxTrpPlanLineNumberFilter) + "&"; 
        if (minTrpPlanLineNumberFilter !== undefined)
            url_ += "MinTrpPlanLineNumberFilter=" + encodeURIComponent("" + minTrpPlanLineNumberFilter) + "&"; 
        if (maxTrpPlanDirectionFilter !== undefined)
            url_ += "MaxTrpPlanDirectionFilter=" + encodeURIComponent("" + maxTrpPlanDirectionFilter) + "&"; 
        if (minTrpPlanDirectionFilter !== undefined)
            url_ += "MinTrpPlanDirectionFilter=" + encodeURIComponent("" + minTrpPlanDirectionFilter) + "&"; 
        if (trpPlanDriverNameFilter !== undefined)
            url_ += "TrpPlanDriverNameFilter=" + encodeURIComponent("" + trpPlanDriverNameFilter) + "&"; 
        if (maxTripMinistryIDFilter !== undefined)
            url_ += "MaxTripMinistryIDFilter=" + encodeURIComponent("" + maxTripMinistryIDFilter) + "&"; 
        if (minTripMinistryIDFilter !== undefined)
            url_ += "MinTripMinistryIDFilter=" + encodeURIComponent("" + minTripMinistryIDFilter) + "&"; 
        if (maxTripMinistryLineNumberFilter !== undefined)
            url_ += "MaxTripMinistryLineNumberFilter=" + encodeURIComponent("" + maxTripMinistryLineNumberFilter) + "&"; 
        if (minTripMinistryLineNumberFilter !== undefined)
            url_ += "MinTripMinistryLineNumberFilter=" + encodeURIComponent("" + minTripMinistryLineNumberFilter) + "&"; 
        if (maxTripMinistryDirectionFilter !== undefined)
            url_ += "MaxTripMinistryDirectionFilter=" + encodeURIComponent("" + maxTripMinistryDirectionFilter) + "&"; 
        if (minTripMinistryDirectionFilter !== undefined)
            url_ += "MinTripMinistryDirectionFilter=" + encodeURIComponent("" + minTripMinistryDirectionFilter) + "&"; 
        if (maxTripMinistryCalenderIDFilter !== undefined)
            url_ += "MaxTripMinistryCalenderIDFilter=" + encodeURIComponent("" + maxTripMinistryCalenderIDFilter) + "&"; 
        if (minTripMinistryCalenderIDFilter !== undefined)
            url_ += "MinTripMinistryCalenderIDFilter=" + encodeURIComponent("" + minTripMinistryCalenderIDFilter) + "&"; 
        if (tripMinistryTimeSpanFilter !== undefined)
            url_ += "TripMinistryTimeSpanFilter=" + encodeURIComponent("" + tripMinistryTimeSpanFilter) + "&"; 
        if (tripMinistryMondayFilter !== undefined)
            url_ += "TripMinistryMondayFilter=" + encodeURIComponent("" + tripMinistryMondayFilter) + "&"; 
        if (tripMinistryTuesdayFilter !== undefined)
            url_ += "TripMinistryTuesdayFilter=" + encodeURIComponent("" + tripMinistryTuesdayFilter) + "&"; 
        if (tripMinistryWensdayFilter !== undefined)
            url_ += "TripMinistryWensdayFilter=" + encodeURIComponent("" + tripMinistryWensdayFilter) + "&"; 
        if (tripMinistryFridayFilter !== undefined)
            url_ += "TripMinistryFridayFilter=" + encodeURIComponent("" + tripMinistryFridayFilter) + "&"; 
        if (tripMinistryThursdayFilter !== undefined)
            url_ += "TripMinistryThursdayFilter=" + encodeURIComponent("" + tripMinistryThursdayFilter) + "&"; 
        if (tripMinistrySaturdayFilter !== undefined)
            url_ += "TripMinistrySaturdayFilter=" + encodeURIComponent("" + tripMinistrySaturdayFilter) + "&"; 
        if (tripMinistrySundayFilter !== undefined)
            url_ += "TripMinistrySundayFilter=" + encodeURIComponent("" + tripMinistrySundayFilter) + "&"; 
        if (maxTripMinistryStart_dateFilter !== undefined)
            url_ += "MaxTripMinistryStart_dateFilter=" + encodeURIComponent(maxTripMinistryStart_dateFilter ? "" + maxTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (minTripMinistryStart_dateFilter !== undefined)
            url_ += "MinTripMinistryStart_dateFilter=" + encodeURIComponent(minTripMinistryStart_dateFilter ? "" + minTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTripMinistryRouteIDFilter !== undefined)
            url_ += "MaxTripMinistryRouteIDFilter=" + encodeURIComponent("" + maxTripMinistryRouteIDFilter) + "&"; 
        if (minTripMinistryRouteIDFilter !== undefined)
            url_ += "MinTripMinistryRouteIDFilter=" + encodeURIComponent("" + minTripMinistryRouteIDFilter) + "&"; 
        if (trpPlanmondayFilter !== undefined)
            url_ += "TrpPlanmondayFilter=" + encodeURIComponent("" + trpPlanmondayFilter) + "&"; 
        if (trpPlanTuesdayFilter !== undefined)
            url_ += "TrpPlanTuesdayFilter=" + encodeURIComponent("" + trpPlanTuesdayFilter) + "&"; 
        if (trpPlanWensdayFilter !== undefined)
            url_ += "TrpPlanWensdayFilter=" + encodeURIComponent("" + trpPlanWensdayFilter) + "&"; 
        if (trpPlanthursdayFilter !== undefined)
            url_ += "TrpPlanthursdayFilter=" + encodeURIComponent("" + trpPlanthursdayFilter) + "&"; 
        if (trpPlanfridayFilter !== undefined)
            url_ += "TrpPlanfridayFilter=" + encodeURIComponent("" + trpPlanfridayFilter) + "&"; 
        if (trpPlansaturdayFilter !== undefined)
            url_ += "TrpPlansaturdayFilter=" + encodeURIComponent("" + trpPlansaturdayFilter) + "&"; 
        if (trpPlansundayFilter !== undefined)
            url_ += "TrpPlansundayFilter=" + encodeURIComponent("" + trpPlansundayFilter) + "&"; 
        if (maxTrpPlanStart_dateFilter !== undefined)
            url_ += "MaxTrpPlanStart_dateFilter=" + encodeURIComponent(maxTrpPlanStart_dateFilter ? "" + maxTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanStart_dateFilter !== undefined)
            url_ += "MinTrpPlanStart_dateFilter=" + encodeURIComponent(minTrpPlanStart_dateFilter ? "" + minTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanEnd_dateFilter !== undefined)
            url_ += "MaxTrpPlanEnd_dateFilter=" + encodeURIComponent(maxTrpPlanEnd_dateFilter ? "" + maxTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanEnd_dateFilter !== undefined)
            url_ += "MinTrpPlanEnd_dateFilter=" + encodeURIComponent(minTrpPlanEnd_dateFilter ? "" + minTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanTaskNoFilter !== undefined)
            url_ += "MaxTrpPlanTaskNoFilter=" + encodeURIComponent("" + maxTrpPlanTaskNoFilter) + "&"; 
        if (minTrpPlanTaskNoFilter !== undefined)
            url_ += "MinTrpPlanTaskNoFilter=" + encodeURIComponent("" + minTrpPlanTaskNoFilter) + "&"; 
        if (maxTripPlanedIDFilter !== undefined)
            url_ += "MaxTripPlanedIDFilter=" + encodeURIComponent("" + maxTripPlanedIDFilter) + "&"; 
        if (minTripPlanedIDFilter !== undefined)
            url_ += "MinTripPlanedIDFilter=" + encodeURIComponent("" + minTripPlanedIDFilter) + "&"; 
        if (maxDriverIDPPlanedFilter !== undefined)
            url_ += "MaxDriverIDPPlanedFilter=" + encodeURIComponent("" + maxDriverIDPPlanedFilter) + "&"; 
        if (minDriverIDPPlanedFilter !== undefined)
            url_ += "MinDriverIDPPlanedFilter=" + encodeURIComponent("" + minDriverIDPPlanedFilter) + "&"; 
        if (maxBUSIDPlanlnedFilter !== undefined)
            url_ += "MaxBUSIDPlanlnedFilter=" + encodeURIComponent("" + maxBUSIDPlanlnedFilter) + "&"; 
        if (minBUSIDPlanlnedFilter !== undefined)
            url_ += "MinBUSIDPlanlnedFilter=" + encodeURIComponent("" + minBUSIDPlanlnedFilter) + "&"; 
        if (trpPlanISValidFilter !== undefined)
            url_ += "TrpPlanISValidFilter=" + encodeURIComponent("" + trpPlanISValidFilter) + "&"; 
        if (trpPlanEndTimeFilter !== undefined)
            url_ += "TrpPlanEndTimeFilter=" + encodeURIComponent("" + trpPlanEndTimeFilter) + "&"; 
        if (maxTrpPlanRouteIDFilter !== undefined)
            url_ += "MaxTrpPlanRouteIDFilter=" + encodeURIComponent("" + maxTrpPlanRouteIDFilter) + "&"; 
        if (minTrpPlanRouteIDFilter !== undefined)
            url_ += "MinTrpPlanRouteIDFilter=" + encodeURIComponent("" + minTrpPlanRouteIDFilter) + "&"; 
        if (maxWorkingdayFilter !== undefined)
            url_ += "MaxWorkingdayFilter=" + encodeURIComponent(maxWorkingdayFilter ? "" + maxWorkingdayFilter.toJSON() : "") + "&"; 
        if (minWorkingdayFilter !== undefined)
            url_ += "MinWorkingdayFilter=" + encodeURIComponent(minWorkingdayFilter ? "" + minWorkingdayFilter.toJSON() : "") + "&"; 
        if (maxAutranFilter !== undefined)
            url_ += "MaxAutranFilter=" + encodeURIComponent("" + maxAutranFilter) + "&"; 
        if (minAutranFilter !== undefined)
            url_ += "MinAutranFilter=" + encodeURIComponent("" + minAutranFilter) + "&"; 
        if (startLocationNameFilter !== undefined)
            url_ += "StartLocationNameFilter=" + encodeURIComponent("" + startLocationNameFilter) + "&"; 
        if (startLocationNameHebFilter !== undefined)
            url_ += "StartLocationNameHebFilter=" + encodeURIComponent("" + startLocationNameHebFilter) + "&"; 
        if (maxStartLocationCodeFilter !== undefined)
            url_ += "MaxStartLocationCodeFilter=" + encodeURIComponent("" + maxStartLocationCodeFilter) + "&"; 
        if (minStartLocationCodeFilter !== undefined)
            url_ += "MinStartLocationCodeFilter=" + encodeURIComponent("" + minStartLocationCodeFilter) + "&"; 
        if (maxStartLocationLatitudeFilter !== undefined)
            url_ += "MaxStartLocationLatitudeFilter=" + encodeURIComponent("" + maxStartLocationLatitudeFilter) + "&"; 
        if (minStartLocationLatitudeFilter !== undefined)
            url_ += "MinStartLocationLatitudeFilter=" + encodeURIComponent("" + minStartLocationLatitudeFilter) + "&"; 
        if (maxStartLocationLongitudeFilter !== undefined)
            url_ += "MaxStartLocationLongitudeFilter=" + encodeURIComponent("" + maxStartLocationLongitudeFilter) + "&"; 
        if (minStartLocationLongitudeFilter !== undefined)
            url_ += "MinStartLocationLongitudeFilter=" + encodeURIComponent("" + minStartLocationLongitudeFilter) + "&"; 
        if (maxRouteTotalKMFilter !== undefined)
            url_ += "MaxRouteTotalKMFilter=" + encodeURIComponent("" + maxRouteTotalKMFilter) + "&"; 
        if (minRouteTotalKMFilter !== undefined)
            url_ += "MinRouteTotalKMFilter=" + encodeURIComponent("" + minRouteTotalKMFilter) + "&"; 
        if (maxRouteTotalMinutesFilter !== undefined)
            url_ += "MaxRouteTotalMinutesFilter=" + encodeURIComponent("" + maxRouteTotalMinutesFilter) + "&"; 
        if (minRouteTotalMinutesFilter !== undefined)
            url_ += "MinRouteTotalMinutesFilter=" + encodeURIComponent("" + minRouteTotalMinutesFilter) + "&"; 
        if (isMinistryFilter !== undefined)
            url_ += "IsMinistryFilter=" + encodeURIComponent("" + isMinistryFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (routeIDGTFSFilter !== undefined)
            url_ += "RouteIDGTFSFilter=" + encodeURIComponent("" + routeIDGTFSFilter) + "&"; 
        if (controlStartTimeFilter !== undefined)
            url_ += "ControlStartTimeFilter=" + encodeURIComponent("" + controlStartTimeFilter) + "&"; 
        if (tripTypesNameFilter !== undefined)
            url_ += "TripTypesNameFilter=" + encodeURIComponent("" + tripTypesNameFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        if (maxDriverOrginalFilter !== undefined)
            url_ += "MaxDriverOrginalFilter=" + encodeURIComponent("" + maxDriverOrginalFilter) + "&"; 
        if (minDriverOrginalFilter !== undefined)
            url_ += "MinDriverOrginalFilter=" + encodeURIComponent("" + minDriverOrginalFilter) + "&"; 
        if (maxBusOrginalFilter !== undefined)
            url_ += "MaxBusOrginalFilter=" + encodeURIComponent("" + maxBusOrginalFilter) + "&"; 
        if (minBusOrginalFilter !== undefined)
            url_ += "MinBusOrginalFilter=" + encodeURIComponent("" + minBusOrginalFilter) + "&"; 
        if (endLocationNameFilter !== undefined)
            url_ += "EndLocationNameFilter=" + encodeURIComponent("" + endLocationNameFilter) + "&"; 
        if (endLocationNameHebrewFilter !== undefined)
            url_ += "EndLocationNameHebrewFilter=" + encodeURIComponent("" + endLocationNameHebrewFilter) + "&"; 
        if (maxEndStationCodeFilter !== undefined)
            url_ += "MaxEndStationCodeFilter=" + encodeURIComponent("" + maxEndStationCodeFilter) + "&"; 
        if (minEndStationCodeFilter !== undefined)
            url_ += "MinEndStationCodeFilter=" + encodeURIComponent("" + minEndStationCodeFilter) + "&"; 
        if (maxEndLatitudeFilter !== undefined)
            url_ += "MaxEndLatitudeFilter=" + encodeURIComponent("" + maxEndLatitudeFilter) + "&"; 
        if (minEndLatitudeFilter !== undefined)
            url_ += "MinEndLatitudeFilter=" + encodeURIComponent("" + minEndLatitudeFilter) + "&"; 
        if (maxEndLongitudeFilter !== undefined)
            url_ += "MaxEndLongitudeFilter=" + encodeURIComponent("" + maxEndLongitudeFilter) + "&"; 
        if (minEndLongitudeFilter !== undefined)
            url_ += "MinEndLongitudeFilter=" + encodeURIComponent("" + minEndLongitudeFilter) + "&"; 
        if (maxTripPlannedWothDriverIDFilter !== undefined)
            url_ += "MaxTripPlannedWothDriverIDFilter=" + encodeURIComponent("" + maxTripPlannedWothDriverIDFilter) + "&"; 
        if (minTripPlannedWothDriverIDFilter !== undefined)
            url_ += "MinTripPlannedWothDriverIDFilter=" + encodeURIComponent("" + minTripPlannedWothDriverIDFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetViwTripPlanedDailyForView>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetViwTripPlanedDailyForView>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetViwTripPlanedDailyForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetViwTripPlanedDailyForView.fromJS(resultData200) : new PagedResultDtoOfGetViwTripPlanedDailyForView();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetViwTripPlanedDailyForView>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getViwTripPlanedDailyForEdit(id: number | null | undefined): Observable<GetViwTripPlanedDailyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetViwTripPlanedDailyForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViwTripPlanedDailyForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViwTripPlanedDailyForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetViwTripPlanedDailyForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetViwTripPlanedDailyForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetViwTripPlanedDailyForEdit(response: HttpResponseBase): Observable<GetViwTripPlanedDailyForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetViwTripPlanedDailyForEditOutput.fromJS(resultData200) : new GetViwTripPlanedDailyForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetViwTripPlanedDailyForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditViwTripPlanedDailyDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param tripIDGTFSFilter (optional) 
     * @param trpPlanBusNumberFilter (optional) 
     * @param maxTrpPlanCalnderIDFilter (optional) 
     * @param minTrpPlanCalnderIDFilter (optional) 
     * @param trpPlanStartTimeFilter (optional) 
     * @param maxTrpPlanLineNumberFilter (optional) 
     * @param minTrpPlanLineNumberFilter (optional) 
     * @param maxTrpPlanDirectionFilter (optional) 
     * @param minTrpPlanDirectionFilter (optional) 
     * @param trpPlanDriverNameFilter (optional) 
     * @param maxTripMinistryIDFilter (optional) 
     * @param minTripMinistryIDFilter (optional) 
     * @param maxTripMinistryLineNumberFilter (optional) 
     * @param minTripMinistryLineNumberFilter (optional) 
     * @param maxTripMinistryDirectionFilter (optional) 
     * @param minTripMinistryDirectionFilter (optional) 
     * @param maxTripMinistryCalenderIDFilter (optional) 
     * @param minTripMinistryCalenderIDFilter (optional) 
     * @param tripMinistryTimeSpanFilter (optional) 
     * @param tripMinistryMondayFilter (optional) 
     * @param tripMinistryTuesdayFilter (optional) 
     * @param tripMinistryWensdayFilter (optional) 
     * @param tripMinistryFridayFilter (optional) 
     * @param tripMinistryThursdayFilter (optional) 
     * @param tripMinistrySaturdayFilter (optional) 
     * @param tripMinistrySundayFilter (optional) 
     * @param maxTripMinistryStart_dateFilter (optional) 
     * @param minTripMinistryStart_dateFilter (optional) 
     * @param maxTripMinistryRouteIDFilter (optional) 
     * @param minTripMinistryRouteIDFilter (optional) 
     * @param trpPlanmondayFilter (optional) 
     * @param trpPlanTuesdayFilter (optional) 
     * @param trpPlanWensdayFilter (optional) 
     * @param trpPlanthursdayFilter (optional) 
     * @param trpPlanfridayFilter (optional) 
     * @param trpPlansaturdayFilter (optional) 
     * @param trpPlansundayFilter (optional) 
     * @param maxTrpPlanStart_dateFilter (optional) 
     * @param minTrpPlanStart_dateFilter (optional) 
     * @param maxTrpPlanEnd_dateFilter (optional) 
     * @param minTrpPlanEnd_dateFilter (optional) 
     * @param maxTrpPlanTaskNoFilter (optional) 
     * @param minTrpPlanTaskNoFilter (optional) 
     * @param maxTripPlanedIDFilter (optional) 
     * @param minTripPlanedIDFilter (optional) 
     * @param maxDriverIDPPlanedFilter (optional) 
     * @param minDriverIDPPlanedFilter (optional) 
     * @param maxBUSIDPlanlnedFilter (optional) 
     * @param minBUSIDPlanlnedFilter (optional) 
     * @param trpPlanISValidFilter (optional) 
     * @param trpPlanEndTimeFilter (optional) 
     * @param maxTrpPlanRouteIDFilter (optional) 
     * @param minTrpPlanRouteIDFilter (optional) 
     * @param maxWorkingdayFilter (optional) 
     * @param minWorkingdayFilter (optional) 
     * @param maxAutranFilter (optional) 
     * @param minAutranFilter (optional) 
     * @param startLocationNameFilter (optional) 
     * @param startLocationNameHebFilter (optional) 
     * @param maxStartLocationCodeFilter (optional) 
     * @param minStartLocationCodeFilter (optional) 
     * @param maxStartLocationLatitudeFilter (optional) 
     * @param minStartLocationLatitudeFilter (optional) 
     * @param maxStartLocationLongitudeFilter (optional) 
     * @param minStartLocationLongitudeFilter (optional) 
     * @param maxRouteTotalKMFilter (optional) 
     * @param minRouteTotalKMFilter (optional) 
     * @param maxRouteTotalMinutesFilter (optional) 
     * @param minRouteTotalMinutesFilter (optional) 
     * @param isMinistryFilter (optional) 
     * @param maxBusIDFilter (optional) 
     * @param minBusIDFilter (optional) 
     * @param routeIDGTFSFilter (optional) 
     * @param controlStartTimeFilter (optional) 
     * @param tripTypesNameFilter (optional) 
     * @param busGroupFilter (optional) 
     * @param maxDriverOrginalFilter (optional) 
     * @param minDriverOrginalFilter (optional) 
     * @param maxBusOrginalFilter (optional) 
     * @param minBusOrginalFilter (optional) 
     * @param endLocationNameFilter (optional) 
     * @param endLocationNameHebrewFilter (optional) 
     * @param maxEndStationCodeFilter (optional) 
     * @param minEndStationCodeFilter (optional) 
     * @param maxEndLatitudeFilter (optional) 
     * @param minEndLatitudeFilter (optional) 
     * @param maxEndLongitudeFilter (optional) 
     * @param minEndLongitudeFilter (optional) 
     * @param maxTripPlannedWothDriverIDFilter (optional) 
     * @param minTripPlannedWothDriverIDFilter (optional) 
     * @return Success
     */
    getViwTripPlanedDailyToExcel(filter: string | null | undefined, tripIDGTFSFilter: string | null | undefined, trpPlanBusNumberFilter: string | null | undefined, maxTrpPlanCalnderIDFilter: number | null | undefined, minTrpPlanCalnderIDFilter: number | null | undefined, trpPlanStartTimeFilter: string | null | undefined, maxTrpPlanLineNumberFilter: number | null | undefined, minTrpPlanLineNumberFilter: number | null | undefined, maxTrpPlanDirectionFilter: number | null | undefined, minTrpPlanDirectionFilter: number | null | undefined, trpPlanDriverNameFilter: string | null | undefined, maxTripMinistryIDFilter: number | null | undefined, minTripMinistryIDFilter: number | null | undefined, maxTripMinistryLineNumberFilter: number | null | undefined, minTripMinistryLineNumberFilter: number | null | undefined, maxTripMinistryDirectionFilter: number | null | undefined, minTripMinistryDirectionFilter: number | null | undefined, maxTripMinistryCalenderIDFilter: number | null | undefined, minTripMinistryCalenderIDFilter: number | null | undefined, tripMinistryTimeSpanFilter: string | null | undefined, tripMinistryMondayFilter: number | null | undefined, tripMinistryTuesdayFilter: number | null | undefined, tripMinistryWensdayFilter: number | null | undefined, tripMinistryFridayFilter: number | null | undefined, tripMinistryThursdayFilter: number | null | undefined, tripMinistrySaturdayFilter: number | null | undefined, tripMinistrySundayFilter: number | null | undefined, maxTripMinistryStart_dateFilter: moment.Moment | null | undefined, minTripMinistryStart_dateFilter: moment.Moment | null | undefined, maxTripMinistryRouteIDFilter: number | null | undefined, minTripMinistryRouteIDFilter: number | null | undefined, trpPlanmondayFilter: number | null | undefined, trpPlanTuesdayFilter: number | null | undefined, trpPlanWensdayFilter: number | null | undefined, trpPlanthursdayFilter: number | null | undefined, trpPlanfridayFilter: number | null | undefined, trpPlansaturdayFilter: number | null | undefined, trpPlansundayFilter: number | null | undefined, maxTrpPlanStart_dateFilter: moment.Moment | null | undefined, minTrpPlanStart_dateFilter: moment.Moment | null | undefined, maxTrpPlanEnd_dateFilter: moment.Moment | null | undefined, minTrpPlanEnd_dateFilter: moment.Moment | null | undefined, maxTrpPlanTaskNoFilter: number | null | undefined, minTrpPlanTaskNoFilter: number | null | undefined, maxTripPlanedIDFilter: number | null | undefined, minTripPlanedIDFilter: number | null | undefined, maxDriverIDPPlanedFilter: number | null | undefined, minDriverIDPPlanedFilter: number | null | undefined, maxBUSIDPlanlnedFilter: number | null | undefined, minBUSIDPlanlnedFilter: number | null | undefined, trpPlanISValidFilter: number | null | undefined, trpPlanEndTimeFilter: string | null | undefined, maxTrpPlanRouteIDFilter: number | null | undefined, minTrpPlanRouteIDFilter: number | null | undefined, maxWorkingdayFilter: moment.Moment | null | undefined, minWorkingdayFilter: moment.Moment | null | undefined, maxAutranFilter: number | null | undefined, minAutranFilter: number | null | undefined, startLocationNameFilter: string | null | undefined, startLocationNameHebFilter: string | null | undefined, maxStartLocationCodeFilter: number | null | undefined, minStartLocationCodeFilter: number | null | undefined, maxStartLocationLatitudeFilter: number | null | undefined, minStartLocationLatitudeFilter: number | null | undefined, maxStartLocationLongitudeFilter: number | null | undefined, minStartLocationLongitudeFilter: number | null | undefined, maxRouteTotalKMFilter: number | null | undefined, minRouteTotalKMFilter: number | null | undefined, maxRouteTotalMinutesFilter: number | null | undefined, minRouteTotalMinutesFilter: number | null | undefined, isMinistryFilter: string | null | undefined, maxBusIDFilter: number | null | undefined, minBusIDFilter: number | null | undefined, routeIDGTFSFilter: string | null | undefined, controlStartTimeFilter: string | null | undefined, tripTypesNameFilter: string | null | undefined, busGroupFilter: string | null | undefined, maxDriverOrginalFilter: number | null | undefined, minDriverOrginalFilter: number | null | undefined, maxBusOrginalFilter: number | null | undefined, minBusOrginalFilter: number | null | undefined, endLocationNameFilter: string | null | undefined, endLocationNameHebrewFilter: string | null | undefined, maxEndStationCodeFilter: number | null | undefined, minEndStationCodeFilter: number | null | undefined, maxEndLatitudeFilter: number | null | undefined, minEndLatitudeFilter: number | null | undefined, maxEndLongitudeFilter: number | null | undefined, minEndLongitudeFilter: number | null | undefined, maxTripPlannedWothDriverIDFilter: number | null | undefined, minTripPlannedWothDriverIDFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ViwTripPlanedDaily/GetViwTripPlanedDailyToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (tripIDGTFSFilter !== undefined)
            url_ += "TripIDGTFSFilter=" + encodeURIComponent("" + tripIDGTFSFilter) + "&"; 
        if (trpPlanBusNumberFilter !== undefined)
            url_ += "TrpPlanBusNumberFilter=" + encodeURIComponent("" + trpPlanBusNumberFilter) + "&"; 
        if (maxTrpPlanCalnderIDFilter !== undefined)
            url_ += "MaxTrpPlanCalnderIDFilter=" + encodeURIComponent("" + maxTrpPlanCalnderIDFilter) + "&"; 
        if (minTrpPlanCalnderIDFilter !== undefined)
            url_ += "MinTrpPlanCalnderIDFilter=" + encodeURIComponent("" + minTrpPlanCalnderIDFilter) + "&"; 
        if (trpPlanStartTimeFilter !== undefined)
            url_ += "TrpPlanStartTimeFilter=" + encodeURIComponent("" + trpPlanStartTimeFilter) + "&"; 
        if (maxTrpPlanLineNumberFilter !== undefined)
            url_ += "MaxTrpPlanLineNumberFilter=" + encodeURIComponent("" + maxTrpPlanLineNumberFilter) + "&"; 
        if (minTrpPlanLineNumberFilter !== undefined)
            url_ += "MinTrpPlanLineNumberFilter=" + encodeURIComponent("" + minTrpPlanLineNumberFilter) + "&"; 
        if (maxTrpPlanDirectionFilter !== undefined)
            url_ += "MaxTrpPlanDirectionFilter=" + encodeURIComponent("" + maxTrpPlanDirectionFilter) + "&"; 
        if (minTrpPlanDirectionFilter !== undefined)
            url_ += "MinTrpPlanDirectionFilter=" + encodeURIComponent("" + minTrpPlanDirectionFilter) + "&"; 
        if (trpPlanDriverNameFilter !== undefined)
            url_ += "TrpPlanDriverNameFilter=" + encodeURIComponent("" + trpPlanDriverNameFilter) + "&"; 
        if (maxTripMinistryIDFilter !== undefined)
            url_ += "MaxTripMinistryIDFilter=" + encodeURIComponent("" + maxTripMinistryIDFilter) + "&"; 
        if (minTripMinistryIDFilter !== undefined)
            url_ += "MinTripMinistryIDFilter=" + encodeURIComponent("" + minTripMinistryIDFilter) + "&"; 
        if (maxTripMinistryLineNumberFilter !== undefined)
            url_ += "MaxTripMinistryLineNumberFilter=" + encodeURIComponent("" + maxTripMinistryLineNumberFilter) + "&"; 
        if (minTripMinistryLineNumberFilter !== undefined)
            url_ += "MinTripMinistryLineNumberFilter=" + encodeURIComponent("" + minTripMinistryLineNumberFilter) + "&"; 
        if (maxTripMinistryDirectionFilter !== undefined)
            url_ += "MaxTripMinistryDirectionFilter=" + encodeURIComponent("" + maxTripMinistryDirectionFilter) + "&"; 
        if (minTripMinistryDirectionFilter !== undefined)
            url_ += "MinTripMinistryDirectionFilter=" + encodeURIComponent("" + minTripMinistryDirectionFilter) + "&"; 
        if (maxTripMinistryCalenderIDFilter !== undefined)
            url_ += "MaxTripMinistryCalenderIDFilter=" + encodeURIComponent("" + maxTripMinistryCalenderIDFilter) + "&"; 
        if (minTripMinistryCalenderIDFilter !== undefined)
            url_ += "MinTripMinistryCalenderIDFilter=" + encodeURIComponent("" + minTripMinistryCalenderIDFilter) + "&"; 
        if (tripMinistryTimeSpanFilter !== undefined)
            url_ += "TripMinistryTimeSpanFilter=" + encodeURIComponent("" + tripMinistryTimeSpanFilter) + "&"; 
        if (tripMinistryMondayFilter !== undefined)
            url_ += "TripMinistryMondayFilter=" + encodeURIComponent("" + tripMinistryMondayFilter) + "&"; 
        if (tripMinistryTuesdayFilter !== undefined)
            url_ += "TripMinistryTuesdayFilter=" + encodeURIComponent("" + tripMinistryTuesdayFilter) + "&"; 
        if (tripMinistryWensdayFilter !== undefined)
            url_ += "TripMinistryWensdayFilter=" + encodeURIComponent("" + tripMinistryWensdayFilter) + "&"; 
        if (tripMinistryFridayFilter !== undefined)
            url_ += "TripMinistryFridayFilter=" + encodeURIComponent("" + tripMinistryFridayFilter) + "&"; 
        if (tripMinistryThursdayFilter !== undefined)
            url_ += "TripMinistryThursdayFilter=" + encodeURIComponent("" + tripMinistryThursdayFilter) + "&"; 
        if (tripMinistrySaturdayFilter !== undefined)
            url_ += "TripMinistrySaturdayFilter=" + encodeURIComponent("" + tripMinistrySaturdayFilter) + "&"; 
        if (tripMinistrySundayFilter !== undefined)
            url_ += "TripMinistrySundayFilter=" + encodeURIComponent("" + tripMinistrySundayFilter) + "&"; 
        if (maxTripMinistryStart_dateFilter !== undefined)
            url_ += "MaxTripMinistryStart_dateFilter=" + encodeURIComponent(maxTripMinistryStart_dateFilter ? "" + maxTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (minTripMinistryStart_dateFilter !== undefined)
            url_ += "MinTripMinistryStart_dateFilter=" + encodeURIComponent(minTripMinistryStart_dateFilter ? "" + minTripMinistryStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTripMinistryRouteIDFilter !== undefined)
            url_ += "MaxTripMinistryRouteIDFilter=" + encodeURIComponent("" + maxTripMinistryRouteIDFilter) + "&"; 
        if (minTripMinistryRouteIDFilter !== undefined)
            url_ += "MinTripMinistryRouteIDFilter=" + encodeURIComponent("" + minTripMinistryRouteIDFilter) + "&"; 
        if (trpPlanmondayFilter !== undefined)
            url_ += "TrpPlanmondayFilter=" + encodeURIComponent("" + trpPlanmondayFilter) + "&"; 
        if (trpPlanTuesdayFilter !== undefined)
            url_ += "TrpPlanTuesdayFilter=" + encodeURIComponent("" + trpPlanTuesdayFilter) + "&"; 
        if (trpPlanWensdayFilter !== undefined)
            url_ += "TrpPlanWensdayFilter=" + encodeURIComponent("" + trpPlanWensdayFilter) + "&"; 
        if (trpPlanthursdayFilter !== undefined)
            url_ += "TrpPlanthursdayFilter=" + encodeURIComponent("" + trpPlanthursdayFilter) + "&"; 
        if (trpPlanfridayFilter !== undefined)
            url_ += "TrpPlanfridayFilter=" + encodeURIComponent("" + trpPlanfridayFilter) + "&"; 
        if (trpPlansaturdayFilter !== undefined)
            url_ += "TrpPlansaturdayFilter=" + encodeURIComponent("" + trpPlansaturdayFilter) + "&"; 
        if (trpPlansundayFilter !== undefined)
            url_ += "TrpPlansundayFilter=" + encodeURIComponent("" + trpPlansundayFilter) + "&"; 
        if (maxTrpPlanStart_dateFilter !== undefined)
            url_ += "MaxTrpPlanStart_dateFilter=" + encodeURIComponent(maxTrpPlanStart_dateFilter ? "" + maxTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanStart_dateFilter !== undefined)
            url_ += "MinTrpPlanStart_dateFilter=" + encodeURIComponent(minTrpPlanStart_dateFilter ? "" + minTrpPlanStart_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanEnd_dateFilter !== undefined)
            url_ += "MaxTrpPlanEnd_dateFilter=" + encodeURIComponent(maxTrpPlanEnd_dateFilter ? "" + maxTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (minTrpPlanEnd_dateFilter !== undefined)
            url_ += "MinTrpPlanEnd_dateFilter=" + encodeURIComponent(minTrpPlanEnd_dateFilter ? "" + minTrpPlanEnd_dateFilter.toJSON() : "") + "&"; 
        if (maxTrpPlanTaskNoFilter !== undefined)
            url_ += "MaxTrpPlanTaskNoFilter=" + encodeURIComponent("" + maxTrpPlanTaskNoFilter) + "&"; 
        if (minTrpPlanTaskNoFilter !== undefined)
            url_ += "MinTrpPlanTaskNoFilter=" + encodeURIComponent("" + minTrpPlanTaskNoFilter) + "&"; 
        if (maxTripPlanedIDFilter !== undefined)
            url_ += "MaxTripPlanedIDFilter=" + encodeURIComponent("" + maxTripPlanedIDFilter) + "&"; 
        if (minTripPlanedIDFilter !== undefined)
            url_ += "MinTripPlanedIDFilter=" + encodeURIComponent("" + minTripPlanedIDFilter) + "&"; 
        if (maxDriverIDPPlanedFilter !== undefined)
            url_ += "MaxDriverIDPPlanedFilter=" + encodeURIComponent("" + maxDriverIDPPlanedFilter) + "&"; 
        if (minDriverIDPPlanedFilter !== undefined)
            url_ += "MinDriverIDPPlanedFilter=" + encodeURIComponent("" + minDriverIDPPlanedFilter) + "&"; 
        if (maxBUSIDPlanlnedFilter !== undefined)
            url_ += "MaxBUSIDPlanlnedFilter=" + encodeURIComponent("" + maxBUSIDPlanlnedFilter) + "&"; 
        if (minBUSIDPlanlnedFilter !== undefined)
            url_ += "MinBUSIDPlanlnedFilter=" + encodeURIComponent("" + minBUSIDPlanlnedFilter) + "&"; 
        if (trpPlanISValidFilter !== undefined)
            url_ += "TrpPlanISValidFilter=" + encodeURIComponent("" + trpPlanISValidFilter) + "&"; 
        if (trpPlanEndTimeFilter !== undefined)
            url_ += "TrpPlanEndTimeFilter=" + encodeURIComponent("" + trpPlanEndTimeFilter) + "&"; 
        if (maxTrpPlanRouteIDFilter !== undefined)
            url_ += "MaxTrpPlanRouteIDFilter=" + encodeURIComponent("" + maxTrpPlanRouteIDFilter) + "&"; 
        if (minTrpPlanRouteIDFilter !== undefined)
            url_ += "MinTrpPlanRouteIDFilter=" + encodeURIComponent("" + minTrpPlanRouteIDFilter) + "&"; 
        if (maxWorkingdayFilter !== undefined)
            url_ += "MaxWorkingdayFilter=" + encodeURIComponent(maxWorkingdayFilter ? "" + maxWorkingdayFilter.toJSON() : "") + "&"; 
        if (minWorkingdayFilter !== undefined)
            url_ += "MinWorkingdayFilter=" + encodeURIComponent(minWorkingdayFilter ? "" + minWorkingdayFilter.toJSON() : "") + "&"; 
        if (maxAutranFilter !== undefined)
            url_ += "MaxAutranFilter=" + encodeURIComponent("" + maxAutranFilter) + "&"; 
        if (minAutranFilter !== undefined)
            url_ += "MinAutranFilter=" + encodeURIComponent("" + minAutranFilter) + "&"; 
        if (startLocationNameFilter !== undefined)
            url_ += "StartLocationNameFilter=" + encodeURIComponent("" + startLocationNameFilter) + "&"; 
        if (startLocationNameHebFilter !== undefined)
            url_ += "StartLocationNameHebFilter=" + encodeURIComponent("" + startLocationNameHebFilter) + "&"; 
        if (maxStartLocationCodeFilter !== undefined)
            url_ += "MaxStartLocationCodeFilter=" + encodeURIComponent("" + maxStartLocationCodeFilter) + "&"; 
        if (minStartLocationCodeFilter !== undefined)
            url_ += "MinStartLocationCodeFilter=" + encodeURIComponent("" + minStartLocationCodeFilter) + "&"; 
        if (maxStartLocationLatitudeFilter !== undefined)
            url_ += "MaxStartLocationLatitudeFilter=" + encodeURIComponent("" + maxStartLocationLatitudeFilter) + "&"; 
        if (minStartLocationLatitudeFilter !== undefined)
            url_ += "MinStartLocationLatitudeFilter=" + encodeURIComponent("" + minStartLocationLatitudeFilter) + "&"; 
        if (maxStartLocationLongitudeFilter !== undefined)
            url_ += "MaxStartLocationLongitudeFilter=" + encodeURIComponent("" + maxStartLocationLongitudeFilter) + "&"; 
        if (minStartLocationLongitudeFilter !== undefined)
            url_ += "MinStartLocationLongitudeFilter=" + encodeURIComponent("" + minStartLocationLongitudeFilter) + "&"; 
        if (maxRouteTotalKMFilter !== undefined)
            url_ += "MaxRouteTotalKMFilter=" + encodeURIComponent("" + maxRouteTotalKMFilter) + "&"; 
        if (minRouteTotalKMFilter !== undefined)
            url_ += "MinRouteTotalKMFilter=" + encodeURIComponent("" + minRouteTotalKMFilter) + "&"; 
        if (maxRouteTotalMinutesFilter !== undefined)
            url_ += "MaxRouteTotalMinutesFilter=" + encodeURIComponent("" + maxRouteTotalMinutesFilter) + "&"; 
        if (minRouteTotalMinutesFilter !== undefined)
            url_ += "MinRouteTotalMinutesFilter=" + encodeURIComponent("" + minRouteTotalMinutesFilter) + "&"; 
        if (isMinistryFilter !== undefined)
            url_ += "IsMinistryFilter=" + encodeURIComponent("" + isMinistryFilter) + "&"; 
        if (maxBusIDFilter !== undefined)
            url_ += "MaxBusIDFilter=" + encodeURIComponent("" + maxBusIDFilter) + "&"; 
        if (minBusIDFilter !== undefined)
            url_ += "MinBusIDFilter=" + encodeURIComponent("" + minBusIDFilter) + "&"; 
        if (routeIDGTFSFilter !== undefined)
            url_ += "RouteIDGTFSFilter=" + encodeURIComponent("" + routeIDGTFSFilter) + "&"; 
        if (controlStartTimeFilter !== undefined)
            url_ += "ControlStartTimeFilter=" + encodeURIComponent("" + controlStartTimeFilter) + "&"; 
        if (tripTypesNameFilter !== undefined)
            url_ += "TripTypesNameFilter=" + encodeURIComponent("" + tripTypesNameFilter) + "&"; 
        if (busGroupFilter !== undefined)
            url_ += "BusGroupFilter=" + encodeURIComponent("" + busGroupFilter) + "&"; 
        if (maxDriverOrginalFilter !== undefined)
            url_ += "MaxDriverOrginalFilter=" + encodeURIComponent("" + maxDriverOrginalFilter) + "&"; 
        if (minDriverOrginalFilter !== undefined)
            url_ += "MinDriverOrginalFilter=" + encodeURIComponent("" + minDriverOrginalFilter) + "&"; 
        if (maxBusOrginalFilter !== undefined)
            url_ += "MaxBusOrginalFilter=" + encodeURIComponent("" + maxBusOrginalFilter) + "&"; 
        if (minBusOrginalFilter !== undefined)
            url_ += "MinBusOrginalFilter=" + encodeURIComponent("" + minBusOrginalFilter) + "&"; 
        if (endLocationNameFilter !== undefined)
            url_ += "EndLocationNameFilter=" + encodeURIComponent("" + endLocationNameFilter) + "&"; 
        if (endLocationNameHebrewFilter !== undefined)
            url_ += "EndLocationNameHebrewFilter=" + encodeURIComponent("" + endLocationNameHebrewFilter) + "&"; 
        if (maxEndStationCodeFilter !== undefined)
            url_ += "MaxEndStationCodeFilter=" + encodeURIComponent("" + maxEndStationCodeFilter) + "&"; 
        if (minEndStationCodeFilter !== undefined)
            url_ += "MinEndStationCodeFilter=" + encodeURIComponent("" + minEndStationCodeFilter) + "&"; 
        if (maxEndLatitudeFilter !== undefined)
            url_ += "MaxEndLatitudeFilter=" + encodeURIComponent("" + maxEndLatitudeFilter) + "&"; 
        if (minEndLatitudeFilter !== undefined)
            url_ += "MinEndLatitudeFilter=" + encodeURIComponent("" + minEndLatitudeFilter) + "&"; 
        if (maxEndLongitudeFilter !== undefined)
            url_ += "MaxEndLongitudeFilter=" + encodeURIComponent("" + maxEndLongitudeFilter) + "&"; 
        if (minEndLongitudeFilter !== undefined)
            url_ += "MinEndLongitudeFilter=" + encodeURIComponent("" + minEndLongitudeFilter) + "&"; 
        if (maxTripPlannedWothDriverIDFilter !== undefined)
            url_ += "MaxTripPlannedWothDriverIDFilter=" + encodeURIComponent("" + maxTripPlannedWothDriverIDFilter) + "&"; 
        if (minTripPlannedWothDriverIDFilter !== undefined)
            url_ += "MinTripPlannedWothDriverIDFilter=" + encodeURIComponent("" + minTripPlannedWothDriverIDFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViwTripPlanedDailyToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViwTripPlanedDailyToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetViwTripPlanedDailyToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1, 
    InActive = 2, 
    NotFound = 3, 
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = 0, 
    Updated = 1, 
    Deleted = 2, 
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetBanksForViewDto implements IPagedResultDtoOfGetBanksForViewDto {
    totalCount!: number | undefined;
    items!: GetBanksForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBanksForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBanksForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBanksForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBanksForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBanksForViewDto {
    totalCount: number | undefined;
    items: GetBanksForViewDto[] | undefined;
}

export class GetBanksForViewDto implements IGetBanksForViewDto {
    banks!: BanksDto | undefined;

    constructor(data?: IGetBanksForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.banks = data["banks"] ? BanksDto.fromJS(data["banks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBanksForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBanksForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["banks"] = this.banks ? this.banks.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBanksForViewDto {
    banks: BanksDto | undefined;
}

export class BanksDto implements IBanksDto {
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBanksDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BanksDto {
        data = typeof data === 'object' ? data : {};
        let result = new BanksDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBanksDto {
    description: string | undefined;
    id: number | undefined;
}

export class GetBanksForEditOutput implements IGetBanksForEditOutput {
    banks!: CreateOrEditBanksDto | undefined;

    constructor(data?: IGetBanksForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.banks = data["banks"] ? CreateOrEditBanksDto.fromJS(data["banks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBanksForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBanksForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["banks"] = this.banks ? this.banks.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBanksForEditOutput {
    banks: CreateOrEditBanksDto | undefined;
}

export class CreateOrEditBanksDto implements ICreateOrEditBanksDto {
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBanksDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBanksDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBanksDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBanksDto {
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetBranchesForViewDto implements IPagedResultDtoOfGetBranchesForViewDto {
    totalCount!: number | undefined;
    items!: GetBranchesForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBranchesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBranchesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBranchesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBranchesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBranchesForViewDto {
    totalCount: number | undefined;
    items: GetBranchesForViewDto[] | undefined;
}

export class GetBranchesForViewDto implements IGetBranchesForViewDto {
    branches!: BranchesDto | undefined;

    constructor(data?: IGetBranchesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branches = data["branches"] ? BranchesDto.fromJS(data["branches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBranchesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBranchesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branches"] = this.branches ? this.branches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBranchesForViewDto {
    branches: BranchesDto | undefined;
}

export class BranchesDto implements IBranchesDto {
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBranchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BranchesDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBranchesDto {
    description: string | undefined;
    id: number | undefined;
}

export class GetBranchesForEditOutput implements IGetBranchesForEditOutput {
    branches!: CreateOrEditBranchesDto | undefined;

    constructor(data?: IGetBranchesForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branches = data["branches"] ? CreateOrEditBranchesDto.fromJS(data["branches"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBranchesForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBranchesForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branches"] = this.branches ? this.branches.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBranchesForEditOutput {
    branches: CreateOrEditBranchesDto | undefined;
}

export class CreateOrEditBranchesDto implements ICreateOrEditBranchesDto {
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBranchesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBranchesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBranchesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBranchesDto {
    description: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetBusInfoForView implements IPagedResultDtoOfGetBusInfoForView {
    totalCount!: number | undefined;
    items!: GetBusInfoForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusInfoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBusInfoForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusInfoForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusInfoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBusInfoForView {
    totalCount: number | undefined;
    items: GetBusInfoForView[] | undefined;
}

export class GetBusInfoForView implements IGetBusInfoForView {
    busInfo!: BusInfoDto | undefined;

    constructor(data?: IGetBusInfoForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busInfo = data["busInfo"] ? BusInfoDto.fromJS(data["busInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusInfoForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusInfoForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busInfo"] = this.busInfo ? this.busInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBusInfoForView {
    busInfo: BusInfoDto | undefined;
}

export class BusInfoDto implements IBusInfoDto {
    busNumber!: string | undefined;
    busModel!: string | undefined;
    model!: string | undefined;
    chassisNumber!: string | undefined;
    trackerIEMI!: string | undefined;
    insuPolicyNumber!: moment.Moment | undefined;
    capcity!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBusInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busNumber = data["busNumber"];
            this.busModel = data["busModel"];
            this.model = data["model"];
            this.chassisNumber = data["chassisNumber"];
            this.trackerIEMI = data["trackerIEMI"];
            this.insuPolicyNumber = data["insuPolicyNumber"] ? moment(data["insuPolicyNumber"].toString()) : <any>undefined;
            this.capcity = data["capcity"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BusInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busNumber"] = this.busNumber;
        data["busModel"] = this.busModel;
        data["model"] = this.model;
        data["chassisNumber"] = this.chassisNumber;
        data["trackerIEMI"] = this.trackerIEMI;
        data["insuPolicyNumber"] = this.insuPolicyNumber ? this.insuPolicyNumber.toISOString() : <any>undefined;
        data["capcity"] = this.capcity;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusInfoDto {
    busNumber: string | undefined;
    busModel: string | undefined;
    model: string | undefined;
    chassisNumber: string | undefined;
    trackerIEMI: string | undefined;
    insuPolicyNumber: moment.Moment | undefined;
    capcity: number | undefined;
    id: number | undefined;
}

export class GetBusInfoForEditOutput implements IGetBusInfoForEditOutput {
    busInfo!: CreateOrEditBusInfoDto | undefined;

    constructor(data?: IGetBusInfoForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busInfo = data["busInfo"] ? CreateOrEditBusInfoDto.fromJS(data["busInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusInfoForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusInfoForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busInfo"] = this.busInfo ? this.busInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBusInfoForEditOutput {
    busInfo: CreateOrEditBusInfoDto | undefined;
}

export class CreateOrEditBusInfoDto implements ICreateOrEditBusInfoDto {
    busNumber!: string | undefined;
    busModel!: string | undefined;
    model!: string;
    chassisNumber!: string | undefined;
    trackerIEMI!: string | undefined;
    insuPolicyNumber!: moment.Moment | undefined;
    capcity!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busNumber = data["busNumber"];
            this.busModel = data["busModel"];
            this.model = data["model"];
            this.chassisNumber = data["chassisNumber"];
            this.trackerIEMI = data["trackerIEMI"];
            this.insuPolicyNumber = data["insuPolicyNumber"] ? moment(data["insuPolicyNumber"].toString()) : <any>undefined;
            this.capcity = data["capcity"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busNumber"] = this.busNumber;
        data["busModel"] = this.busModel;
        data["model"] = this.model;
        data["chassisNumber"] = this.chassisNumber;
        data["trackerIEMI"] = this.trackerIEMI;
        data["insuPolicyNumber"] = this.insuPolicyNumber ? this.insuPolicyNumber.toISOString() : <any>undefined;
        data["capcity"] = this.capcity;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBusInfoDto {
    busNumber: string | undefined;
    busModel: string | undefined;
    model: string;
    chassisNumber: string | undefined;
    trackerIEMI: string | undefined;
    insuPolicyNumber: moment.Moment | undefined;
    capcity: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetBusTypesForViewDto implements IPagedResultDtoOfGetBusTypesForViewDto {
    totalCount!: number | undefined;
    items!: GetBusTypesForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBusTypesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBusTypesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBusTypesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBusTypesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBusTypesForViewDto {
    totalCount: number | undefined;
    items: GetBusTypesForViewDto[] | undefined;
}

export class GetBusTypesForViewDto implements IGetBusTypesForViewDto {
    busTypes!: BusTypesDto | undefined;

    constructor(data?: IGetBusTypesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busTypes = data["busTypes"] ? BusTypesDto.fromJS(data["busTypes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusTypesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusTypesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busTypes"] = this.busTypes ? this.busTypes.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBusTypesForViewDto {
    busTypes: BusTypesDto | undefined;
}

export class BusTypesDto implements IBusTypesDto {
    busTypeDesc!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBusTypesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busTypeDesc = data["busTypeDesc"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BusTypesDto {
        data = typeof data === 'object' ? data : {};
        let result = new BusTypesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busTypeDesc"] = this.busTypeDesc;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBusTypesDto {
    busTypeDesc: string | undefined;
    id: number | undefined;
}

export class GetBusTypesForEditOutput implements IGetBusTypesForEditOutput {
    busTypes!: CreateOrEditBusTypesDto | undefined;

    constructor(data?: IGetBusTypesForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busTypes = data["busTypes"] ? CreateOrEditBusTypesDto.fromJS(data["busTypes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBusTypesForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBusTypesForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busTypes"] = this.busTypes ? this.busTypes.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBusTypesForEditOutput {
    busTypes: CreateOrEditBusTypesDto | undefined;
}

export class CreateOrEditBusTypesDto implements ICreateOrEditBusTypesDto {
    busTypeDesc!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBusTypesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.busTypeDesc = data["busTypeDesc"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBusTypesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBusTypesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["busTypeDesc"] = this.busTypeDesc;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBusTypesDto {
    busTypeDesc: string;
    id: number | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class PagedResultDtoOfGetCalenderBusForView implements IPagedResultDtoOfGetCalenderBusForView {
    totalCount!: number | undefined;
    items!: GetCalenderBusForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCalenderBusForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCalenderBusForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCalenderBusForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCalenderBusForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCalenderBusForView {
    totalCount: number | undefined;
    items: GetCalenderBusForView[] | undefined;
}

export class GetCalenderBusForView implements IGetCalenderBusForView {
    calenderBus!: CalenderBusDto | undefined;

    constructor(data?: IGetCalenderBusForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calenderBus = data["calenderBus"] ? CalenderBusDto.fromJS(data["calenderBus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCalenderBusForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetCalenderBusForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calenderBus"] = this.calenderBus ? this.calenderBus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCalenderBusForView {
    calenderBus: CalenderBusDto | undefined;
}

export class CalenderBusDto implements ICalenderBusDto {
    monday!: boolean | undefined;
    tuesday!: boolean | undefined;
    wednesday!: boolean | undefined;
    thursday!: boolean | undefined;
    friday!: boolean | undefined;
    saturday!: boolean | undefined;
    sunday!: boolean | undefined;
    start_date!: moment.Moment | undefined;
    end_date!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICalenderBusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.monday = data["monday"];
            this.tuesday = data["tuesday"];
            this.wednesday = data["wednesday"];
            this.thursday = data["thursday"];
            this.friday = data["friday"];
            this.saturday = data["saturday"];
            this.sunday = data["sunday"];
            this.start_date = data["start_date"] ? moment(data["start_date"].toString()) : <any>undefined;
            this.end_date = data["end_date"] ? moment(data["end_date"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CalenderBusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalenderBusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monday"] = this.monday;
        data["tuesday"] = this.tuesday;
        data["wednesday"] = this.wednesday;
        data["thursday"] = this.thursday;
        data["friday"] = this.friday;
        data["saturday"] = this.saturday;
        data["sunday"] = this.sunday;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICalenderBusDto {
    monday: boolean | undefined;
    tuesday: boolean | undefined;
    wednesday: boolean | undefined;
    thursday: boolean | undefined;
    friday: boolean | undefined;
    saturday: boolean | undefined;
    sunday: boolean | undefined;
    start_date: moment.Moment | undefined;
    end_date: moment.Moment | undefined;
    id: number | undefined;
}

export class GetCalenderBusForEditOutput implements IGetCalenderBusForEditOutput {
    calenderBus!: CreateOrEditCalenderBusDto | undefined;

    constructor(data?: IGetCalenderBusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calenderBus = data["calenderBus"] ? CreateOrEditCalenderBusDto.fromJS(data["calenderBus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCalenderBusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCalenderBusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calenderBus"] = this.calenderBus ? this.calenderBus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCalenderBusForEditOutput {
    calenderBus: CreateOrEditCalenderBusDto | undefined;
}

export class CreateOrEditCalenderBusDto implements ICreateOrEditCalenderBusDto {
    monday!: boolean | undefined;
    tuesday!: boolean | undefined;
    wednesday!: boolean | undefined;
    thursday!: boolean | undefined;
    friday!: boolean | undefined;
    saturday!: boolean | undefined;
    sunday!: boolean | undefined;
    start_date!: moment.Moment | undefined;
    end_date!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCalenderBusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.monday = data["monday"];
            this.tuesday = data["tuesday"];
            this.wednesday = data["wednesday"];
            this.thursday = data["thursday"];
            this.friday = data["friday"];
            this.saturday = data["saturday"];
            this.sunday = data["sunday"];
            this.start_date = data["start_date"] ? moment(data["start_date"].toString()) : <any>undefined;
            this.end_date = data["end_date"] ? moment(data["end_date"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCalenderBusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCalenderBusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monday"] = this.monday;
        data["tuesday"] = this.tuesday;
        data["wednesday"] = this.wednesday;
        data["thursday"] = this.thursday;
        data["friday"] = this.friday;
        data["saturday"] = this.saturday;
        data["sunday"] = this.sunday;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCalenderBusDto {
    monday: boolean | undefined;
    tuesday: boolean | undefined;
    wednesday: boolean | undefined;
    thursday: boolean | undefined;
    friday: boolean | undefined;
    saturday: boolean | undefined;
    sunday: boolean | undefined;
    start_date: moment.Moment | undefined;
    end_date: moment.Moment | undefined;
    id: number | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [] as any;
                for (let item of data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export enum FriendshipState {
    Accepted = 1, 
    Blocked = 2, 
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export enum ChatSide {
    Sender = 1, 
    Receiver = 2, 
}

export enum ChatMessageReadState {
    Unread = 1, 
    Read = 2, 
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class PagedResultDtoOfGetDepartmentForView implements IPagedResultDtoOfGetDepartmentForView {
    totalCount!: number | undefined;
    items!: GetDepartmentForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDepartmentForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetDepartmentForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDepartmentForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDepartmentForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetDepartmentForView {
    totalCount: number | undefined;
    items: GetDepartmentForView[] | undefined;
}

export class GetDepartmentForView implements IGetDepartmentForView {
    department!: DepartmentDto | undefined;

    constructor(data?: IGetDepartmentForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.department = data["department"] ? DepartmentDto.fromJS(data["department"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDepartmentForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetDepartmentForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetDepartmentForView {
    department: DepartmentDto | undefined;
}

export class DepartmentDto implements IDepartmentDto {
    departmentName!: string | undefined;
    departmentEnName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.departmentName = data["departmentName"];
            this.departmentEnName = data["departmentEnName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentName"] = this.departmentName;
        data["departmentEnName"] = this.departmentEnName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDepartmentDto {
    departmentName: string | undefined;
    departmentEnName: string | undefined;
    id: number | undefined;
}

export class GetDepartmentForEditOutput implements IGetDepartmentForEditOutput {
    department!: CreateOrEditDepartmentDto | undefined;

    constructor(data?: IGetDepartmentForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.department = data["department"] ? CreateOrEditDepartmentDto.fromJS(data["department"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDepartmentForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDepartmentForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["department"] = this.department ? this.department.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetDepartmentForEditOutput {
    department: CreateOrEditDepartmentDto | undefined;
}

export class CreateOrEditDepartmentDto implements ICreateOrEditDepartmentDto {
    departmentName!: string | undefined;
    departmentEnName!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.departmentName = data["departmentName"];
            this.departmentEnName = data["departmentEnName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["departmentName"] = this.departmentName;
        data["departmentEnName"] = this.departmentEnName;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditDepartmentDto {
    departmentName: string | undefined;
    departmentEnName: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number | undefined;
    targetEditionId!: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class PagedResultDtoOfGetEmployeesForViewDto implements IPagedResultDtoOfGetEmployeesForViewDto {
    totalCount!: number | undefined;
    items!: GetEmployeesForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEmployeesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEmployeesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEmployeesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEmployeesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEmployeesForViewDto {
    totalCount: number | undefined;
    items: GetEmployeesForViewDto[] | undefined;
}

export class GetEmployeesForViewDto implements IGetEmployeesForViewDto {
    employees!: EmployeesDto | undefined;
    employeeTypeDescription!: string | undefined;
    branchesDescription!: string | undefined;

    constructor(data?: IGetEmployeesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employees = data["employees"] ? EmployeesDto.fromJS(data["employees"]) : <any>undefined;
            this.employeeTypeDescription = data["employeeTypeDescription"];
            this.branchesDescription = data["branchesDescription"];
        }
    }

    static fromJS(data: any): GetEmployeesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employees"] = this.employees ? this.employees.toJSON() : <any>undefined;
        data["employeeTypeDescription"] = this.employeeTypeDescription;
        data["branchesDescription"] = this.branchesDescription;
        return data; 
    }
}

export interface IGetEmployeesForViewDto {
    employees: EmployeesDto | undefined;
    employeeTypeDescription: string | undefined;
    branchesDescription: string | undefined;
}

export class EmployeesDto implements IEmployeesDto {
    userName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    cellular!: string | undefined;
    gender!: string | undefined;
    email!: string | undefined;
    employeeIDNumber!: string | undefined;
    employeeNumber!: string | undefined;
    password!: number | undefined;
    isActive!: boolean | undefined;
    cardNumberTicketing!: number | undefined;
    emailAddress!: string | undefined;
    percentageOfPosition!: number | undefined;
    workStartDate!: moment.Moment | undefined;
    workEndDate!: moment.Moment | undefined;
    dateOfBirth!: moment.Moment | undefined;
    bankAccountNumber!: string | undefined;
    jobTitle!: string | undefined;
    employeeTypeId!: number | undefined;
    branchesId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEmployeesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellular = data["cellular"];
            this.gender = data["gender"];
            this.email = data["email"];
            this.employeeIDNumber = data["employeeIDNumber"];
            this.employeeNumber = data["employeeNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.cardNumberTicketing = data["cardNumberTicketing"];
            this.emailAddress = data["emailAddress"];
            this.percentageOfPosition = data["percentageOfPosition"];
            this.workStartDate = data["workStartDate"] ? moment(data["workStartDate"].toString()) : <any>undefined;
            this.workEndDate = data["workEndDate"] ? moment(data["workEndDate"].toString()) : <any>undefined;
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.bankAccountNumber = data["bankAccountNumber"];
            this.jobTitle = data["jobTitle"];
            this.employeeTypeId = data["employeeTypeId"];
            this.branchesId = data["branchesId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EmployeesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellular"] = this.cellular;
        data["gender"] = this.gender;
        data["email"] = this.email;
        data["employeeIDNumber"] = this.employeeIDNumber;
        data["employeeNumber"] = this.employeeNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["cardNumberTicketing"] = this.cardNumberTicketing;
        data["emailAddress"] = this.emailAddress;
        data["percentageOfPosition"] = this.percentageOfPosition;
        data["workStartDate"] = this.workStartDate ? this.workStartDate.toISOString() : <any>undefined;
        data["workEndDate"] = this.workEndDate ? this.workEndDate.toISOString() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["jobTitle"] = this.jobTitle;
        data["employeeTypeId"] = this.employeeTypeId;
        data["branchesId"] = this.branchesId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEmployeesDto {
    userName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    cellular: string | undefined;
    gender: string | undefined;
    email: string | undefined;
    employeeIDNumber: string | undefined;
    employeeNumber: string | undefined;
    password: number | undefined;
    isActive: boolean | undefined;
    cardNumberTicketing: number | undefined;
    emailAddress: string | undefined;
    percentageOfPosition: number | undefined;
    workStartDate: moment.Moment | undefined;
    workEndDate: moment.Moment | undefined;
    dateOfBirth: moment.Moment | undefined;
    bankAccountNumber: string | undefined;
    jobTitle: string | undefined;
    employeeTypeId: number | undefined;
    branchesId: number | undefined;
    id: number | undefined;
}

export class GetEmployeesForEditOutput implements IGetEmployeesForEditOutput {
    employees!: CreateOrEditEmployeesDto | undefined;
    employeeTypeDescription!: string | undefined;
    branchesDescription!: string | undefined;

    constructor(data?: IGetEmployeesForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employees = data["employees"] ? CreateOrEditEmployeesDto.fromJS(data["employees"]) : <any>undefined;
            this.employeeTypeDescription = data["employeeTypeDescription"];
            this.branchesDescription = data["branchesDescription"];
        }
    }

    static fromJS(data: any): GetEmployeesForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employees"] = this.employees ? this.employees.toJSON() : <any>undefined;
        data["employeeTypeDescription"] = this.employeeTypeDescription;
        data["branchesDescription"] = this.branchesDescription;
        return data; 
    }
}

export interface IGetEmployeesForEditOutput {
    employees: CreateOrEditEmployeesDto | undefined;
    employeeTypeDescription: string | undefined;
    branchesDescription: string | undefined;
}

export class CreateOrEditEmployeesDto implements ICreateOrEditEmployeesDto {
    userName!: string;
    firstName!: string;
    lastName!: string;
    cellular!: string | undefined;
    gender!: string | undefined;
    email!: string | undefined;
    employeeIDNumber!: string;
    employeeNumber!: string;
    password!: number | undefined;
    isActive!: boolean | undefined;
    cardNumberTicketing!: number | undefined;
    emailAddress!: string | undefined;
    percentageOfPosition!: number | undefined;
    workStartDate!: moment.Moment | undefined;
    workEndDate!: moment.Moment | undefined;
    dateOfBirth!: moment.Moment | undefined;
    bankAccountNumber!: string | undefined;
    jobTitle!: string | undefined;
    employeeTypeId!: number | undefined;
    branchesId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEmployeesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.cellular = data["cellular"];
            this.gender = data["gender"];
            this.email = data["email"];
            this.employeeIDNumber = data["employeeIDNumber"];
            this.employeeNumber = data["employeeNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.cardNumberTicketing = data["cardNumberTicketing"];
            this.emailAddress = data["emailAddress"];
            this.percentageOfPosition = data["percentageOfPosition"];
            this.workStartDate = data["workStartDate"] ? moment(data["workStartDate"].toString()) : <any>undefined;
            this.workEndDate = data["workEndDate"] ? moment(data["workEndDate"].toString()) : <any>undefined;
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.bankAccountNumber = data["bankAccountNumber"];
            this.jobTitle = data["jobTitle"];
            this.employeeTypeId = data["employeeTypeId"];
            this.branchesId = data["branchesId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEmployeesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmployeesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["cellular"] = this.cellular;
        data["gender"] = this.gender;
        data["email"] = this.email;
        data["employeeIDNumber"] = this.employeeIDNumber;
        data["employeeNumber"] = this.employeeNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["cardNumberTicketing"] = this.cardNumberTicketing;
        data["emailAddress"] = this.emailAddress;
        data["percentageOfPosition"] = this.percentageOfPosition;
        data["workStartDate"] = this.workStartDate ? this.workStartDate.toISOString() : <any>undefined;
        data["workEndDate"] = this.workEndDate ? this.workEndDate.toISOString() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["jobTitle"] = this.jobTitle;
        data["employeeTypeId"] = this.employeeTypeId;
        data["branchesId"] = this.branchesId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEmployeesDto {
    userName: string;
    firstName: string;
    lastName: string;
    cellular: string | undefined;
    gender: string | undefined;
    email: string | undefined;
    employeeIDNumber: string;
    employeeNumber: string;
    password: number | undefined;
    isActive: boolean | undefined;
    cardNumberTicketing: number | undefined;
    emailAddress: string | undefined;
    percentageOfPosition: number | undefined;
    workStartDate: moment.Moment | undefined;
    workEndDate: moment.Moment | undefined;
    dateOfBirth: moment.Moment | undefined;
    bankAccountNumber: string | undefined;
    jobTitle: string | undefined;
    employeeTypeId: number | undefined;
    branchesId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto implements IPagedResultDtoOfEmployeesEmployeeTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: EmployeesEmployeeTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeesEmployeeTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EmployeesEmployeeTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeesEmployeeTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEmployeesEmployeeTypeLookupTableDto {
    totalCount: number | undefined;
    items: EmployeesEmployeeTypeLookupTableDto[] | undefined;
}

export class EmployeesEmployeeTypeLookupTableDto implements IEmployeesEmployeeTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IEmployeesEmployeeTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EmployeesEmployeeTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeesEmployeeTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEmployeesEmployeeTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfEmployeesBranchesLookupTableDto implements IPagedResultDtoOfEmployeesBranchesLookupTableDto {
    totalCount!: number | undefined;
    items!: EmployeesBranchesLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeesBranchesLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EmployeesBranchesLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeesBranchesLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeesBranchesLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEmployeesBranchesLookupTableDto {
    totalCount: number | undefined;
    items: EmployeesBranchesLookupTableDto[] | undefined;
}

export class EmployeesBranchesLookupTableDto implements IEmployeesBranchesLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IEmployeesBranchesLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EmployeesBranchesLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeesBranchesLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEmployeesBranchesLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetEmployeeTypeForViewDto implements IPagedResultDtoOfGetEmployeeTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetEmployeeTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEmployeeTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEmployeeTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEmployeeTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEmployeeTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEmployeeTypeForViewDto {
    totalCount: number | undefined;
    items: GetEmployeeTypeForViewDto[] | undefined;
}

export class GetEmployeeTypeForViewDto implements IGetEmployeeTypeForViewDto {
    employeeType!: EmployeeTypeDto | undefined;

    constructor(data?: IGetEmployeeTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employeeType = data["employeeType"] ? EmployeeTypeDto.fromJS(data["employeeType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEmployeeTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeType"] = this.employeeType ? this.employeeType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEmployeeTypeForViewDto {
    employeeType: EmployeeTypeDto | undefined;
}

export class EmployeeTypeDto implements IEmployeeTypeDto {
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEmployeeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EmployeeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEmployeeTypeDto {
    description: string | undefined;
    id: number | undefined;
}

export class GetEmployeeTypeForEditOutput implements IGetEmployeeTypeForEditOutput {
    employeeType!: CreateOrEditEmployeeTypeDto | undefined;

    constructor(data?: IGetEmployeeTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employeeType = data["employeeType"] ? CreateOrEditEmployeeTypeDto.fromJS(data["employeeType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEmployeeTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employeeType"] = this.employeeType ? this.employeeType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEmployeeTypeForEditOutput {
    employeeType: CreateOrEditEmployeeTypeDto | undefined;
}

export class CreateOrEditEmployeeTypeDto implements ICreateOrEditEmployeeTypeDto {
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEmployeeTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEmployeeTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEmployeeTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEmployeeTypeDto {
    description: string | undefined;
    id: number | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export enum ChartDateInterval {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [] as any;
                for (let item of data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [] as any;
                for (let item of data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;
    otherSettings!: OtherSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto | undefined;
    billInfo!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment | undefined;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [] as any;
                for (let item of data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [] as any;
                for (let item of data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class PagedResultDtoOfGetJobTitleForViewDto implements IPagedResultDtoOfGetJobTitleForViewDto {
    totalCount!: number | undefined;
    items!: GetJobTitleForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetJobTitleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetJobTitleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetJobTitleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetJobTitleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetJobTitleForViewDto {
    totalCount: number | undefined;
    items: GetJobTitleForViewDto[] | undefined;
}

export class GetJobTitleForViewDto implements IGetJobTitleForViewDto {
    jobTitle!: JobTitleDto | undefined;

    constructor(data?: IGetJobTitleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobTitle = data["jobTitle"] ? JobTitleDto.fromJS(data["jobTitle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJobTitleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobTitleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetJobTitleForViewDto {
    jobTitle: JobTitleDto | undefined;
}

export class JobTitleDto implements IJobTitleDto {
    description!: string | undefined;
    description2ndLang!: string | undefined;
    description3rdLang!: string | undefined;
    id!: number | undefined;

    constructor(data?: IJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.description2ndLang = data["description2ndLang"];
            this.description3rdLang = data["description3rdLang"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): JobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["description2ndLang"] = this.description2ndLang;
        data["description3rdLang"] = this.description3rdLang;
        data["id"] = this.id;
        return data; 
    }
}

export interface IJobTitleDto {
    description: string | undefined;
    description2ndLang: string | undefined;
    description3rdLang: string | undefined;
    id: number | undefined;
}

export class GetJobTitleForEditOutput implements IGetJobTitleForEditOutput {
    jobTitle!: CreateOrEditJobTitleDto | undefined;

    constructor(data?: IGetJobTitleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.jobTitle = data["jobTitle"] ? CreateOrEditJobTitleDto.fromJS(data["jobTitle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJobTitleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobTitleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetJobTitleForEditOutput {
    jobTitle: CreateOrEditJobTitleDto | undefined;
}

export class CreateOrEditJobTitleDto implements ICreateOrEditJobTitleDto {
    description!: string | undefined;
    description2ndLang!: string | undefined;
    description3rdLang!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.description2ndLang = data["description2ndLang"];
            this.description3rdLang = data["description3rdLang"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditJobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditJobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["description2ndLang"] = this.description2ndLang;
        data["description3rdLang"] = this.description3rdLang;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditJobTitleDto {
    description: string | undefined;
    description2ndLang: string | undefined;
    description3rdLang: string | undefined;
    id: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export enum UserNotificationState {
    Unread = 0, 
    Read = 1, 
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotification | undefined;
    id!: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties![key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0, 
    Success = 1, 
    Warn = 2, 
    Error = 3, 
    Fatal = 4, 
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    roleCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto | undefined;
    additionalPrice!: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean | undefined;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number | undefined;
    editionPaymentType!: EditionPaymentType | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled!: boolean | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export enum PaymentPeriodType {
    Monthly = 30, 
    Annual = 365, 
}

export enum EditionPaymentType {
    NewRegistration = 0, 
    BuyNow = 1, 
    Upgrade = 2, 
    Extend = 3, 
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1, 
    Stripe = 2, 
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number | undefined;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number | undefined;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments!: boolean | undefined;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    tenantId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number | undefined;
    status!: SubscriptionPaymentStatus | undefined;
    isRecurring!: boolean | undefined;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1, 
    Paid = 2, 
    Failed = 3, 
    Cancelled = 4, 
    Completed = 5, 
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    environment!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.environment = data["environment"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["environment"] = this.environment;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    environment: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number | undefined;
    y!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class PagedResultDtoOfGetRouteForView implements IPagedResultDtoOfGetRouteForView {
    totalCount!: number | undefined;
    items!: GetRouteForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRouteForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRouteForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRouteForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRouteForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRouteForView {
    totalCount: number | undefined;
    items: GetRouteForView[] | undefined;
}

export class GetRouteForView implements IGetRouteForView {
    route!: RouteDto | undefined;

    constructor(data?: IGetRouteForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.route = data["route"] ? RouteDto.fromJS(data["route"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRouteForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetRouteForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRouteForView {
    route: RouteDto | undefined;
}

export class RouteDto implements IRouteDto {
    lineNumber!: number | undefined;
    direction!: number | undefined;
    lineCode!: number | undefined;
    signage!: number | undefined;
    agency!: number | undefined;
    totalKM!: number | undefined;
    totalMinutes!: number | undefined;
    routeIDGTFS!: string | undefined;
    catSedor!: number | undefined;
    id!: number | undefined;

    constructor(data?: IRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lineNumber = data["lineNumber"];
            this.direction = data["direction"];
            this.lineCode = data["lineCode"];
            this.signage = data["signage"];
            this.agency = data["agency"];
            this.totalKM = data["totalKM"];
            this.totalMinutes = data["totalMinutes"];
            this.routeIDGTFS = data["routeIDGTFS"];
            this.catSedor = data["catSedor"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineNumber"] = this.lineNumber;
        data["direction"] = this.direction;
        data["lineCode"] = this.lineCode;
        data["signage"] = this.signage;
        data["agency"] = this.agency;
        data["totalKM"] = this.totalKM;
        data["totalMinutes"] = this.totalMinutes;
        data["routeIDGTFS"] = this.routeIDGTFS;
        data["catSedor"] = this.catSedor;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRouteDto {
    lineNumber: number | undefined;
    direction: number | undefined;
    lineCode: number | undefined;
    signage: number | undefined;
    agency: number | undefined;
    totalKM: number | undefined;
    totalMinutes: number | undefined;
    routeIDGTFS: string | undefined;
    catSedor: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetStatoinDetailForRouteForView implements IPagedResultDtoOfGetStatoinDetailForRouteForView {
    totalCount!: number | undefined;
    items!: GetStatoinDetailForRouteForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStatoinDetailForRouteForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetStatoinDetailForRouteForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStatoinDetailForRouteForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStatoinDetailForRouteForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetStatoinDetailForRouteForView {
    totalCount: number | undefined;
    items: GetStatoinDetailForRouteForView[] | undefined;
}

export class GetStatoinDetailForRouteForView implements IGetStatoinDetailForRouteForView {
    route!: GetRouteForView | undefined;
    station!: GetStationForView | undefined;
    routes_Station!: GetRoutes_StationForView | undefined;

    constructor(data?: IGetStatoinDetailForRouteForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.route = data["route"] ? GetRouteForView.fromJS(data["route"]) : <any>undefined;
            this.station = data["station"] ? GetStationForView.fromJS(data["station"]) : <any>undefined;
            this.routes_Station = data["routes_Station"] ? GetRoutes_StationForView.fromJS(data["routes_Station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetStatoinDetailForRouteForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetStatoinDetailForRouteForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        data["station"] = this.station ? this.station.toJSON() : <any>undefined;
        data["routes_Station"] = this.routes_Station ? this.routes_Station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetStatoinDetailForRouteForView {
    route: GetRouteForView | undefined;
    station: GetStationForView | undefined;
    routes_Station: GetRoutes_StationForView | undefined;
}

export class GetStationForView implements IGetStationForView {
    station!: StationDto | undefined;

    constructor(data?: IGetStationForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.station = data["station"] ? StationDto.fromJS(data["station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetStationForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetStationForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["station"] = this.station ? this.station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetStationForView {
    station: StationDto | undefined;
}

export class GetRoutes_StationForView implements IGetRoutes_StationForView {
    routes_Station!: Routes_StationDto | undefined;

    constructor(data?: IGetRoutes_StationForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routes_Station = data["routes_Station"] ? Routes_StationDto.fromJS(data["routes_Station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRoutes_StationForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoutes_StationForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routes_Station"] = this.routes_Station ? this.routes_Station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRoutes_StationForView {
    routes_Station: Routes_StationDto | undefined;
}

export class StationDto implements IStationDto {
    locationName!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    isStop!: boolean | undefined;
    stationCode!: number | undefined;
    locationNameHebrew!: string | undefined;
    type!: string | undefined;
    isMark!: boolean | undefined;
    isSave!: boolean | undefined;
    checkDistance!: number | undefined;
    isPath!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IStationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locationName = data["locationName"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.isStop = data["isStop"];
            this.stationCode = data["stationCode"];
            this.locationNameHebrew = data["locationNameHebrew"];
            this.type = data["type"];
            this.isMark = data["isMark"];
            this.isSave = data["isSave"];
            this.checkDistance = data["checkDistance"];
            this.isPath = data["isPath"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationName"] = this.locationName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["isStop"] = this.isStop;
        data["stationCode"] = this.stationCode;
        data["locationNameHebrew"] = this.locationNameHebrew;
        data["type"] = this.type;
        data["isMark"] = this.isMark;
        data["isSave"] = this.isSave;
        data["checkDistance"] = this.checkDistance;
        data["isPath"] = this.isPath;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStationDto {
    locationName: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    isStop: boolean | undefined;
    stationCode: number | undefined;
    locationNameHebrew: string | undefined;
    type: string | undefined;
    isMark: boolean | undefined;
    isSave: boolean | undefined;
    checkDistance: number | undefined;
    isPath: boolean | undefined;
    id: number | undefined;
}

export class Routes_StationDto implements IRoutes_StationDto {
    routesID!: number | undefined;
    stationCode!: number | undefined;
    stationOrder!: number | undefined;
    distanceFStart!: number | undefined;
    distanceFPrviousSt!: number | undefined;
    timefrStartStation!: number | undefined;
    linkToMain!: number | undefined;
    timefrPrvious!: string | undefined;
    timeFrStart!: string | undefined;
    id!: number | undefined;

    constructor(data?: IRoutes_StationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routesID = data["routesID"];
            this.stationCode = data["stationCode"];
            this.stationOrder = data["stationOrder"];
            this.distanceFStart = data["distanceFStart"];
            this.distanceFPrviousSt = data["distanceFPrviousSt"];
            this.timefrStartStation = data["timefrStartStation"];
            this.linkToMain = data["linkToMain"];
            this.timefrPrvious = data["timefrPrvious"];
            this.timeFrStart = data["timeFrStart"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Routes_StationDto {
        data = typeof data === 'object' ? data : {};
        let result = new Routes_StationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routesID"] = this.routesID;
        data["stationCode"] = this.stationCode;
        data["stationOrder"] = this.stationOrder;
        data["distanceFStart"] = this.distanceFStart;
        data["distanceFPrviousSt"] = this.distanceFPrviousSt;
        data["timefrStartStation"] = this.timefrStartStation;
        data["linkToMain"] = this.linkToMain;
        data["timefrPrvious"] = this.timefrPrvious;
        data["timeFrStart"] = this.timeFrStart;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoutes_StationDto {
    routesID: number | undefined;
    stationCode: number | undefined;
    stationOrder: number | undefined;
    distanceFStart: number | undefined;
    distanceFPrviousSt: number | undefined;
    timefrStartStation: number | undefined;
    linkToMain: number | undefined;
    timefrPrvious: string | undefined;
    timeFrStart: string | undefined;
    id: number | undefined;
}

export class GetRouteForEditOutput implements IGetRouteForEditOutput {
    route!: CreateOrEditRouteDto | undefined;

    constructor(data?: IGetRouteForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.route = data["route"] ? CreateOrEditRouteDto.fromJS(data["route"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRouteForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRouteForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["route"] = this.route ? this.route.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRouteForEditOutput {
    route: CreateOrEditRouteDto | undefined;
}

export class CreateOrEditRouteDto implements ICreateOrEditRouteDto {
    lineNumber!: number | undefined;
    direction!: number | undefined;
    lineCode!: number | undefined;
    signage!: number | undefined;
    agency!: number | undefined;
    totalKM!: number | undefined;
    totalMinutes!: number | undefined;
    routeIDGTFS!: string | undefined;
    catSedor!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditRouteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lineNumber = data["lineNumber"];
            this.direction = data["direction"];
            this.lineCode = data["lineCode"];
            this.signage = data["signage"];
            this.agency = data["agency"];
            this.totalKM = data["totalKM"];
            this.totalMinutes = data["totalMinutes"];
            this.routeIDGTFS = data["routeIDGTFS"];
            this.catSedor = data["catSedor"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRouteDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRouteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineNumber"] = this.lineNumber;
        data["direction"] = this.direction;
        data["lineCode"] = this.lineCode;
        data["signage"] = this.signage;
        data["agency"] = this.agency;
        data["totalKM"] = this.totalKM;
        data["totalMinutes"] = this.totalMinutes;
        data["routeIDGTFS"] = this.routeIDGTFS;
        data["catSedor"] = this.catSedor;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRouteDto {
    lineNumber: number | undefined;
    direction: number | undefined;
    lineCode: number | undefined;
    signage: number | undefined;
    agency: number | undefined;
    totalKM: number | undefined;
    totalMinutes: number | undefined;
    routeIDGTFS: string | undefined;
    catSedor: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetRoutes_StationForView implements IPagedResultDtoOfGetRoutes_StationForView {
    totalCount!: number | undefined;
    items!: GetRoutes_StationForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRoutes_StationForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRoutes_StationForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRoutes_StationForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRoutes_StationForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRoutes_StationForView {
    totalCount: number | undefined;
    items: GetRoutes_StationForView[] | undefined;
}

export class GetRoutes_StationForEditOutput implements IGetRoutes_StationForEditOutput {
    routes_Station!: CreateOrEditRoutes_StationDto | undefined;

    constructor(data?: IGetRoutes_StationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routes_Station = data["routes_Station"] ? CreateOrEditRoutes_StationDto.fromJS(data["routes_Station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRoutes_StationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoutes_StationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routes_Station"] = this.routes_Station ? this.routes_Station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRoutes_StationForEditOutput {
    routes_Station: CreateOrEditRoutes_StationDto | undefined;
}

export class CreateOrEditRoutes_StationDto implements ICreateOrEditRoutes_StationDto {
    routesID!: number | undefined;
    stationCode!: number | undefined;
    stationOrder!: number | undefined;
    distanceFStart!: number | undefined;
    distanceFPrviousSt!: number | undefined;
    timefrStartStation!: number | undefined;
    linkToMain!: number | undefined;
    timefrPrvious!: string | undefined;
    timeFrStart!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditRoutes_StationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routesID = data["routesID"];
            this.stationCode = data["stationCode"];
            this.stationOrder = data["stationOrder"];
            this.distanceFStart = data["distanceFStart"];
            this.distanceFPrviousSt = data["distanceFPrviousSt"];
            this.timefrStartStation = data["timefrStartStation"];
            this.linkToMain = data["linkToMain"];
            this.timefrPrvious = data["timefrPrvious"];
            this.timeFrStart = data["timeFrStart"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRoutes_StationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRoutes_StationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routesID"] = this.routesID;
        data["stationCode"] = this.stationCode;
        data["stationOrder"] = this.stationOrder;
        data["distanceFStart"] = this.distanceFStart;
        data["distanceFPrviousSt"] = this.distanceFPrviousSt;
        data["timefrStartStation"] = this.timefrStartStation;
        data["linkToMain"] = this.linkToMain;
        data["timefrPrvious"] = this.timefrPrvious;
        data["timeFrStart"] = this.timeFrStart;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRoutes_StationDto {
    routesID: number | undefined;
    stationCode: number | undefined;
    stationOrder: number | undefined;
    distanceFStart: number | undefined;
    distanceFPrviousSt: number | undefined;
    timefrStartStation: number | undefined;
    linkToMain: number | undefined;
    timefrPrvious: string | undefined;
    timeFrStart: string | undefined;
    id: number | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;
    theme!: UiCustomizationSettingsDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    subscriptionPaymentType!: SubscriptionPaymentType | undefined;
    edition!: EditionInfoDto | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean | undefined;
    features!: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features![key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto | undefined;
    isLeftMenuUsed!: boolean | undefined;
    isTopMenuUsed!: boolean | undefined;
    isTabMenuUsed!: boolean | undefined;
    allowMenuScroll!: boolean | undefined;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;
}

export enum SubscriptionPaymentType {
    Manual = 0, 
    RecurringAutomatic = 1, 
    RecurringManual = 2, 
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean | undefined;
    isFree!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto | undefined;
    header!: ThemeHeaderSettingsDto | undefined;
    subHeader!: ThemeSubHeaderSettingsDto | undefined;
    menu!: ThemeMenuSettingsDto | undefined;
    footer!: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.subHeader = data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(data["subHeader"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    subHeader: ThemeSubHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;
    headerMenuArrows!: boolean | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.minimizeDesktopHeaderType = data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean | undefined;
    subheaderStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedSubHeader = data["fixedSubHeader"];
            this.subheaderStyle = data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data; 
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean | undefined;
    subheaderStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    submenuToggle!: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    submenuToggle: string | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class PagedResultDtoOfGetStaffForView implements IPagedResultDtoOfGetStaffForView {
    totalCount!: number | undefined;
    items!: GetStaffForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStaffForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetStaffForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStaffForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStaffForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetStaffForView {
    totalCount: number | undefined;
    items: GetStaffForView[] | undefined;
}

export class GetStaffForView implements IGetStaffForView {
    staff!: StaffDto | undefined;
    departmentDepartmentName!: string | undefined;
    organizationUnitDisplayName!: string | undefined;
    staffFULL_NAME!: string | undefined;

    constructor(data?: IGetStaffForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.staff = data["staff"] ? StaffDto.fromJS(data["staff"]) : <any>undefined;
            this.departmentDepartmentName = data["departmentDepartmentName"];
            this.organizationUnitDisplayName = data["organizationUnitDisplayName"];
            this.staffFULL_NAME = data["staffFULL_NAME"];
        }
    }

    static fromJS(data: any): GetStaffForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetStaffForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staff"] = this.staff ? this.staff.toJSON() : <any>undefined;
        data["departmentDepartmentName"] = this.departmentDepartmentName;
        data["organizationUnitDisplayName"] = this.organizationUnitDisplayName;
        data["staffFULL_NAME"] = this.staffFULL_NAME;
        return data; 
    }
}

export interface IGetStaffForView {
    staff: StaffDto | undefined;
    departmentDepartmentName: string | undefined;
    organizationUnitDisplayName: string | undefined;
    staffFULL_NAME: string | undefined;
}

export class StaffDto implements IStaffDto {
    fulL_NAME!: string | undefined;
    gender!: string | undefined;
    workMobile!: string | undefined;
    jobTitle!: string | undefined;
    profession!: string | undefined;
    phone!: string | undefined;
    mobile!: string | undefined;
    posistion!: string | undefined;
    employmenT_TYPE!: string | undefined;
    projecT_ID!: number | undefined;
    dob!: moment.Moment | undefined;
    doe!: moment.Moment | undefined;
    logiN_NAME!: string | undefined;
    logiN_PASS!: string | undefined;
    iS_ACTIVE!: boolean | undefined;
    roles!: string | undefined;
    email!: string | undefined;
    skype!: string | undefined;
    personalIM!: string | undefined;
    homeFax!: string | undefined;
    homePhone!: string | undefined;
    address!: string | undefined;
    postalCode!: string | undefined;
    workExtension!: string | undefined;
    lastUpdated!: moment.Moment | undefined;
    employeestartDate!: moment.Moment | undefined;
    cost!: number | undefined;
    timsheetCheckByEmp!: number | undefined;
    autoranID!: number | undefined;
    isDriver!: boolean | undefined;
    x!: number | undefined;
    y!: number | undefined;
    day!: string | undefined;
    displayOrder!: number | undefined;
    isStop!: boolean | undefined;
    autoranIDServer!: number | undefined;
    idNumber!: string | undefined;
    klushNo!: string | undefined;
    welfareClockId!: number | undefined;
    departmentId!: number | undefined;
    organizationUnitId!: number | undefined;
    supervisorId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fulL_NAME = data["fulL_NAME"];
            this.gender = data["gender"];
            this.workMobile = data["workMobile"];
            this.jobTitle = data["jobTitle"];
            this.profession = data["profession"];
            this.phone = data["phone"];
            this.mobile = data["mobile"];
            this.posistion = data["posistion"];
            this.employmenT_TYPE = data["employmenT_TYPE"];
            this.projecT_ID = data["projecT_ID"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.doe = data["doe"] ? moment(data["doe"].toString()) : <any>undefined;
            this.logiN_NAME = data["logiN_NAME"];
            this.logiN_PASS = data["logiN_PASS"];
            this.iS_ACTIVE = data["iS_ACTIVE"];
            this.roles = data["roles"];
            this.email = data["email"];
            this.skype = data["skype"];
            this.personalIM = data["personalIM"];
            this.homeFax = data["homeFax"];
            this.homePhone = data["homePhone"];
            this.address = data["address"];
            this.postalCode = data["postalCode"];
            this.workExtension = data["workExtension"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.employeestartDate = data["employeestartDate"] ? moment(data["employeestartDate"].toString()) : <any>undefined;
            this.cost = data["cost"];
            this.timsheetCheckByEmp = data["timsheetCheckByEmp"];
            this.autoranID = data["autoranID"];
            this.isDriver = data["isDriver"];
            this.x = data["x"];
            this.y = data["y"];
            this.day = data["day"];
            this.displayOrder = data["displayOrder"];
            this.isStop = data["isStop"];
            this.autoranIDServer = data["autoranIDServer"];
            this.idNumber = data["idNumber"];
            this.klushNo = data["klushNo"];
            this.welfareClockId = data["welfareClockId"];
            this.departmentId = data["departmentId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.supervisorId = data["supervisorId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fulL_NAME"] = this.fulL_NAME;
        data["gender"] = this.gender;
        data["workMobile"] = this.workMobile;
        data["jobTitle"] = this.jobTitle;
        data["profession"] = this.profession;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["posistion"] = this.posistion;
        data["employmenT_TYPE"] = this.employmenT_TYPE;
        data["projecT_ID"] = this.projecT_ID;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["doe"] = this.doe ? this.doe.toISOString() : <any>undefined;
        data["logiN_NAME"] = this.logiN_NAME;
        data["logiN_PASS"] = this.logiN_PASS;
        data["iS_ACTIVE"] = this.iS_ACTIVE;
        data["roles"] = this.roles;
        data["email"] = this.email;
        data["skype"] = this.skype;
        data["personalIM"] = this.personalIM;
        data["homeFax"] = this.homeFax;
        data["homePhone"] = this.homePhone;
        data["address"] = this.address;
        data["postalCode"] = this.postalCode;
        data["workExtension"] = this.workExtension;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["employeestartDate"] = this.employeestartDate ? this.employeestartDate.toISOString() : <any>undefined;
        data["cost"] = this.cost;
        data["timsheetCheckByEmp"] = this.timsheetCheckByEmp;
        data["autoranID"] = this.autoranID;
        data["isDriver"] = this.isDriver;
        data["x"] = this.x;
        data["y"] = this.y;
        data["day"] = this.day;
        data["displayOrder"] = this.displayOrder;
        data["isStop"] = this.isStop;
        data["autoranIDServer"] = this.autoranIDServer;
        data["idNumber"] = this.idNumber;
        data["klushNo"] = this.klushNo;
        data["welfareClockId"] = this.welfareClockId;
        data["departmentId"] = this.departmentId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["supervisorId"] = this.supervisorId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStaffDto {
    fulL_NAME: string | undefined;
    gender: string | undefined;
    workMobile: string | undefined;
    jobTitle: string | undefined;
    profession: string | undefined;
    phone: string | undefined;
    mobile: string | undefined;
    posistion: string | undefined;
    employmenT_TYPE: string | undefined;
    projecT_ID: number | undefined;
    dob: moment.Moment | undefined;
    doe: moment.Moment | undefined;
    logiN_NAME: string | undefined;
    logiN_PASS: string | undefined;
    iS_ACTIVE: boolean | undefined;
    roles: string | undefined;
    email: string | undefined;
    skype: string | undefined;
    personalIM: string | undefined;
    homeFax: string | undefined;
    homePhone: string | undefined;
    address: string | undefined;
    postalCode: string | undefined;
    workExtension: string | undefined;
    lastUpdated: moment.Moment | undefined;
    employeestartDate: moment.Moment | undefined;
    cost: number | undefined;
    timsheetCheckByEmp: number | undefined;
    autoranID: number | undefined;
    isDriver: boolean | undefined;
    x: number | undefined;
    y: number | undefined;
    day: string | undefined;
    displayOrder: number | undefined;
    isStop: boolean | undefined;
    autoranIDServer: number | undefined;
    idNumber: string | undefined;
    klushNo: string | undefined;
    welfareClockId: number | undefined;
    departmentId: number | undefined;
    organizationUnitId: number | undefined;
    supervisorId: number | undefined;
    id: number | undefined;
}

export class GetStaffForEditOutput implements IGetStaffForEditOutput {
    staff!: CreateOrEditStaffDto | undefined;
    departmentDepartmentName!: string | undefined;
    organizationUnitDisplayName!: string | undefined;
    staffFULL_NAME!: string | undefined;

    constructor(data?: IGetStaffForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.staff = data["staff"] ? CreateOrEditStaffDto.fromJS(data["staff"]) : <any>undefined;
            this.departmentDepartmentName = data["departmentDepartmentName"];
            this.organizationUnitDisplayName = data["organizationUnitDisplayName"];
            this.staffFULL_NAME = data["staffFULL_NAME"];
        }
    }

    static fromJS(data: any): GetStaffForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStaffForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["staff"] = this.staff ? this.staff.toJSON() : <any>undefined;
        data["departmentDepartmentName"] = this.departmentDepartmentName;
        data["organizationUnitDisplayName"] = this.organizationUnitDisplayName;
        data["staffFULL_NAME"] = this.staffFULL_NAME;
        return data; 
    }
}

export interface IGetStaffForEditOutput {
    staff: CreateOrEditStaffDto | undefined;
    departmentDepartmentName: string | undefined;
    organizationUnitDisplayName: string | undefined;
    staffFULL_NAME: string | undefined;
}

export class CreateOrEditStaffDto implements ICreateOrEditStaffDto {
    fulL_NAME!: string;
    gender!: string | undefined;
    workMobile!: string | undefined;
    jobTitle!: string | undefined;
    profession!: string | undefined;
    phone!: string | undefined;
    mobile!: string | undefined;
    posistion!: string | undefined;
    employmenT_TYPE!: string | undefined;
    projecT_ID!: number | undefined;
    dob!: moment.Moment | undefined;
    doe!: moment.Moment | undefined;
    logiN_NAME!: string | undefined;
    logiN_PASS!: string | undefined;
    iS_ACTIVE!: boolean | undefined;
    roles!: string | undefined;
    email!: string | undefined;
    skype!: string | undefined;
    personalIM!: string | undefined;
    homeFax!: string | undefined;
    homePhone!: string | undefined;
    address!: string | undefined;
    postalCode!: string | undefined;
    workExtension!: string | undefined;
    lastUpdated!: moment.Moment | undefined;
    employeestartDate!: moment.Moment | undefined;
    cost!: number | undefined;
    timsheetCheckByEmp!: number | undefined;
    autoranID!: number | undefined;
    isDriver!: boolean | undefined;
    x!: number | undefined;
    y!: number | undefined;
    day!: string | undefined;
    displayOrder!: number | undefined;
    isStop!: boolean | undefined;
    autoranIDServer!: number | undefined;
    idNumber!: string | undefined;
    klushNo!: string | undefined;
    welfareClockId!: number | undefined;
    departmentId!: number | undefined;
    organizationUnitId!: number | undefined;
    supervisorId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fulL_NAME = data["fulL_NAME"];
            this.gender = data["gender"];
            this.workMobile = data["workMobile"];
            this.jobTitle = data["jobTitle"];
            this.profession = data["profession"];
            this.phone = data["phone"];
            this.mobile = data["mobile"];
            this.posistion = data["posistion"];
            this.employmenT_TYPE = data["employmenT_TYPE"];
            this.projecT_ID = data["projecT_ID"];
            this.dob = data["dob"] ? moment(data["dob"].toString()) : <any>undefined;
            this.doe = data["doe"] ? moment(data["doe"].toString()) : <any>undefined;
            this.logiN_NAME = data["logiN_NAME"];
            this.logiN_PASS = data["logiN_PASS"];
            this.iS_ACTIVE = data["iS_ACTIVE"];
            this.roles = data["roles"];
            this.email = data["email"];
            this.skype = data["skype"];
            this.personalIM = data["personalIM"];
            this.homeFax = data["homeFax"];
            this.homePhone = data["homePhone"];
            this.address = data["address"];
            this.postalCode = data["postalCode"];
            this.workExtension = data["workExtension"];
            this.lastUpdated = data["lastUpdated"] ? moment(data["lastUpdated"].toString()) : <any>undefined;
            this.employeestartDate = data["employeestartDate"] ? moment(data["employeestartDate"].toString()) : <any>undefined;
            this.cost = data["cost"];
            this.timsheetCheckByEmp = data["timsheetCheckByEmp"];
            this.autoranID = data["autoranID"];
            this.isDriver = data["isDriver"];
            this.x = data["x"];
            this.y = data["y"];
            this.day = data["day"];
            this.displayOrder = data["displayOrder"];
            this.isStop = data["isStop"];
            this.autoranIDServer = data["autoranIDServer"];
            this.idNumber = data["idNumber"];
            this.klushNo = data["klushNo"];
            this.welfareClockId = data["welfareClockId"];
            this.departmentId = data["departmentId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.supervisorId = data["supervisorId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fulL_NAME"] = this.fulL_NAME;
        data["gender"] = this.gender;
        data["workMobile"] = this.workMobile;
        data["jobTitle"] = this.jobTitle;
        data["profession"] = this.profession;
        data["phone"] = this.phone;
        data["mobile"] = this.mobile;
        data["posistion"] = this.posistion;
        data["employmenT_TYPE"] = this.employmenT_TYPE;
        data["projecT_ID"] = this.projecT_ID;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["doe"] = this.doe ? this.doe.toISOString() : <any>undefined;
        data["logiN_NAME"] = this.logiN_NAME;
        data["logiN_PASS"] = this.logiN_PASS;
        data["iS_ACTIVE"] = this.iS_ACTIVE;
        data["roles"] = this.roles;
        data["email"] = this.email;
        data["skype"] = this.skype;
        data["personalIM"] = this.personalIM;
        data["homeFax"] = this.homeFax;
        data["homePhone"] = this.homePhone;
        data["address"] = this.address;
        data["postalCode"] = this.postalCode;
        data["workExtension"] = this.workExtension;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["employeestartDate"] = this.employeestartDate ? this.employeestartDate.toISOString() : <any>undefined;
        data["cost"] = this.cost;
        data["timsheetCheckByEmp"] = this.timsheetCheckByEmp;
        data["autoranID"] = this.autoranID;
        data["isDriver"] = this.isDriver;
        data["x"] = this.x;
        data["y"] = this.y;
        data["day"] = this.day;
        data["displayOrder"] = this.displayOrder;
        data["isStop"] = this.isStop;
        data["autoranIDServer"] = this.autoranIDServer;
        data["idNumber"] = this.idNumber;
        data["klushNo"] = this.klushNo;
        data["welfareClockId"] = this.welfareClockId;
        data["departmentId"] = this.departmentId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["supervisorId"] = this.supervisorId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditStaffDto {
    fulL_NAME: string;
    gender: string | undefined;
    workMobile: string | undefined;
    jobTitle: string | undefined;
    profession: string | undefined;
    phone: string | undefined;
    mobile: string | undefined;
    posistion: string | undefined;
    employmenT_TYPE: string | undefined;
    projecT_ID: number | undefined;
    dob: moment.Moment | undefined;
    doe: moment.Moment | undefined;
    logiN_NAME: string | undefined;
    logiN_PASS: string | undefined;
    iS_ACTIVE: boolean | undefined;
    roles: string | undefined;
    email: string | undefined;
    skype: string | undefined;
    personalIM: string | undefined;
    homeFax: string | undefined;
    homePhone: string | undefined;
    address: string | undefined;
    postalCode: string | undefined;
    workExtension: string | undefined;
    lastUpdated: moment.Moment | undefined;
    employeestartDate: moment.Moment | undefined;
    cost: number | undefined;
    timsheetCheckByEmp: number | undefined;
    autoranID: number | undefined;
    isDriver: boolean | undefined;
    x: number | undefined;
    y: number | undefined;
    day: string | undefined;
    displayOrder: number | undefined;
    isStop: boolean | undefined;
    autoranIDServer: number | undefined;
    idNumber: string | undefined;
    klushNo: string | undefined;
    welfareClockId: number | undefined;
    departmentId: number | undefined;
    organizationUnitId: number | undefined;
    supervisorId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDepartmentLookupTableDto implements IPagedResultDtoOfDepartmentLookupTableDto {
    totalCount!: number | undefined;
    items!: DepartmentLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDepartmentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(DepartmentLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDepartmentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDepartmentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDepartmentLookupTableDto {
    totalCount: number | undefined;
    items: DepartmentLookupTableDto[] | undefined;
}

export class DepartmentLookupTableDto implements IDepartmentLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IDepartmentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): DepartmentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IDepartmentLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfStaffLookupTableDto implements IPagedResultDtoOfStaffLookupTableDto {
    totalCount!: number | undefined;
    items!: StaffLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStaffLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(StaffLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStaffLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStaffLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStaffLookupTableDto {
    totalCount: number | undefined;
    items: StaffLookupTableDto[] | undefined;
}

export class StaffLookupTableDto implements IStaffLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IStaffLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): StaffLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IStaffLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfOrganizationUnitLookupTableDto implements IPagedResultDtoOfOrganizationUnitLookupTableDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitLookupTableDto {
    totalCount: number | undefined;
    items: OrganizationUnitLookupTableDto[] | undefined;
}

export class OrganizationUnitLookupTableDto implements IOrganizationUnitLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IOrganizationUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): OrganizationUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IOrganizationUnitLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetStationForView implements IPagedResultDtoOfGetStationForView {
    totalCount!: number | undefined;
    items!: GetStationForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStationForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetStationForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStationForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStationForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetStationForView {
    totalCount: number | undefined;
    items: GetStationForView[] | undefined;
}

export class GetStationForEditOutput implements IGetStationForEditOutput {
    station!: CreateOrEditStationDto | undefined;

    constructor(data?: IGetStationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.station = data["station"] ? CreateOrEditStationDto.fromJS(data["station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetStationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["station"] = this.station ? this.station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetStationForEditOutput {
    station: CreateOrEditStationDto | undefined;
}

export class CreateOrEditStationDto implements ICreateOrEditStationDto {
    locationName!: string | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    isStop!: boolean | undefined;
    stationCode!: number;
    locationNameHebrew!: string | undefined;
    type!: string | undefined;
    isMark!: boolean | undefined;
    isSave!: boolean | undefined;
    checkDistance!: number | undefined;
    isPath!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditStationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locationName = data["locationName"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.isStop = data["isStop"];
            this.stationCode = data["stationCode"];
            this.locationNameHebrew = data["locationNameHebrew"];
            this.type = data["type"];
            this.isMark = data["isMark"];
            this.isSave = data["isSave"];
            this.checkDistance = data["checkDistance"];
            this.isPath = data["isPath"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditStationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditStationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationName"] = this.locationName;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["isStop"] = this.isStop;
        data["stationCode"] = this.stationCode;
        data["locationNameHebrew"] = this.locationNameHebrew;
        data["type"] = this.type;
        data["isMark"] = this.isMark;
        data["isSave"] = this.isSave;
        data["checkDistance"] = this.checkDistance;
        data["isPath"] = this.isPath;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditStationDto {
    locationName: string | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    isStop: boolean | undefined;
    stationCode: number;
    locationNameHebrew: string | undefined;
    type: string | undefined;
    isMark: boolean | undefined;
    isSave: boolean | undefined;
    checkDistance: number | undefined;
    isPath: boolean | undefined;
    id: number | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId!: number | undefined;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [] as any;
                for (let item of data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number | undefined;
    closed!: number | undefined;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number | undefined;
    newFeedbacks!: number | undefined;
    newOrders!: number | undefined;
    newUsers!: number | undefined;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number | undefined;
    revenue!: number | undefined;
    expenses!: number | undefined;
    growth!: number | undefined;
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [] as any;
                for (let item of data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [] as any;
                for (let item of data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number | undefined;
    profit!: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [] as any;
                for (let item of data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number | undefined;
    change!: number[] | undefined;
    averagePrice!: number | undefined;
    totalPrice!: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [] as any;
                for (let item of data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType | undefined;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;
}

export enum SubscriptionStartType {
    Free = 1, 
    Trial = 2, 
    Paid = 3, 
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean | undefined;
    isActive!: boolean | undefined;
    isEmailConfirmationRequired!: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;
    tenantEditionId!: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [] as any;
                for (let item of data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [] as any;
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType | undefined;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto | undefined;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;
    otherSettings!: TenantOtherSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export enum SettingScopes {
    Application = 1, 
    Tenant = 2, 
    User = 4, 
    All = 7, 
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    waitingForActivation!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class PagedResultDtoOfGetTripActualForView implements IPagedResultDtoOfGetTripActualForView {
    totalCount!: number | undefined;
    items!: GetTripActualForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripActualForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripActualForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripActualForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripActualForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripActualForView {
    totalCount: number | undefined;
    items: GetTripActualForView[] | undefined;
}

export class GetTripActualForView implements IGetTripActualForView {
    tripActual!: TripActualDto | undefined;
    routeLineNumber!: string | undefined;
    calenderBusTenantId!: string | undefined;
    tripPlanedTenantId!: string | undefined;
    tripByMinistryTenantId!: string | undefined;

    constructor(data?: IGetTripActualForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripActual = data["tripActual"] ? TripActualDto.fromJS(data["tripActual"]) : <any>undefined;
            this.routeLineNumber = data["routeLineNumber"];
            this.calenderBusTenantId = data["calenderBusTenantId"];
            this.tripPlanedTenantId = data["tripPlanedTenantId"];
            this.tripByMinistryTenantId = data["tripByMinistryTenantId"];
        }
    }

    static fromJS(data: any): GetTripActualForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripActualForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripActual"] = this.tripActual ? this.tripActual.toJSON() : <any>undefined;
        data["routeLineNumber"] = this.routeLineNumber;
        data["calenderBusTenantId"] = this.calenderBusTenantId;
        data["tripPlanedTenantId"] = this.tripPlanedTenantId;
        data["tripByMinistryTenantId"] = this.tripByMinistryTenantId;
        return data; 
    }
}

export interface IGetTripActualForView {
    tripActual: TripActualDto | undefined;
    routeLineNumber: string | undefined;
    calenderBusTenantId: string | undefined;
    tripPlanedTenantId: string | undefined;
    tripByMinistryTenantId: string | undefined;
}

export class TripActualDto implements ITripActualDto {
    timeSpan!: string | undefined;
    endStationID!: number | undefined;
    startStationID!: number | undefined;
    startStation!: string | undefined;
    endStation!: string | undefined;
    tripDate!: moment.Moment | undefined;
    controlStartTime!: string | undefined;
    isdone!: boolean | undefined;
    routeId!: number | undefined;
    calenderBusId!: number | undefined;
    tripPlanedId!: number | undefined;
    tripByMinistryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITripActualDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeSpan = data["timeSpan"];
            this.endStationID = data["endStationID"];
            this.startStationID = data["startStationID"];
            this.startStation = data["startStation"];
            this.endStation = data["endStation"];
            this.tripDate = data["tripDate"] ? moment(data["tripDate"].toString()) : <any>undefined;
            this.controlStartTime = data["controlStartTime"];
            this.isdone = data["isdone"];
            this.routeId = data["routeId"];
            this.calenderBusId = data["calenderBusId"];
            this.tripPlanedId = data["tripPlanedId"];
            this.tripByMinistryId = data["tripByMinistryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripActualDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripActualDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpan"] = this.timeSpan;
        data["endStationID"] = this.endStationID;
        data["startStationID"] = this.startStationID;
        data["startStation"] = this.startStation;
        data["endStation"] = this.endStation;
        data["tripDate"] = this.tripDate ? this.tripDate.toISOString() : <any>undefined;
        data["controlStartTime"] = this.controlStartTime;
        data["isdone"] = this.isdone;
        data["routeId"] = this.routeId;
        data["calenderBusId"] = this.calenderBusId;
        data["tripPlanedId"] = this.tripPlanedId;
        data["tripByMinistryId"] = this.tripByMinistryId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripActualDto {
    timeSpan: string | undefined;
    endStationID: number | undefined;
    startStationID: number | undefined;
    startStation: string | undefined;
    endStation: string | undefined;
    tripDate: moment.Moment | undefined;
    controlStartTime: string | undefined;
    isdone: boolean | undefined;
    routeId: number | undefined;
    calenderBusId: number | undefined;
    tripPlanedId: number | undefined;
    tripByMinistryId: number | undefined;
    id: number | undefined;
}

export class GetTripActualForEditOutput implements IGetTripActualForEditOutput {
    tripActual!: CreateOrEditTripActualDto | undefined;
    routeLineNumber!: string | undefined;
    calenderBusTenantId!: string | undefined;
    tripPlanedTenantId!: string | undefined;
    tripByMinistryTenantId!: string | undefined;

    constructor(data?: IGetTripActualForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripActual = data["tripActual"] ? CreateOrEditTripActualDto.fromJS(data["tripActual"]) : <any>undefined;
            this.routeLineNumber = data["routeLineNumber"];
            this.calenderBusTenantId = data["calenderBusTenantId"];
            this.tripPlanedTenantId = data["tripPlanedTenantId"];
            this.tripByMinistryTenantId = data["tripByMinistryTenantId"];
        }
    }

    static fromJS(data: any): GetTripActualForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripActualForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripActual"] = this.tripActual ? this.tripActual.toJSON() : <any>undefined;
        data["routeLineNumber"] = this.routeLineNumber;
        data["calenderBusTenantId"] = this.calenderBusTenantId;
        data["tripPlanedTenantId"] = this.tripPlanedTenantId;
        data["tripByMinistryTenantId"] = this.tripByMinistryTenantId;
        return data; 
    }
}

export interface IGetTripActualForEditOutput {
    tripActual: CreateOrEditTripActualDto | undefined;
    routeLineNumber: string | undefined;
    calenderBusTenantId: string | undefined;
    tripPlanedTenantId: string | undefined;
    tripByMinistryTenantId: string | undefined;
}

export class CreateOrEditTripActualDto implements ICreateOrEditTripActualDto {
    timeSpan!: string | undefined;
    endStationID!: number | undefined;
    startStationID!: number | undefined;
    startStation!: string | undefined;
    endStation!: string | undefined;
    tripDate!: moment.Moment | undefined;
    controlStartTime!: string | undefined;
    isdone!: boolean | undefined;
    routeId!: number | undefined;
    calenderBusId!: number | undefined;
    tripPlanedId!: number | undefined;
    tripByMinistryId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripActualDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeSpan = data["timeSpan"];
            this.endStationID = data["endStationID"];
            this.startStationID = data["startStationID"];
            this.startStation = data["startStation"];
            this.endStation = data["endStation"];
            this.tripDate = data["tripDate"] ? moment(data["tripDate"].toString()) : <any>undefined;
            this.controlStartTime = data["controlStartTime"];
            this.isdone = data["isdone"];
            this.routeId = data["routeId"];
            this.calenderBusId = data["calenderBusId"];
            this.tripPlanedId = data["tripPlanedId"];
            this.tripByMinistryId = data["tripByMinistryId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripActualDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripActualDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpan"] = this.timeSpan;
        data["endStationID"] = this.endStationID;
        data["startStationID"] = this.startStationID;
        data["startStation"] = this.startStation;
        data["endStation"] = this.endStation;
        data["tripDate"] = this.tripDate ? this.tripDate.toISOString() : <any>undefined;
        data["controlStartTime"] = this.controlStartTime;
        data["isdone"] = this.isdone;
        data["routeId"] = this.routeId;
        data["calenderBusId"] = this.calenderBusId;
        data["tripPlanedId"] = this.tripPlanedId;
        data["tripByMinistryId"] = this.tripByMinistryId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripActualDto {
    timeSpan: string | undefined;
    endStationID: number | undefined;
    startStationID: number | undefined;
    startStation: string | undefined;
    endStation: string | undefined;
    tripDate: moment.Moment | undefined;
    controlStartTime: string | undefined;
    isdone: boolean | undefined;
    routeId: number | undefined;
    calenderBusId: number | undefined;
    tripPlanedId: number | undefined;
    tripByMinistryId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfRouteLookupTableDto implements IPagedResultDtoOfRouteLookupTableDto {
    totalCount!: number | undefined;
    items!: RouteLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRouteLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RouteLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRouteLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRouteLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRouteLookupTableDto {
    totalCount: number | undefined;
    items: RouteLookupTableDto[] | undefined;
}

export class RouteLookupTableDto implements IRouteLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRouteLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RouteLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RouteLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRouteLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCalenderBusLookupTableDto implements IPagedResultDtoOfCalenderBusLookupTableDto {
    totalCount!: number | undefined;
    items!: CalenderBusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCalenderBusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CalenderBusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCalenderBusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCalenderBusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCalenderBusLookupTableDto {
    totalCount: number | undefined;
    items: CalenderBusLookupTableDto[] | undefined;
}

export class CalenderBusLookupTableDto implements ICalenderBusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICalenderBusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CalenderBusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CalenderBusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICalenderBusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfTripPlanedLookupTableDto implements IPagedResultDtoOfTripPlanedLookupTableDto {
    totalCount!: number | undefined;
    items!: TripPlanedLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTripPlanedLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TripPlanedLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTripPlanedLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTripPlanedLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTripPlanedLookupTableDto {
    totalCount: number | undefined;
    items: TripPlanedLookupTableDto[] | undefined;
}

export class TripPlanedLookupTableDto implements ITripPlanedLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ITripPlanedLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TripPlanedLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripPlanedLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITripPlanedLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfTripByMinistryLookupTableDto implements IPagedResultDtoOfTripByMinistryLookupTableDto {
    totalCount!: number | undefined;
    items!: TripByMinistryLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTripByMinistryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TripByMinistryLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTripByMinistryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTripByMinistryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTripByMinistryLookupTableDto {
    totalCount: number | undefined;
    items: TripByMinistryLookupTableDto[] | undefined;
}

export class TripByMinistryLookupTableDto implements ITripByMinistryLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ITripByMinistryLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TripByMinistryLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripByMinistryLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITripByMinistryLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetTripActualRoutes_StationForView implements IPagedResultDtoOfGetTripActualRoutes_StationForView {
    totalCount!: number | undefined;
    items!: GetTripActualRoutes_StationForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripActualRoutes_StationForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripActualRoutes_StationForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripActualRoutes_StationForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripActualRoutes_StationForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripActualRoutes_StationForView {
    totalCount: number | undefined;
    items: GetTripActualRoutes_StationForView[] | undefined;
}

export class GetTripActualRoutes_StationForView implements IGetTripActualRoutes_StationForView {
    tripActualRoutes_Station!: TripActualRoutes_StationDto | undefined;

    constructor(data?: IGetTripActualRoutes_StationForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripActualRoutes_Station = data["tripActualRoutes_Station"] ? TripActualRoutes_StationDto.fromJS(data["tripActualRoutes_Station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripActualRoutes_StationForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripActualRoutes_StationForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripActualRoutes_Station"] = this.tripActualRoutes_Station ? this.tripActualRoutes_Station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripActualRoutes_StationForView {
    tripActualRoutes_Station: TripActualRoutes_StationDto | undefined;
}

export class TripActualRoutes_StationDto implements ITripActualRoutes_StationDto {
    routesID!: number | undefined;
    stationCode!: number | undefined;
    stationOrder!: number | undefined;
    distanceFStart!: number | undefined;
    distanceFPrviousSt!: number | undefined;
    timefrStartStation!: string | undefined;
    timefrPrviousStation!: string | undefined;
    timeSpendonStation!: string | undefined;
    tripActualID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITripActualRoutes_StationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routesID = data["routesID"];
            this.stationCode = data["stationCode"];
            this.stationOrder = data["stationOrder"];
            this.distanceFStart = data["distanceFStart"];
            this.distanceFPrviousSt = data["distanceFPrviousSt"];
            this.timefrStartStation = data["timefrStartStation"];
            this.timefrPrviousStation = data["timefrPrviousStation"];
            this.timeSpendonStation = data["timeSpendonStation"];
            this.tripActualID = data["tripActualID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripActualRoutes_StationDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripActualRoutes_StationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routesID"] = this.routesID;
        data["stationCode"] = this.stationCode;
        data["stationOrder"] = this.stationOrder;
        data["distanceFStart"] = this.distanceFStart;
        data["distanceFPrviousSt"] = this.distanceFPrviousSt;
        data["timefrStartStation"] = this.timefrStartStation;
        data["timefrPrviousStation"] = this.timefrPrviousStation;
        data["timeSpendonStation"] = this.timeSpendonStation;
        data["tripActualID"] = this.tripActualID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripActualRoutes_StationDto {
    routesID: number | undefined;
    stationCode: number | undefined;
    stationOrder: number | undefined;
    distanceFStart: number | undefined;
    distanceFPrviousSt: number | undefined;
    timefrStartStation: string | undefined;
    timefrPrviousStation: string | undefined;
    timeSpendonStation: string | undefined;
    tripActualID: number | undefined;
    id: number | undefined;
}

export class GetTripActualRoutes_StationForEditOutput implements IGetTripActualRoutes_StationForEditOutput {
    tripActualRoutes_Station!: CreateOrEditTripActualRoutes_StationDto | undefined;

    constructor(data?: IGetTripActualRoutes_StationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripActualRoutes_Station = data["tripActualRoutes_Station"] ? CreateOrEditTripActualRoutes_StationDto.fromJS(data["tripActualRoutes_Station"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripActualRoutes_StationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripActualRoutes_StationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripActualRoutes_Station"] = this.tripActualRoutes_Station ? this.tripActualRoutes_Station.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripActualRoutes_StationForEditOutput {
    tripActualRoutes_Station: CreateOrEditTripActualRoutes_StationDto | undefined;
}

export class CreateOrEditTripActualRoutes_StationDto implements ICreateOrEditTripActualRoutes_StationDto {
    routesID!: number | undefined;
    stationCode!: number | undefined;
    stationOrder!: number | undefined;
    distanceFStart!: number | undefined;
    distanceFPrviousSt!: number | undefined;
    timefrStartStation!: string | undefined;
    timefrPrviousStation!: string | undefined;
    timeSpendonStation!: string | undefined;
    tripActualID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripActualRoutes_StationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routesID = data["routesID"];
            this.stationCode = data["stationCode"];
            this.stationOrder = data["stationOrder"];
            this.distanceFStart = data["distanceFStart"];
            this.distanceFPrviousSt = data["distanceFPrviousSt"];
            this.timefrStartStation = data["timefrStartStation"];
            this.timefrPrviousStation = data["timefrPrviousStation"];
            this.timeSpendonStation = data["timeSpendonStation"];
            this.tripActualID = data["tripActualID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripActualRoutes_StationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripActualRoutes_StationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routesID"] = this.routesID;
        data["stationCode"] = this.stationCode;
        data["stationOrder"] = this.stationOrder;
        data["distanceFStart"] = this.distanceFStart;
        data["distanceFPrviousSt"] = this.distanceFPrviousSt;
        data["timefrStartStation"] = this.timefrStartStation;
        data["timefrPrviousStation"] = this.timefrPrviousStation;
        data["timeSpendonStation"] = this.timeSpendonStation;
        data["tripActualID"] = this.tripActualID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripActualRoutes_StationDto {
    routesID: number | undefined;
    stationCode: number | undefined;
    stationOrder: number | undefined;
    distanceFStart: number | undefined;
    distanceFPrviousSt: number | undefined;
    timefrStartStation: string | undefined;
    timefrPrviousStation: string | undefined;
    timeSpendonStation: string | undefined;
    tripActualID: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetTripActualWitHDriverForView implements IPagedResultDtoOfGetTripActualWitHDriverForView {
    totalCount!: number | undefined;
    items!: GetTripActualWitHDriverForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripActualWitHDriverForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripActualWitHDriverForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripActualWitHDriverForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripActualWitHDriverForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripActualWitHDriverForView {
    totalCount: number | undefined;
    items: GetTripActualWitHDriverForView[] | undefined;
}

export class GetTripActualWitHDriverForView implements IGetTripActualWitHDriverForView {
    tripActualWitHDriver!: TripActualWitHDriverDto | undefined;

    constructor(data?: IGetTripActualWitHDriverForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripActualWitHDriver = data["tripActualWitHDriver"] ? TripActualWitHDriverDto.fromJS(data["tripActualWitHDriver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripActualWitHDriverForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripActualWitHDriverForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripActualWitHDriver"] = this.tripActualWitHDriver ? this.tripActualWitHDriver.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripActualWitHDriverForView {
    tripActualWitHDriver: TripActualWitHDriverDto | undefined;
}

export class TripActualWitHDriverDto implements ITripActualWitHDriverDto {
    tripPlanID!: number | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    taskNo!: number | undefined;
    tripDate!: moment.Moment | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    totalHour!: number | undefined;
    tripLength!: number | undefined;
    tripActualID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITripActualWitHDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanID = data["tripPlanID"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.taskNo = data["taskNo"];
            this.tripDate = data["tripDate"] ? moment(data["tripDate"].toString()) : <any>undefined;
            this.startTime = data["startTime"];
            this.endTime = data["endTime"];
            this.totalHour = data["totalHour"];
            this.tripLength = data["tripLength"];
            this.tripActualID = data["tripActualID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripActualWitHDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripActualWitHDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanID"] = this.tripPlanID;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["taskNo"] = this.taskNo;
        data["tripDate"] = this.tripDate ? this.tripDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["totalHour"] = this.totalHour;
        data["tripLength"] = this.tripLength;
        data["tripActualID"] = this.tripActualID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripActualWitHDriverDto {
    tripPlanID: number | undefined;
    driver: number | undefined;
    busID: number | undefined;
    taskNo: number | undefined;
    tripDate: moment.Moment | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    totalHour: number | undefined;
    tripLength: number | undefined;
    tripActualID: number | undefined;
    id: number | undefined;
}

export class GetTripActualWitHDriverForEditOutput implements IGetTripActualWitHDriverForEditOutput {
    tripActualWitHDriver!: CreateOrEditTripActualWitHDriverDto | undefined;

    constructor(data?: IGetTripActualWitHDriverForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripActualWitHDriver = data["tripActualWitHDriver"] ? CreateOrEditTripActualWitHDriverDto.fromJS(data["tripActualWitHDriver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripActualWitHDriverForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripActualWitHDriverForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripActualWitHDriver"] = this.tripActualWitHDriver ? this.tripActualWitHDriver.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripActualWitHDriverForEditOutput {
    tripActualWitHDriver: CreateOrEditTripActualWitHDriverDto | undefined;
}

export class CreateOrEditTripActualWitHDriverDto implements ICreateOrEditTripActualWitHDriverDto {
    tripPlanID!: number | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    taskNo!: number | undefined;
    tripDate!: moment.Moment | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    totalHour!: number | undefined;
    tripLength!: number | undefined;
    tripActualID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripActualWitHDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanID = data["tripPlanID"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.taskNo = data["taskNo"];
            this.tripDate = data["tripDate"] ? moment(data["tripDate"].toString()) : <any>undefined;
            this.startTime = data["startTime"];
            this.endTime = data["endTime"];
            this.totalHour = data["totalHour"];
            this.tripLength = data["tripLength"];
            this.tripActualID = data["tripActualID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripActualWitHDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripActualWitHDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanID"] = this.tripPlanID;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["taskNo"] = this.taskNo;
        data["tripDate"] = this.tripDate ? this.tripDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["totalHour"] = this.totalHour;
        data["tripLength"] = this.tripLength;
        data["tripActualID"] = this.tripActualID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripActualWitHDriverDto {
    tripPlanID: number | undefined;
    driver: number | undefined;
    busID: number | undefined;
    taskNo: number | undefined;
    tripDate: moment.Moment | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    totalHour: number | undefined;
    tripLength: number | undefined;
    tripActualID: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetTripByMinistryForView implements IPagedResultDtoOfGetTripByMinistryForView {
    totalCount!: number | undefined;
    items!: GetTripByMinistryForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripByMinistryForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripByMinistryForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripByMinistryForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripByMinistryForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripByMinistryForView {
    totalCount: number | undefined;
    items: GetTripByMinistryForView[] | undefined;
}

export class GetTripByMinistryForView implements IGetTripByMinistryForView {
    tripByMinistry!: TripByMinistryDto | undefined;
    routeLineNumber!: string | undefined;
    calenderBusTenantId!: string | undefined;

    constructor(data?: IGetTripByMinistryForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripByMinistry = data["tripByMinistry"] ? TripByMinistryDto.fromJS(data["tripByMinistry"]) : <any>undefined;
            this.routeLineNumber = data["routeLineNumber"];
            this.calenderBusTenantId = data["calenderBusTenantId"];
        }
    }

    static fromJS(data: any): GetTripByMinistryForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripByMinistryForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripByMinistry"] = this.tripByMinistry ? this.tripByMinistry.toJSON() : <any>undefined;
        data["routeLineNumber"] = this.routeLineNumber;
        data["calenderBusTenantId"] = this.calenderBusTenantId;
        return data; 
    }
}

export interface IGetTripByMinistryForView {
    tripByMinistry: TripByMinistryDto | undefined;
    routeLineNumber: string | undefined;
    calenderBusTenantId: string | undefined;
}

export class TripByMinistryDto implements ITripByMinistryDto {
    timeSpan!: moment.Moment | undefined;
    timeSpanEnd!: moment.Moment | undefined;
    routeId!: number | undefined;
    calenderBusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITripByMinistryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeSpan = data["timeSpan"] ? moment(data["timeSpan"].toString()) : <any>undefined;
            this.timeSpanEnd = data["timeSpanEnd"] ? moment(data["timeSpanEnd"].toString()) : <any>undefined;
            this.routeId = data["routeId"];
            this.calenderBusId = data["calenderBusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripByMinistryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripByMinistryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpan"] = this.timeSpan ? this.timeSpan.toISOString() : <any>undefined;
        data["timeSpanEnd"] = this.timeSpanEnd ? this.timeSpanEnd.toISOString() : <any>undefined;
        data["routeId"] = this.routeId;
        data["calenderBusId"] = this.calenderBusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripByMinistryDto {
    timeSpan: moment.Moment | undefined;
    timeSpanEnd: moment.Moment | undefined;
    routeId: number | undefined;
    calenderBusId: number | undefined;
    id: number | undefined;
}

export class GetTripByMinistryForEditOutput implements IGetTripByMinistryForEditOutput {
    tripByMinistry!: CreateOrEditTripByMinistryDto | undefined;
    routeLineNumber!: string | undefined;
    calenderBusTenantId!: string | undefined;

    constructor(data?: IGetTripByMinistryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripByMinistry = data["tripByMinistry"] ? CreateOrEditTripByMinistryDto.fromJS(data["tripByMinistry"]) : <any>undefined;
            this.routeLineNumber = data["routeLineNumber"];
            this.calenderBusTenantId = data["calenderBusTenantId"];
        }
    }

    static fromJS(data: any): GetTripByMinistryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripByMinistryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripByMinistry"] = this.tripByMinistry ? this.tripByMinistry.toJSON() : <any>undefined;
        data["routeLineNumber"] = this.routeLineNumber;
        data["calenderBusTenantId"] = this.calenderBusTenantId;
        return data; 
    }
}

export interface IGetTripByMinistryForEditOutput {
    tripByMinistry: CreateOrEditTripByMinistryDto | undefined;
    routeLineNumber: string | undefined;
    calenderBusTenantId: string | undefined;
}

export class CreateOrEditTripByMinistryDto implements ICreateOrEditTripByMinistryDto {
    timeSpan!: moment.Moment | undefined;
    timeSpanEnd!: moment.Moment | undefined;
    routeId!: number | undefined;
    calenderBusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripByMinistryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeSpan = data["timeSpan"] ? moment(data["timeSpan"].toString()) : <any>undefined;
            this.timeSpanEnd = data["timeSpanEnd"] ? moment(data["timeSpanEnd"].toString()) : <any>undefined;
            this.routeId = data["routeId"];
            this.calenderBusId = data["calenderBusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripByMinistryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripByMinistryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSpan"] = this.timeSpan ? this.timeSpan.toISOString() : <any>undefined;
        data["timeSpanEnd"] = this.timeSpanEnd ? this.timeSpanEnd.toISOString() : <any>undefined;
        data["routeId"] = this.routeId;
        data["calenderBusId"] = this.calenderBusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripByMinistryDto {
    timeSpan: moment.Moment | undefined;
    timeSpanEnd: moment.Moment | undefined;
    routeId: number | undefined;
    calenderBusId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetTripPlanedDailyWitHDriverForView implements IPagedResultDtoOfGetTripPlanedDailyWitHDriverForView {
    totalCount!: number | undefined;
    items!: GetTripPlanedDailyWitHDriverForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripPlanedDailyWitHDriverForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripPlanedDailyWitHDriverForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripPlanedDailyWitHDriverForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripPlanedDailyWitHDriverForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripPlanedDailyWitHDriverForView {
    totalCount: number | undefined;
    items: GetTripPlanedDailyWitHDriverForView[] | undefined;
}

export class GetTripPlanedDailyWitHDriverForView implements IGetTripPlanedDailyWitHDriverForView {
    tripPlanedDailyWitHDriver!: TripPlanedDailyWitHDriverDto | undefined;

    constructor(data?: IGetTripPlanedDailyWitHDriverForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanedDailyWitHDriver = data["tripPlanedDailyWitHDriver"] ? TripPlanedDailyWitHDriverDto.fromJS(data["tripPlanedDailyWitHDriver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripPlanedDailyWitHDriverForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripPlanedDailyWitHDriverForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanedDailyWitHDriver"] = this.tripPlanedDailyWitHDriver ? this.tripPlanedDailyWitHDriver.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripPlanedDailyWitHDriverForView {
    tripPlanedDailyWitHDriver: TripPlanedDailyWitHDriverDto | undefined;
}

export class TripPlanedDailyWitHDriverDto implements ITripPlanedDailyWitHDriverDto {
    tripPlanID!: number | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    taskNo!: number | undefined;
    workingday!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ITripPlanedDailyWitHDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanID = data["tripPlanID"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.taskNo = data["taskNo"];
            this.workingday = data["workingday"] ? moment(data["workingday"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripPlanedDailyWitHDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripPlanedDailyWitHDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanID"] = this.tripPlanID;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["taskNo"] = this.taskNo;
        data["workingday"] = this.workingday ? this.workingday.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripPlanedDailyWitHDriverDto {
    tripPlanID: number | undefined;
    driver: number | undefined;
    busID: number | undefined;
    taskNo: number | undefined;
    workingday: moment.Moment | undefined;
    id: number | undefined;
}

export class GetTripPlanedDailyWitHDriverForEditOutput implements IGetTripPlanedDailyWitHDriverForEditOutput {
    tripPlanedDailyWitHDriver!: CreateOrEditTripPlanedDailyWitHDriverDto | undefined;

    constructor(data?: IGetTripPlanedDailyWitHDriverForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanedDailyWitHDriver = data["tripPlanedDailyWitHDriver"] ? CreateOrEditTripPlanedDailyWitHDriverDto.fromJS(data["tripPlanedDailyWitHDriver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripPlanedDailyWitHDriverForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripPlanedDailyWitHDriverForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanedDailyWitHDriver"] = this.tripPlanedDailyWitHDriver ? this.tripPlanedDailyWitHDriver.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripPlanedDailyWitHDriverForEditOutput {
    tripPlanedDailyWitHDriver: CreateOrEditTripPlanedDailyWitHDriverDto | undefined;
}

export class CreateOrEditTripPlanedDailyWitHDriverDto implements ICreateOrEditTripPlanedDailyWitHDriverDto {
    tripPlanID!: number | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    taskNo!: number | undefined;
    workingday!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripPlanedDailyWitHDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanID = data["tripPlanID"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.taskNo = data["taskNo"];
            this.workingday = data["workingday"] ? moment(data["workingday"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripPlanedDailyWitHDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripPlanedDailyWitHDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanID"] = this.tripPlanID;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["taskNo"] = this.taskNo;
        data["workingday"] = this.workingday ? this.workingday.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripPlanedDailyWitHDriverDto {
    tripPlanID: number | undefined;
    driver: number | undefined;
    busID: number | undefined;
    taskNo: number | undefined;
    workingday: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetTripPlanedForView implements IPagedResultDtoOfGetTripPlanedForView {
    totalCount!: number | undefined;
    items!: GetTripPlanedForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripPlanedForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripPlanedForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripPlanedForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripPlanedForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripPlanedForView {
    totalCount: number | undefined;
    items: GetTripPlanedForView[] | undefined;
}

export class GetTripPlanedForView implements IGetTripPlanedForView {
    tripPlaned!: TripPlanedDto | undefined;
    tripTypeName!: string | undefined;

    constructor(data?: IGetTripPlanedForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlaned = data["tripPlaned"] ? TripPlanedDto.fromJS(data["tripPlaned"]) : <any>undefined;
            this.tripTypeName = data["tripTypeName"];
        }
    }

    static fromJS(data: any): GetTripPlanedForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripPlanedForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlaned"] = this.tripPlaned ? this.tripPlaned.toJSON() : <any>undefined;
        data["tripTypeName"] = this.tripTypeName;
        return data; 
    }
}

export interface IGetTripPlanedForView {
    tripPlaned: TripPlanedDto | undefined;
    tripTypeName: string | undefined;
}

export class TripPlanedDto implements ITripPlanedDto {
    calenderID!: number | undefined;
    routeID!: number | undefined;
    timeSpan!: string | undefined;
    tripMinistry!: number | undefined;
    isValid!: boolean | undefined;
    endTimeSpan!: string | undefined;
    tripTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITripPlanedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calenderID = data["calenderID"];
            this.routeID = data["routeID"];
            this.timeSpan = data["timeSpan"];
            this.tripMinistry = data["tripMinistry"];
            this.isValid = data["isValid"];
            this.endTimeSpan = data["endTimeSpan"];
            this.tripTypeId = data["tripTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripPlanedDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripPlanedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calenderID"] = this.calenderID;
        data["routeID"] = this.routeID;
        data["timeSpan"] = this.timeSpan;
        data["tripMinistry"] = this.tripMinistry;
        data["isValid"] = this.isValid;
        data["endTimeSpan"] = this.endTimeSpan;
        data["tripTypeId"] = this.tripTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripPlanedDto {
    calenderID: number | undefined;
    routeID: number | undefined;
    timeSpan: string | undefined;
    tripMinistry: number | undefined;
    isValid: boolean | undefined;
    endTimeSpan: string | undefined;
    tripTypeId: number | undefined;
    id: number | undefined;
}

export class GetTripPlanedForEditOutput implements IGetTripPlanedForEditOutput {
    tripPlaned!: CreateOrEditTripPlanedDto | undefined;
    tripTypeName!: string | undefined;

    constructor(data?: IGetTripPlanedForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlaned = data["tripPlaned"] ? CreateOrEditTripPlanedDto.fromJS(data["tripPlaned"]) : <any>undefined;
            this.tripTypeName = data["tripTypeName"];
        }
    }

    static fromJS(data: any): GetTripPlanedForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripPlanedForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlaned"] = this.tripPlaned ? this.tripPlaned.toJSON() : <any>undefined;
        data["tripTypeName"] = this.tripTypeName;
        return data; 
    }
}

export interface IGetTripPlanedForEditOutput {
    tripPlaned: CreateOrEditTripPlanedDto | undefined;
    tripTypeName: string | undefined;
}

export class CreateOrEditTripPlanedDto implements ICreateOrEditTripPlanedDto {
    calenderID!: number | undefined;
    routeID!: number | undefined;
    timeSpan!: string | undefined;
    tripMinistry!: number | undefined;
    isValid!: boolean | undefined;
    endTimeSpan!: string | undefined;
    tripTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripPlanedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.calenderID = data["calenderID"];
            this.routeID = data["routeID"];
            this.timeSpan = data["timeSpan"];
            this.tripMinistry = data["tripMinistry"];
            this.isValid = data["isValid"];
            this.endTimeSpan = data["endTimeSpan"];
            this.tripTypeId = data["tripTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripPlanedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripPlanedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["calenderID"] = this.calenderID;
        data["routeID"] = this.routeID;
        data["timeSpan"] = this.timeSpan;
        data["tripMinistry"] = this.tripMinistry;
        data["isValid"] = this.isValid;
        data["endTimeSpan"] = this.endTimeSpan;
        data["tripTypeId"] = this.tripTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripPlanedDto {
    calenderID: number | undefined;
    routeID: number | undefined;
    timeSpan: string | undefined;
    tripMinistry: number | undefined;
    isValid: boolean | undefined;
    endTimeSpan: string | undefined;
    tripTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTripTypeLookupTableDto implements IPagedResultDtoOfTripTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: TripTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTripTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TripTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTripTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTripTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTripTypeLookupTableDto {
    totalCount: number | undefined;
    items: TripTypeLookupTableDto[] | undefined;
}

export class TripTypeLookupTableDto implements ITripTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ITripTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TripTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ITripTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetTripPlanedWitHDriverForView implements IPagedResultDtoOfGetTripPlanedWitHDriverForView {
    totalCount!: number | undefined;
    items!: GetTripPlanedWitHDriverForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripPlanedWitHDriverForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripPlanedWitHDriverForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripPlanedWitHDriverForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripPlanedWitHDriverForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripPlanedWitHDriverForView {
    totalCount: number | undefined;
    items: GetTripPlanedWitHDriverForView[] | undefined;
}

export class GetTripPlanedWitHDriverForView implements IGetTripPlanedWitHDriverForView {
    tripPlanedWitHDriver!: TripPlanedWitHDriverDto | undefined;

    constructor(data?: IGetTripPlanedWitHDriverForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanedWitHDriver = data["tripPlanedWitHDriver"] ? TripPlanedWitHDriverDto.fromJS(data["tripPlanedWitHDriver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripPlanedWitHDriverForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripPlanedWitHDriverForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanedWitHDriver"] = this.tripPlanedWitHDriver ? this.tripPlanedWitHDriver.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripPlanedWitHDriverForView {
    tripPlanedWitHDriver: TripPlanedWitHDriverDto | undefined;
}

export class TripPlanedWitHDriverDto implements ITripPlanedWitHDriverDto {
    tripPlanID!: number | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    taskNo!: number | undefined;
    notes!: string | undefined;
    busGroup!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITripPlanedWitHDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanID = data["tripPlanID"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.taskNo = data["taskNo"];
            this.notes = data["notes"];
            this.busGroup = data["busGroup"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripPlanedWitHDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripPlanedWitHDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanID"] = this.tripPlanID;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["taskNo"] = this.taskNo;
        data["notes"] = this.notes;
        data["busGroup"] = this.busGroup;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripPlanedWitHDriverDto {
    tripPlanID: number | undefined;
    driver: number | undefined;
    busID: number | undefined;
    taskNo: number | undefined;
    notes: string | undefined;
    busGroup: string | undefined;
    id: number | undefined;
}

export class GetTripPlanedWitHDriverForEditOutput implements IGetTripPlanedWitHDriverForEditOutput {
    tripPlanedWitHDriver!: CreateOrEditTripPlanedWitHDriverDto | undefined;

    constructor(data?: IGetTripPlanedWitHDriverForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanedWitHDriver = data["tripPlanedWitHDriver"] ? CreateOrEditTripPlanedWitHDriverDto.fromJS(data["tripPlanedWitHDriver"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripPlanedWitHDriverForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripPlanedWitHDriverForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanedWitHDriver"] = this.tripPlanedWitHDriver ? this.tripPlanedWitHDriver.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripPlanedWitHDriverForEditOutput {
    tripPlanedWitHDriver: CreateOrEditTripPlanedWitHDriverDto | undefined;
}

export class CreateOrEditTripPlanedWitHDriverDto implements ICreateOrEditTripPlanedWitHDriverDto {
    tripPlanID!: number | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    taskNo!: number | undefined;
    notes!: string | undefined;
    busGroup!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripPlanedWitHDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripPlanID = data["tripPlanID"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.taskNo = data["taskNo"];
            this.notes = data["notes"];
            this.busGroup = data["busGroup"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripPlanedWitHDriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripPlanedWitHDriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripPlanID"] = this.tripPlanID;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["taskNo"] = this.taskNo;
        data["notes"] = this.notes;
        data["busGroup"] = this.busGroup;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripPlanedWitHDriverDto {
    tripPlanID: number | undefined;
    driver: number | undefined;
    busID: number | undefined;
    taskNo: number | undefined;
    notes: string | undefined;
    busGroup: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetTripTypeForView implements IPagedResultDtoOfGetTripTypeForView {
    totalCount!: number | undefined;
    items!: GetTripTypeForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTripTypeForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTripTypeForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTripTypeForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTripTypeForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetTripTypeForView {
    totalCount: number | undefined;
    items: GetTripTypeForView[] | undefined;
}

export class GetTripTypeForView implements IGetTripTypeForView {
    tripType!: TripTypeDto | undefined;

    constructor(data?: IGetTripTypeForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripType = data["tripType"] ? TripTypeDto.fromJS(data["tripType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripTypeForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripTypeForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripType"] = this.tripType ? this.tripType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripTypeForView {
    tripType: TripTypeDto | undefined;
}

export class TripTypeDto implements ITripTypeDto {
    name!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITripTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TripTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TripTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITripTypeDto {
    name: string | undefined;
    id: number | undefined;
}

export class GetTripTypeForEditOutput implements IGetTripTypeForEditOutput {
    tripType!: CreateOrEditTripTypeDto | undefined;

    constructor(data?: IGetTripTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripType = data["tripType"] ? CreateOrEditTripTypeDto.fromJS(data["tripType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTripTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTripTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripType"] = this.tripType ? this.tripType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetTripTypeForEditOutput {
    tripType: CreateOrEditTripTypeDto | undefined;
}

export class CreateOrEditTripTypeDto implements ICreateOrEditTripTypeDto {
    name!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTripTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTripTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTripTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditTripTypeDto {
    name: string;
    id: number | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class PagedResultDtoOfGetVechileGpsForViewDto implements IPagedResultDtoOfGetVechileGpsForViewDto {
    totalCount!: number | undefined;
    items!: GetVechileGpsForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVechileGpsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVechileGpsForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVechileGpsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVechileGpsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVechileGpsForViewDto {
    totalCount: number | undefined;
    items: GetVechileGpsForViewDto[] | undefined;
}

export class GetVechileGpsForViewDto implements IGetVechileGpsForViewDto {
    vechileGps!: VechileGpsDto | undefined;

    constructor(data?: IGetVechileGpsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vechileGps = data["vechileGps"] ? VechileGpsDto.fromJS(data["vechileGps"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVechileGpsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVechileGpsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vechileGps"] = this.vechileGps ? this.vechileGps.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVechileGpsForViewDto {
    vechileGps: VechileGpsDto | undefined;
}

export class VechileGpsDto implements IVechileGpsDto {
    vechileID!: number | undefined;
    latitude!: number | undefined;
    longitude!: number | undefined;
    angle!: number | undefined;
    locationDateTime!: moment.Moment | undefined;
    satellites!: number | undefined;
    hdop!: number | undefined;
    created!: moment.Moment | undefined;
    modified!: moment.Moment | undefined;
    gpsSpeed!: number | undefined;
    speed!: number | undefined;
    bearing!: number | undefined;
    vehicleNumber!: number | undefined;
    id!: number | undefined;

    constructor(data?: IVechileGpsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vechileID = data["vechileID"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.angle = data["angle"];
            this.locationDateTime = data["locationDateTime"] ? moment(data["locationDateTime"].toString()) : <any>undefined;
            this.satellites = data["satellites"];
            this.hdop = data["hdop"];
            this.created = data["created"] ? moment(data["created"].toString()) : <any>undefined;
            this.modified = data["modified"] ? moment(data["modified"].toString()) : <any>undefined;
            this.gpsSpeed = data["gpsSpeed"];
            this.speed = data["speed"];
            this.bearing = data["bearing"];
            this.vehicleNumber = data["vehicleNumber"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VechileGpsDto {
        data = typeof data === 'object' ? data : {};
        let result = new VechileGpsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vechileID"] = this.vechileID;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["angle"] = this.angle;
        data["locationDateTime"] = this.locationDateTime ? this.locationDateTime.toISOString() : <any>undefined;
        data["satellites"] = this.satellites;
        data["hdop"] = this.hdop;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["gpsSpeed"] = this.gpsSpeed;
        data["speed"] = this.speed;
        data["bearing"] = this.bearing;
        data["vehicleNumber"] = this.vehicleNumber;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVechileGpsDto {
    vechileID: number | undefined;
    latitude: number | undefined;
    longitude: number | undefined;
    angle: number | undefined;
    locationDateTime: moment.Moment | undefined;
    satellites: number | undefined;
    hdop: number | undefined;
    created: moment.Moment | undefined;
    modified: moment.Moment | undefined;
    gpsSpeed: number | undefined;
    speed: number | undefined;
    bearing: number | undefined;
    vehicleNumber: number | undefined;
    id: number | undefined;
}

export class GetVechileGpsForEditOutput implements IGetVechileGpsForEditOutput {
    vechileGps!: CreateOrEditVechileGpsDto | undefined;

    constructor(data?: IGetVechileGpsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vechileGps = data["vechileGps"] ? CreateOrEditVechileGpsDto.fromJS(data["vechileGps"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVechileGpsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVechileGpsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vechileGps"] = this.vechileGps ? this.vechileGps.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVechileGpsForEditOutput {
    vechileGps: CreateOrEditVechileGpsDto | undefined;
}

export class CreateOrEditVechileGpsDto implements ICreateOrEditVechileGpsDto {
    vechileID!: number;
    latitude!: number;
    longitude!: number;
    angle!: number;
    locationDateTime!: moment.Moment;
    satellites!: number | undefined;
    hdop!: number | undefined;
    created!: moment.Moment;
    modified!: moment.Moment;
    gpsSpeed!: number | undefined;
    speed!: number | undefined;
    bearing!: number | undefined;
    vehicleNumber!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVechileGpsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vechileID = data["vechileID"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.angle = data["angle"];
            this.locationDateTime = data["locationDateTime"] ? moment(data["locationDateTime"].toString()) : <any>undefined;
            this.satellites = data["satellites"];
            this.hdop = data["hdop"];
            this.created = data["created"] ? moment(data["created"].toString()) : <any>undefined;
            this.modified = data["modified"] ? moment(data["modified"].toString()) : <any>undefined;
            this.gpsSpeed = data["gpsSpeed"];
            this.speed = data["speed"];
            this.bearing = data["bearing"];
            this.vehicleNumber = data["vehicleNumber"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVechileGpsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVechileGpsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vechileID"] = this.vechileID;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["angle"] = this.angle;
        data["locationDateTime"] = this.locationDateTime ? this.locationDateTime.toISOString() : <any>undefined;
        data["satellites"] = this.satellites;
        data["hdop"] = this.hdop;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        data["gpsSpeed"] = this.gpsSpeed;
        data["speed"] = this.speed;
        data["bearing"] = this.bearing;
        data["vehicleNumber"] = this.vehicleNumber;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVechileGpsDto {
    vechileID: number;
    latitude: number;
    longitude: number;
    angle: number;
    locationDateTime: moment.Moment;
    satellites: number | undefined;
    hdop: number | undefined;
    created: moment.Moment;
    modified: moment.Moment;
    gpsSpeed: number | undefined;
    speed: number | undefined;
    bearing: number | undefined;
    vehicleNumber: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetVehiclesForViewDto implements IPagedResultDtoOfGetVehiclesForViewDto {
    totalCount!: number | undefined;
    items!: GetVehiclesForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVehiclesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVehiclesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVehiclesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVehiclesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVehiclesForViewDto {
    totalCount: number | undefined;
    items: GetVehiclesForViewDto[] | undefined;
}

export class GetVehiclesForViewDto implements IGetVehiclesForViewDto {
    vehicles!: VehiclesDto | undefined;
    vehiclesTypeTypeDescription!: string | undefined;

    constructor(data?: IGetVehiclesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vehicles = data["vehicles"] ? VehiclesDto.fromJS(data["vehicles"]) : <any>undefined;
            this.vehiclesTypeTypeDescription = data["vehiclesTypeTypeDescription"];
        }
    }

    static fromJS(data: any): GetVehiclesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehiclesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicles"] = this.vehicles ? this.vehicles.toJSON() : <any>undefined;
        data["vehiclesTypeTypeDescription"] = this.vehiclesTypeTypeDescription;
        return data; 
    }
}

export interface IGetVehiclesForViewDto {
    vehicles: VehiclesDto | undefined;
    vehiclesTypeTypeDescription: string | undefined;
}

export class VehiclesDto implements IVehiclesDto {
    internalID!: number | undefined;
    vehicleNumber!: number | undefined;
    shortVehicleNumber!: number | undefined;
    vehicleType!: number | undefined;
    status!: number | undefined;
    statusDate!: moment.Moment | undefined;
    parking!: number | undefined;
    garage!: number | undefined;
    km!: number | undefined;
    testDate!: moment.Moment | undefined;
    insuranceDate!: moment.Moment | undefined;
    lastHandleDate!: moment.Moment | undefined;
    nextHandleDate!: moment.Moment | undefined;
    updated!: moment.Moment | undefined;
    operatorID!: number | undefined;
    isBusInTrip!: number | undefined;
    isBusInTripLastUpdated!: moment.Moment | undefined;
    vehiclesTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IVehiclesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.internalID = data["internalID"];
            this.vehicleNumber = data["vehicleNumber"];
            this.shortVehicleNumber = data["shortVehicleNumber"];
            this.vehicleType = data["vehicleType"];
            this.status = data["status"];
            this.statusDate = data["statusDate"] ? moment(data["statusDate"].toString()) : <any>undefined;
            this.parking = data["parking"];
            this.garage = data["garage"];
            this.km = data["km"];
            this.testDate = data["testDate"] ? moment(data["testDate"].toString()) : <any>undefined;
            this.insuranceDate = data["insuranceDate"] ? moment(data["insuranceDate"].toString()) : <any>undefined;
            this.lastHandleDate = data["lastHandleDate"] ? moment(data["lastHandleDate"].toString()) : <any>undefined;
            this.nextHandleDate = data["nextHandleDate"] ? moment(data["nextHandleDate"].toString()) : <any>undefined;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>undefined;
            this.operatorID = data["operatorID"];
            this.isBusInTrip = data["isBusInTrip"];
            this.isBusInTripLastUpdated = data["isBusInTripLastUpdated"] ? moment(data["isBusInTripLastUpdated"].toString()) : <any>undefined;
            this.vehiclesTypeId = data["vehiclesTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VehiclesDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehiclesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalID"] = this.internalID;
        data["vehicleNumber"] = this.vehicleNumber;
        data["shortVehicleNumber"] = this.shortVehicleNumber;
        data["vehicleType"] = this.vehicleType;
        data["status"] = this.status;
        data["statusDate"] = this.statusDate ? this.statusDate.toISOString() : <any>undefined;
        data["parking"] = this.parking;
        data["garage"] = this.garage;
        data["km"] = this.km;
        data["testDate"] = this.testDate ? this.testDate.toISOString() : <any>undefined;
        data["insuranceDate"] = this.insuranceDate ? this.insuranceDate.toISOString() : <any>undefined;
        data["lastHandleDate"] = this.lastHandleDate ? this.lastHandleDate.toISOString() : <any>undefined;
        data["nextHandleDate"] = this.nextHandleDate ? this.nextHandleDate.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["operatorID"] = this.operatorID;
        data["isBusInTrip"] = this.isBusInTrip;
        data["isBusInTripLastUpdated"] = this.isBusInTripLastUpdated ? this.isBusInTripLastUpdated.toISOString() : <any>undefined;
        data["vehiclesTypeId"] = this.vehiclesTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVehiclesDto {
    internalID: number | undefined;
    vehicleNumber: number | undefined;
    shortVehicleNumber: number | undefined;
    vehicleType: number | undefined;
    status: number | undefined;
    statusDate: moment.Moment | undefined;
    parking: number | undefined;
    garage: number | undefined;
    km: number | undefined;
    testDate: moment.Moment | undefined;
    insuranceDate: moment.Moment | undefined;
    lastHandleDate: moment.Moment | undefined;
    nextHandleDate: moment.Moment | undefined;
    updated: moment.Moment | undefined;
    operatorID: number | undefined;
    isBusInTrip: number | undefined;
    isBusInTripLastUpdated: moment.Moment | undefined;
    vehiclesTypeId: number | undefined;
    id: number | undefined;
}

export class GetVehiclesForEditOutput implements IGetVehiclesForEditOutput {
    vehicles!: CreateOrEditVehiclesDto | undefined;
    vehiclesTypeTypeDescription!: string | undefined;

    constructor(data?: IGetVehiclesForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vehicles = data["vehicles"] ? CreateOrEditVehiclesDto.fromJS(data["vehicles"]) : <any>undefined;
            this.vehiclesTypeTypeDescription = data["vehiclesTypeTypeDescription"];
        }
    }

    static fromJS(data: any): GetVehiclesForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehiclesForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicles"] = this.vehicles ? this.vehicles.toJSON() : <any>undefined;
        data["vehiclesTypeTypeDescription"] = this.vehiclesTypeTypeDescription;
        return data; 
    }
}

export interface IGetVehiclesForEditOutput {
    vehicles: CreateOrEditVehiclesDto | undefined;
    vehiclesTypeTypeDescription: string | undefined;
}

export class CreateOrEditVehiclesDto implements ICreateOrEditVehiclesDto {
    internalID!: number;
    vehicleNumber!: number;
    shortVehicleNumber!: number | undefined;
    vehicleType!: number | undefined;
    status!: number;
    statusDate!: moment.Moment | undefined;
    parking!: number | undefined;
    garage!: number | undefined;
    km!: number | undefined;
    testDate!: moment.Moment | undefined;
    insuranceDate!: moment.Moment | undefined;
    lastHandleDate!: moment.Moment | undefined;
    nextHandleDate!: moment.Moment | undefined;
    updated!: moment.Moment | undefined;
    operatorID!: number;
    isBusInTrip!: number | undefined;
    isBusInTripLastUpdated!: moment.Moment | undefined;
    vehiclesTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVehiclesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.internalID = data["internalID"];
            this.vehicleNumber = data["vehicleNumber"];
            this.shortVehicleNumber = data["shortVehicleNumber"];
            this.vehicleType = data["vehicleType"];
            this.status = data["status"];
            this.statusDate = data["statusDate"] ? moment(data["statusDate"].toString()) : <any>undefined;
            this.parking = data["parking"];
            this.garage = data["garage"];
            this.km = data["km"];
            this.testDate = data["testDate"] ? moment(data["testDate"].toString()) : <any>undefined;
            this.insuranceDate = data["insuranceDate"] ? moment(data["insuranceDate"].toString()) : <any>undefined;
            this.lastHandleDate = data["lastHandleDate"] ? moment(data["lastHandleDate"].toString()) : <any>undefined;
            this.nextHandleDate = data["nextHandleDate"] ? moment(data["nextHandleDate"].toString()) : <any>undefined;
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>undefined;
            this.operatorID = data["operatorID"];
            this.isBusInTrip = data["isBusInTrip"];
            this.isBusInTripLastUpdated = data["isBusInTripLastUpdated"] ? moment(data["isBusInTripLastUpdated"].toString()) : <any>undefined;
            this.vehiclesTypeId = data["vehiclesTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVehiclesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVehiclesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["internalID"] = this.internalID;
        data["vehicleNumber"] = this.vehicleNumber;
        data["shortVehicleNumber"] = this.shortVehicleNumber;
        data["vehicleType"] = this.vehicleType;
        data["status"] = this.status;
        data["statusDate"] = this.statusDate ? this.statusDate.toISOString() : <any>undefined;
        data["parking"] = this.parking;
        data["garage"] = this.garage;
        data["km"] = this.km;
        data["testDate"] = this.testDate ? this.testDate.toISOString() : <any>undefined;
        data["insuranceDate"] = this.insuranceDate ? this.insuranceDate.toISOString() : <any>undefined;
        data["lastHandleDate"] = this.lastHandleDate ? this.lastHandleDate.toISOString() : <any>undefined;
        data["nextHandleDate"] = this.nextHandleDate ? this.nextHandleDate.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["operatorID"] = this.operatorID;
        data["isBusInTrip"] = this.isBusInTrip;
        data["isBusInTripLastUpdated"] = this.isBusInTripLastUpdated ? this.isBusInTripLastUpdated.toISOString() : <any>undefined;
        data["vehiclesTypeId"] = this.vehiclesTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVehiclesDto {
    internalID: number;
    vehicleNumber: number;
    shortVehicleNumber: number | undefined;
    vehicleType: number | undefined;
    status: number;
    statusDate: moment.Moment | undefined;
    parking: number | undefined;
    garage: number | undefined;
    km: number | undefined;
    testDate: moment.Moment | undefined;
    insuranceDate: moment.Moment | undefined;
    lastHandleDate: moment.Moment | undefined;
    nextHandleDate: moment.Moment | undefined;
    updated: moment.Moment | undefined;
    operatorID: number;
    isBusInTrip: number | undefined;
    isBusInTripLastUpdated: moment.Moment | undefined;
    vehiclesTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto implements IPagedResultDtoOfVehiclesVehiclesTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: VehiclesVehiclesTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVehiclesVehiclesTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VehiclesVehiclesTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVehiclesVehiclesTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVehiclesVehiclesTypeLookupTableDto {
    totalCount: number | undefined;
    items: VehiclesVehiclesTypeLookupTableDto[] | undefined;
}

export class VehiclesVehiclesTypeLookupTableDto implements IVehiclesVehiclesTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVehiclesVehiclesTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VehiclesVehiclesTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehiclesVehiclesTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVehiclesVehiclesTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetVehiclesTypeForViewDto implements IPagedResultDtoOfGetVehiclesTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetVehiclesTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVehiclesTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVehiclesTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVehiclesTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVehiclesTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVehiclesTypeForViewDto {
    totalCount: number | undefined;
    items: GetVehiclesTypeForViewDto[] | undefined;
}

export class GetVehiclesTypeForViewDto implements IGetVehiclesTypeForViewDto {
    vehiclesType!: VehiclesTypeDto | undefined;

    constructor(data?: IGetVehiclesTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vehiclesType = data["vehiclesType"] ? VehiclesTypeDto.fromJS(data["vehiclesType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVehiclesTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehiclesTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehiclesType"] = this.vehiclesType ? this.vehiclesType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVehiclesTypeForViewDto {
    vehiclesType: VehiclesTypeDto | undefined;
}

export class VehiclesTypeDto implements IVehiclesTypeDto {
    typeDescription!: string | undefined;
    manufacturer!: number | undefined;
    motorType!: number | undefined;
    passengersCount!: number | undefined;
    doorsCount!: number | undefined;
    doorsTypes!: number | undefined;
    garageFrequencyKM!: number | undefined;
    seatsNumber!: number | undefined;
    noInterurban!: boolean | undefined;
    busType!: number | undefined;
    tiresCount!: number | undefined;
    status!: number | undefined;
    modifiedBy!: number | undefined;
    modificationDate!: moment.Moment | undefined;
    createdBy!: number | undefined;
    creationDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IVehiclesTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeDescription = data["typeDescription"];
            this.manufacturer = data["manufacturer"];
            this.motorType = data["motorType"];
            this.passengersCount = data["passengersCount"];
            this.doorsCount = data["doorsCount"];
            this.doorsTypes = data["doorsTypes"];
            this.garageFrequencyKM = data["garageFrequencyKM"];
            this.seatsNumber = data["seatsNumber"];
            this.noInterurban = data["noInterurban"];
            this.busType = data["busType"];
            this.tiresCount = data["tiresCount"];
            this.status = data["status"];
            this.modifiedBy = data["modifiedBy"];
            this.modificationDate = data["modificationDate"] ? moment(data["modificationDate"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VehiclesTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehiclesTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeDescription"] = this.typeDescription;
        data["manufacturer"] = this.manufacturer;
        data["motorType"] = this.motorType;
        data["passengersCount"] = this.passengersCount;
        data["doorsCount"] = this.doorsCount;
        data["doorsTypes"] = this.doorsTypes;
        data["garageFrequencyKM"] = this.garageFrequencyKM;
        data["seatsNumber"] = this.seatsNumber;
        data["noInterurban"] = this.noInterurban;
        data["busType"] = this.busType;
        data["tiresCount"] = this.tiresCount;
        data["status"] = this.status;
        data["modifiedBy"] = this.modifiedBy;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVehiclesTypeDto {
    typeDescription: string | undefined;
    manufacturer: number | undefined;
    motorType: number | undefined;
    passengersCount: number | undefined;
    doorsCount: number | undefined;
    doorsTypes: number | undefined;
    garageFrequencyKM: number | undefined;
    seatsNumber: number | undefined;
    noInterurban: boolean | undefined;
    busType: number | undefined;
    tiresCount: number | undefined;
    status: number | undefined;
    modifiedBy: number | undefined;
    modificationDate: moment.Moment | undefined;
    createdBy: number | undefined;
    creationDate: moment.Moment | undefined;
    id: number | undefined;
}

export class GetVehiclesTypeForEditOutput implements IGetVehiclesTypeForEditOutput {
    vehiclesType!: CreateOrEditVehiclesTypeDto | undefined;

    constructor(data?: IGetVehiclesTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vehiclesType = data["vehiclesType"] ? CreateOrEditVehiclesTypeDto.fromJS(data["vehiclesType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVehiclesTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVehiclesTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehiclesType"] = this.vehiclesType ? this.vehiclesType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVehiclesTypeForEditOutput {
    vehiclesType: CreateOrEditVehiclesTypeDto | undefined;
}

export class CreateOrEditVehiclesTypeDto implements ICreateOrEditVehiclesTypeDto {
    typeDescription!: string;
    manufacturer!: number;
    motorType!: number | undefined;
    passengersCount!: number | undefined;
    doorsCount!: number | undefined;
    doorsTypes!: number | undefined;
    garageFrequencyKM!: number | undefined;
    seatsNumber!: number | undefined;
    noInterurban!: boolean | undefined;
    busType!: number | undefined;
    tiresCount!: number | undefined;
    status!: number;
    modifiedBy!: number | undefined;
    modificationDate!: moment.Moment | undefined;
    createdBy!: number | undefined;
    creationDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVehiclesTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeDescription = data["typeDescription"];
            this.manufacturer = data["manufacturer"];
            this.motorType = data["motorType"];
            this.passengersCount = data["passengersCount"];
            this.doorsCount = data["doorsCount"];
            this.doorsTypes = data["doorsTypes"];
            this.garageFrequencyKM = data["garageFrequencyKM"];
            this.seatsNumber = data["seatsNumber"];
            this.noInterurban = data["noInterurban"];
            this.busType = data["busType"];
            this.tiresCount = data["tiresCount"];
            this.status = data["status"];
            this.modifiedBy = data["modifiedBy"];
            this.modificationDate = data["modificationDate"] ? moment(data["modificationDate"].toString()) : <any>undefined;
            this.createdBy = data["createdBy"];
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVehiclesTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVehiclesTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeDescription"] = this.typeDescription;
        data["manufacturer"] = this.manufacturer;
        data["motorType"] = this.motorType;
        data["passengersCount"] = this.passengersCount;
        data["doorsCount"] = this.doorsCount;
        data["doorsTypes"] = this.doorsTypes;
        data["garageFrequencyKM"] = this.garageFrequencyKM;
        data["seatsNumber"] = this.seatsNumber;
        data["noInterurban"] = this.noInterurban;
        data["busType"] = this.busType;
        data["tiresCount"] = this.tiresCount;
        data["status"] = this.status;
        data["modifiedBy"] = this.modifiedBy;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVehiclesTypeDto {
    typeDescription: string;
    manufacturer: number;
    motorType: number | undefined;
    passengersCount: number | undefined;
    doorsCount: number | undefined;
    doorsTypes: number | undefined;
    garageFrequencyKM: number | undefined;
    seatsNumber: number | undefined;
    noInterurban: boolean | undefined;
    busType: number | undefined;
    tiresCount: number | undefined;
    status: number;
    modifiedBy: number | undefined;
    modificationDate: moment.Moment | undefined;
    createdBy: number | undefined;
    creationDate: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetViwTripPlanedForView implements IPagedResultDtoOfGetViwTripPlanedForView {
    totalCount!: number | undefined;
    items!: GetViwTripPlanedForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetViwTripPlanedForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetViwTripPlanedForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetViwTripPlanedForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetViwTripPlanedForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetViwTripPlanedForView {
    totalCount: number | undefined;
    items: GetViwTripPlanedForView[] | undefined;
}

export class GetViwTripPlanedForView implements IGetViwTripPlanedForView {
    viwTripPlaned!: ViwTripPlanedDto | undefined;

    constructor(data?: IGetViwTripPlanedForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.viwTripPlaned = data["viwTripPlaned"] ? ViwTripPlanedDto.fromJS(data["viwTripPlaned"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetViwTripPlanedForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetViwTripPlanedForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viwTripPlaned"] = this.viwTripPlaned ? this.viwTripPlaned.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetViwTripPlanedForView {
    viwTripPlaned: ViwTripPlanedDto | undefined;
}

export class ViwTripPlanedDto implements IViwTripPlanedDto {
    trpPlanCalnderID!: number | undefined;
    trpPlanStartTime!: string | undefined;
    trpPlanLineNumber!: number | undefined;
    trpPlanDirection!: number | undefined;
    trpPlanDriverName!: string | undefined;
    trpPlanBusNumber!: string | undefined;
    tripMinistryID!: number | undefined;
    tripMinistryLineNumber!: number | undefined;
    tripMinistryDirection!: number | undefined;
    tripMinistryCalenderID!: number | undefined;
    tripMinistryTimeSpan!: string | undefined;
    tripMinistryMonday!: boolean | undefined;
    tripMinistryTuesday!: boolean | undefined;
    tripMinistryWensday!: boolean | undefined;
    tripMinistryFriday!: boolean | undefined;
    tripMinistryThursday!: boolean | undefined;
    tripMinistrySaturday!: boolean | undefined;
    tripMinistrySunday!: boolean | undefined;
    tripMinistryStart_date!: moment.Moment | undefined;
    tripMinistryRouteID!: number | undefined;
    trpPlanmonday!: boolean | undefined;
    trpPlanTuesday!: boolean | undefined;
    trpPlanWensday!: boolean | undefined;
    trpPlanthursday!: boolean | undefined;
    trpPlanfriday!: boolean | undefined;
    trpPlansaturday!: boolean | undefined;
    trpPlansunday!: boolean | undefined;
    trpPlanStart_date!: moment.Moment | undefined;
    trpPlanEnd_date!: moment.Moment | undefined;
    trpPlanTaskNo!: number | undefined;
    tripPlanedID!: number | undefined;
    driverIDPPlaned!: number | undefined;
    busidPlanlned!: number | undefined;
    trpPlanISValid!: boolean | undefined;
    trpPlanEndTime!: string | undefined;
    trpPlanRouteID!: number | undefined;
    calenderID!: number | undefined;
    viwTripPlanedDaily!: number | undefined;
    catSedor!: string | undefined;
    notes!: string | undefined;
    busGroup!: string | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    id!: number | undefined;

    constructor(data?: IViwTripPlanedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trpPlanCalnderID = data["trpPlanCalnderID"];
            this.trpPlanStartTime = data["trpPlanStartTime"];
            this.trpPlanLineNumber = data["trpPlanLineNumber"];
            this.trpPlanDirection = data["trpPlanDirection"];
            this.trpPlanDriverName = data["trpPlanDriverName"];
            this.trpPlanBusNumber = data["trpPlanBusNumber"];
            this.tripMinistryID = data["tripMinistryID"];
            this.tripMinistryLineNumber = data["tripMinistryLineNumber"];
            this.tripMinistryDirection = data["tripMinistryDirection"];
            this.tripMinistryCalenderID = data["tripMinistryCalenderID"];
            this.tripMinistryTimeSpan = data["tripMinistryTimeSpan"];
            this.tripMinistryMonday = data["tripMinistryMonday"];
            this.tripMinistryTuesday = data["tripMinistryTuesday"];
            this.tripMinistryWensday = data["tripMinistryWensday"];
            this.tripMinistryFriday = data["tripMinistryFriday"];
            this.tripMinistryThursday = data["tripMinistryThursday"];
            this.tripMinistrySaturday = data["tripMinistrySaturday"];
            this.tripMinistrySunday = data["tripMinistrySunday"];
            this.tripMinistryStart_date = data["tripMinistryStart_date"] ? moment(data["tripMinistryStart_date"].toString()) : <any>undefined;
            this.tripMinistryRouteID = data["tripMinistryRouteID"];
            this.trpPlanmonday = data["trpPlanmonday"];
            this.trpPlanTuesday = data["trpPlanTuesday"];
            this.trpPlanWensday = data["trpPlanWensday"];
            this.trpPlanthursday = data["trpPlanthursday"];
            this.trpPlanfriday = data["trpPlanfriday"];
            this.trpPlansaturday = data["trpPlansaturday"];
            this.trpPlansunday = data["trpPlansunday"];
            this.trpPlanStart_date = data["trpPlanStart_date"] ? moment(data["trpPlanStart_date"].toString()) : <any>undefined;
            this.trpPlanEnd_date = data["trpPlanEnd_date"] ? moment(data["trpPlanEnd_date"].toString()) : <any>undefined;
            this.trpPlanTaskNo = data["trpPlanTaskNo"];
            this.tripPlanedID = data["tripPlanedID"];
            this.driverIDPPlaned = data["driverIDPPlaned"];
            this.busidPlanlned = data["busidPlanlned"];
            this.trpPlanISValid = data["trpPlanISValid"];
            this.trpPlanEndTime = data["trpPlanEndTime"];
            this.trpPlanRouteID = data["trpPlanRouteID"];
            this.calenderID = data["calenderID"];
            this.viwTripPlanedDaily = data["viwTripPlanedDaily"];
            this.catSedor = data["catSedor"];
            this.notes = data["notes"];
            this.busGroup = data["busGroup"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ViwTripPlanedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViwTripPlanedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trpPlanCalnderID"] = this.trpPlanCalnderID;
        data["trpPlanStartTime"] = this.trpPlanStartTime;
        data["trpPlanLineNumber"] = this.trpPlanLineNumber;
        data["trpPlanDirection"] = this.trpPlanDirection;
        data["trpPlanDriverName"] = this.trpPlanDriverName;
        data["trpPlanBusNumber"] = this.trpPlanBusNumber;
        data["tripMinistryID"] = this.tripMinistryID;
        data["tripMinistryLineNumber"] = this.tripMinistryLineNumber;
        data["tripMinistryDirection"] = this.tripMinistryDirection;
        data["tripMinistryCalenderID"] = this.tripMinistryCalenderID;
        data["tripMinistryTimeSpan"] = this.tripMinistryTimeSpan;
        data["tripMinistryMonday"] = this.tripMinistryMonday;
        data["tripMinistryTuesday"] = this.tripMinistryTuesday;
        data["tripMinistryWensday"] = this.tripMinistryWensday;
        data["tripMinistryFriday"] = this.tripMinistryFriday;
        data["tripMinistryThursday"] = this.tripMinistryThursday;
        data["tripMinistrySaturday"] = this.tripMinistrySaturday;
        data["tripMinistrySunday"] = this.tripMinistrySunday;
        data["tripMinistryStart_date"] = this.tripMinistryStart_date ? this.tripMinistryStart_date.toISOString() : <any>undefined;
        data["tripMinistryRouteID"] = this.tripMinistryRouteID;
        data["trpPlanmonday"] = this.trpPlanmonday;
        data["trpPlanTuesday"] = this.trpPlanTuesday;
        data["trpPlanWensday"] = this.trpPlanWensday;
        data["trpPlanthursday"] = this.trpPlanthursday;
        data["trpPlanfriday"] = this.trpPlanfriday;
        data["trpPlansaturday"] = this.trpPlansaturday;
        data["trpPlansunday"] = this.trpPlansunday;
        data["trpPlanStart_date"] = this.trpPlanStart_date ? this.trpPlanStart_date.toISOString() : <any>undefined;
        data["trpPlanEnd_date"] = this.trpPlanEnd_date ? this.trpPlanEnd_date.toISOString() : <any>undefined;
        data["trpPlanTaskNo"] = this.trpPlanTaskNo;
        data["tripPlanedID"] = this.tripPlanedID;
        data["driverIDPPlaned"] = this.driverIDPPlaned;
        data["busidPlanlned"] = this.busidPlanlned;
        data["trpPlanISValid"] = this.trpPlanISValid;
        data["trpPlanEndTime"] = this.trpPlanEndTime;
        data["trpPlanRouteID"] = this.trpPlanRouteID;
        data["calenderID"] = this.calenderID;
        data["viwTripPlanedDaily"] = this.viwTripPlanedDaily;
        data["catSedor"] = this.catSedor;
        data["notes"] = this.notes;
        data["busGroup"] = this.busGroup;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["id"] = this.id;
        return data; 
    }
}

export interface IViwTripPlanedDto {
    trpPlanCalnderID: number | undefined;
    trpPlanStartTime: string | undefined;
    trpPlanLineNumber: number | undefined;
    trpPlanDirection: number | undefined;
    trpPlanDriverName: string | undefined;
    trpPlanBusNumber: string | undefined;
    tripMinistryID: number | undefined;
    tripMinistryLineNumber: number | undefined;
    tripMinistryDirection: number | undefined;
    tripMinistryCalenderID: number | undefined;
    tripMinistryTimeSpan: string | undefined;
    tripMinistryMonday: boolean | undefined;
    tripMinistryTuesday: boolean | undefined;
    tripMinistryWensday: boolean | undefined;
    tripMinistryFriday: boolean | undefined;
    tripMinistryThursday: boolean | undefined;
    tripMinistrySaturday: boolean | undefined;
    tripMinistrySunday: boolean | undefined;
    tripMinistryStart_date: moment.Moment | undefined;
    tripMinistryRouteID: number | undefined;
    trpPlanmonday: boolean | undefined;
    trpPlanTuesday: boolean | undefined;
    trpPlanWensday: boolean | undefined;
    trpPlanthursday: boolean | undefined;
    trpPlanfriday: boolean | undefined;
    trpPlansaturday: boolean | undefined;
    trpPlansunday: boolean | undefined;
    trpPlanStart_date: moment.Moment | undefined;
    trpPlanEnd_date: moment.Moment | undefined;
    trpPlanTaskNo: number | undefined;
    tripPlanedID: number | undefined;
    driverIDPPlaned: number | undefined;
    busidPlanlned: number | undefined;
    trpPlanISValid: boolean | undefined;
    trpPlanEndTime: string | undefined;
    trpPlanRouteID: number | undefined;
    calenderID: number | undefined;
    viwTripPlanedDaily: number | undefined;
    catSedor: string | undefined;
    notes: string | undefined;
    busGroup: string | undefined;
    driver: number | undefined;
    busID: number | undefined;
    id: number | undefined;
}

export class GetViwTripPlanedForEditOutput implements IGetViwTripPlanedForEditOutput {
    viwTripPlaned!: CreateOrEditViwTripPlanedDto | undefined;

    constructor(data?: IGetViwTripPlanedForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.viwTripPlaned = data["viwTripPlaned"] ? CreateOrEditViwTripPlanedDto.fromJS(data["viwTripPlaned"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetViwTripPlanedForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetViwTripPlanedForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viwTripPlaned"] = this.viwTripPlaned ? this.viwTripPlaned.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetViwTripPlanedForEditOutput {
    viwTripPlaned: CreateOrEditViwTripPlanedDto | undefined;
}

export class CreateOrEditViwTripPlanedDto implements ICreateOrEditViwTripPlanedDto {
    trpPlanCalnderID!: number | undefined;
    trpPlanStartTime!: string | undefined;
    trpPlanLineNumber!: number | undefined;
    trpPlanDirection!: number | undefined;
    trpPlanDriverName!: string | undefined;
    trpPlanBusNumber!: string | undefined;
    tripMinistryID!: number | undefined;
    tripMinistryLineNumber!: number | undefined;
    tripMinistryDirection!: number | undefined;
    tripMinistryCalenderID!: number | undefined;
    tripMinistryTimeSpan!: string | undefined;
    tripMinistryMonday!: boolean | undefined;
    tripMinistryTuesday!: boolean | undefined;
    tripMinistryWensday!: boolean | undefined;
    tripMinistryFriday!: boolean | undefined;
    tripMinistryThursday!: boolean | undefined;
    tripMinistrySaturday!: boolean | undefined;
    tripMinistrySunday!: boolean | undefined;
    tripMinistryStart_date!: moment.Moment | undefined;
    tripMinistryRouteID!: number | undefined;
    trpPlanmonday!: boolean | undefined;
    trpPlanTuesday!: boolean | undefined;
    trpPlanWensday!: boolean | undefined;
    trpPlanthursday!: boolean | undefined;
    trpPlanfriday!: boolean | undefined;
    trpPlansaturday!: boolean | undefined;
    trpPlansunday!: boolean | undefined;
    trpPlanStart_date!: moment.Moment | undefined;
    trpPlanEnd_date!: moment.Moment | undefined;
    trpPlanTaskNo!: number | undefined;
    tripPlanedID!: number;
    driverIDPPlaned!: number | undefined;
    busidPlanlned!: number | undefined;
    trpPlanISValid!: boolean;
    trpPlanEndTime!: string | undefined;
    trpPlanRouteID!: number | undefined;
    calenderID!: number | undefined;
    viwTripPlanedDaily!: number | undefined;
    catSedor!: string;
    notes!: string | undefined;
    busGroup!: string | undefined;
    driver!: number | undefined;
    busID!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditViwTripPlanedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trpPlanCalnderID = data["trpPlanCalnderID"];
            this.trpPlanStartTime = data["trpPlanStartTime"];
            this.trpPlanLineNumber = data["trpPlanLineNumber"];
            this.trpPlanDirection = data["trpPlanDirection"];
            this.trpPlanDriverName = data["trpPlanDriverName"];
            this.trpPlanBusNumber = data["trpPlanBusNumber"];
            this.tripMinistryID = data["tripMinistryID"];
            this.tripMinistryLineNumber = data["tripMinistryLineNumber"];
            this.tripMinistryDirection = data["tripMinistryDirection"];
            this.tripMinistryCalenderID = data["tripMinistryCalenderID"];
            this.tripMinistryTimeSpan = data["tripMinistryTimeSpan"];
            this.tripMinistryMonday = data["tripMinistryMonday"];
            this.tripMinistryTuesday = data["tripMinistryTuesday"];
            this.tripMinistryWensday = data["tripMinistryWensday"];
            this.tripMinistryFriday = data["tripMinistryFriday"];
            this.tripMinistryThursday = data["tripMinistryThursday"];
            this.tripMinistrySaturday = data["tripMinistrySaturday"];
            this.tripMinistrySunday = data["tripMinistrySunday"];
            this.tripMinistryStart_date = data["tripMinistryStart_date"] ? moment(data["tripMinistryStart_date"].toString()) : <any>undefined;
            this.tripMinistryRouteID = data["tripMinistryRouteID"];
            this.trpPlanmonday = data["trpPlanmonday"];
            this.trpPlanTuesday = data["trpPlanTuesday"];
            this.trpPlanWensday = data["trpPlanWensday"];
            this.trpPlanthursday = data["trpPlanthursday"];
            this.trpPlanfriday = data["trpPlanfriday"];
            this.trpPlansaturday = data["trpPlansaturday"];
            this.trpPlansunday = data["trpPlansunday"];
            this.trpPlanStart_date = data["trpPlanStart_date"] ? moment(data["trpPlanStart_date"].toString()) : <any>undefined;
            this.trpPlanEnd_date = data["trpPlanEnd_date"] ? moment(data["trpPlanEnd_date"].toString()) : <any>undefined;
            this.trpPlanTaskNo = data["trpPlanTaskNo"];
            this.tripPlanedID = data["tripPlanedID"];
            this.driverIDPPlaned = data["driverIDPPlaned"];
            this.busidPlanlned = data["busidPlanlned"];
            this.trpPlanISValid = data["trpPlanISValid"];
            this.trpPlanEndTime = data["trpPlanEndTime"];
            this.trpPlanRouteID = data["trpPlanRouteID"];
            this.calenderID = data["calenderID"];
            this.viwTripPlanedDaily = data["viwTripPlanedDaily"];
            this.catSedor = data["catSedor"];
            this.notes = data["notes"];
            this.busGroup = data["busGroup"];
            this.driver = data["driver"];
            this.busID = data["busID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditViwTripPlanedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditViwTripPlanedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trpPlanCalnderID"] = this.trpPlanCalnderID;
        data["trpPlanStartTime"] = this.trpPlanStartTime;
        data["trpPlanLineNumber"] = this.trpPlanLineNumber;
        data["trpPlanDirection"] = this.trpPlanDirection;
        data["trpPlanDriverName"] = this.trpPlanDriverName;
        data["trpPlanBusNumber"] = this.trpPlanBusNumber;
        data["tripMinistryID"] = this.tripMinistryID;
        data["tripMinistryLineNumber"] = this.tripMinistryLineNumber;
        data["tripMinistryDirection"] = this.tripMinistryDirection;
        data["tripMinistryCalenderID"] = this.tripMinistryCalenderID;
        data["tripMinistryTimeSpan"] = this.tripMinistryTimeSpan;
        data["tripMinistryMonday"] = this.tripMinistryMonday;
        data["tripMinistryTuesday"] = this.tripMinistryTuesday;
        data["tripMinistryWensday"] = this.tripMinistryWensday;
        data["tripMinistryFriday"] = this.tripMinistryFriday;
        data["tripMinistryThursday"] = this.tripMinistryThursday;
        data["tripMinistrySaturday"] = this.tripMinistrySaturday;
        data["tripMinistrySunday"] = this.tripMinistrySunday;
        data["tripMinistryStart_date"] = this.tripMinistryStart_date ? this.tripMinistryStart_date.toISOString() : <any>undefined;
        data["tripMinistryRouteID"] = this.tripMinistryRouteID;
        data["trpPlanmonday"] = this.trpPlanmonday;
        data["trpPlanTuesday"] = this.trpPlanTuesday;
        data["trpPlanWensday"] = this.trpPlanWensday;
        data["trpPlanthursday"] = this.trpPlanthursday;
        data["trpPlanfriday"] = this.trpPlanfriday;
        data["trpPlansaturday"] = this.trpPlansaturday;
        data["trpPlansunday"] = this.trpPlansunday;
        data["trpPlanStart_date"] = this.trpPlanStart_date ? this.trpPlanStart_date.toISOString() : <any>undefined;
        data["trpPlanEnd_date"] = this.trpPlanEnd_date ? this.trpPlanEnd_date.toISOString() : <any>undefined;
        data["trpPlanTaskNo"] = this.trpPlanTaskNo;
        data["tripPlanedID"] = this.tripPlanedID;
        data["driverIDPPlaned"] = this.driverIDPPlaned;
        data["busidPlanlned"] = this.busidPlanlned;
        data["trpPlanISValid"] = this.trpPlanISValid;
        data["trpPlanEndTime"] = this.trpPlanEndTime;
        data["trpPlanRouteID"] = this.trpPlanRouteID;
        data["calenderID"] = this.calenderID;
        data["viwTripPlanedDaily"] = this.viwTripPlanedDaily;
        data["catSedor"] = this.catSedor;
        data["notes"] = this.notes;
        data["busGroup"] = this.busGroup;
        data["driver"] = this.driver;
        data["busID"] = this.busID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditViwTripPlanedDto {
    trpPlanCalnderID: number | undefined;
    trpPlanStartTime: string | undefined;
    trpPlanLineNumber: number | undefined;
    trpPlanDirection: number | undefined;
    trpPlanDriverName: string | undefined;
    trpPlanBusNumber: string | undefined;
    tripMinistryID: number | undefined;
    tripMinistryLineNumber: number | undefined;
    tripMinistryDirection: number | undefined;
    tripMinistryCalenderID: number | undefined;
    tripMinistryTimeSpan: string | undefined;
    tripMinistryMonday: boolean | undefined;
    tripMinistryTuesday: boolean | undefined;
    tripMinistryWensday: boolean | undefined;
    tripMinistryFriday: boolean | undefined;
    tripMinistryThursday: boolean | undefined;
    tripMinistrySaturday: boolean | undefined;
    tripMinistrySunday: boolean | undefined;
    tripMinistryStart_date: moment.Moment | undefined;
    tripMinistryRouteID: number | undefined;
    trpPlanmonday: boolean | undefined;
    trpPlanTuesday: boolean | undefined;
    trpPlanWensday: boolean | undefined;
    trpPlanthursday: boolean | undefined;
    trpPlanfriday: boolean | undefined;
    trpPlansaturday: boolean | undefined;
    trpPlansunday: boolean | undefined;
    trpPlanStart_date: moment.Moment | undefined;
    trpPlanEnd_date: moment.Moment | undefined;
    trpPlanTaskNo: number | undefined;
    tripPlanedID: number;
    driverIDPPlaned: number | undefined;
    busidPlanlned: number | undefined;
    trpPlanISValid: boolean;
    trpPlanEndTime: string | undefined;
    trpPlanRouteID: number | undefined;
    calenderID: number | undefined;
    viwTripPlanedDaily: number | undefined;
    catSedor: string;
    notes: string | undefined;
    busGroup: string | undefined;
    driver: number | undefined;
    busID: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfFilterReturnPlanByBus implements IPagedResultDtoOfFilterReturnPlanByBus {
    totalCount!: number | undefined;
    items!: FilterReturnPlanByBus[] | undefined;

    constructor(data?: IPagedResultDtoOfFilterReturnPlanByBus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FilterReturnPlanByBus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFilterReturnPlanByBus {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFilterReturnPlanByBus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfFilterReturnPlanByBus {
    totalCount: number | undefined;
    items: FilterReturnPlanByBus[] | undefined;
}

export class FilterReturnPlanByBus implements IFilterReturnPlanByBus {
    trpPlanBusNumber!: string | undefined;
    busGroup!: string | undefined;
    busID!: number | undefined;

    constructor(data?: IFilterReturnPlanByBus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trpPlanBusNumber = data["trpPlanBusNumber"];
            this.busGroup = data["busGroup"];
            this.busID = data["busID"];
        }
    }

    static fromJS(data: any): FilterReturnPlanByBus {
        data = typeof data === 'object' ? data : {};
        let result = new FilterReturnPlanByBus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trpPlanBusNumber"] = this.trpPlanBusNumber;
        data["busGroup"] = this.busGroup;
        data["busID"] = this.busID;
        return data; 
    }
}

export interface IFilterReturnPlanByBus {
    trpPlanBusNumber: string | undefined;
    busGroup: string | undefined;
    busID: number | undefined;
}

export class PagedResultDtoOfFilterReturnPlanByTaskno implements IPagedResultDtoOfFilterReturnPlanByTaskno {
    totalCount!: number | undefined;
    items!: FilterReturnPlanByTaskno[] | undefined;

    constructor(data?: IPagedResultDtoOfFilterReturnPlanByTaskno) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FilterReturnPlanByTaskno.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFilterReturnPlanByTaskno {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFilterReturnPlanByTaskno();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfFilterReturnPlanByTaskno {
    totalCount: number | undefined;
    items: FilterReturnPlanByTaskno[] | undefined;
}

export class FilterReturnPlanByTaskno implements IFilterReturnPlanByTaskno {
    trpPlanDriverName!: string | undefined;
    trpPlanBusNumber!: string | undefined;
    trpPlanTaskNo!: number | undefined;
    busGroup!: string | undefined;
    driverIDPPlaned!: number | undefined;
    busID!: number | undefined;

    constructor(data?: IFilterReturnPlanByTaskno) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trpPlanDriverName = data["trpPlanDriverName"];
            this.trpPlanBusNumber = data["trpPlanBusNumber"];
            this.trpPlanTaskNo = data["trpPlanTaskNo"];
            this.busGroup = data["busGroup"];
            this.driverIDPPlaned = data["driverIDPPlaned"];
            this.busID = data["busID"];
        }
    }

    static fromJS(data: any): FilterReturnPlanByTaskno {
        data = typeof data === 'object' ? data : {};
        let result = new FilterReturnPlanByTaskno();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trpPlanDriverName"] = this.trpPlanDriverName;
        data["trpPlanBusNumber"] = this.trpPlanBusNumber;
        data["trpPlanTaskNo"] = this.trpPlanTaskNo;
        data["busGroup"] = this.busGroup;
        data["driverIDPPlaned"] = this.driverIDPPlaned;
        data["busID"] = this.busID;
        return data; 
    }
}

export interface IFilterReturnPlanByTaskno {
    trpPlanDriverName: string | undefined;
    trpPlanBusNumber: string | undefined;
    trpPlanTaskNo: number | undefined;
    busGroup: string | undefined;
    driverIDPPlaned: number | undefined;
    busID: number | undefined;
}

export class PagedResultDtoOfGetViwTripPlanedDailyForView implements IPagedResultDtoOfGetViwTripPlanedDailyForView {
    totalCount!: number | undefined;
    items!: GetViwTripPlanedDailyForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetViwTripPlanedDailyForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetViwTripPlanedDailyForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetViwTripPlanedDailyForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetViwTripPlanedDailyForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetViwTripPlanedDailyForView {
    totalCount: number | undefined;
    items: GetViwTripPlanedDailyForView[] | undefined;
}

export class GetViwTripPlanedDailyForView implements IGetViwTripPlanedDailyForView {
    viwTripPlanedDaily!: ViwTripPlanedDailyDto | undefined;

    constructor(data?: IGetViwTripPlanedDailyForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.viwTripPlanedDaily = data["viwTripPlanedDaily"] ? ViwTripPlanedDailyDto.fromJS(data["viwTripPlanedDaily"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetViwTripPlanedDailyForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetViwTripPlanedDailyForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viwTripPlanedDaily"] = this.viwTripPlanedDaily ? this.viwTripPlanedDaily.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetViwTripPlanedDailyForView {
    viwTripPlanedDaily: ViwTripPlanedDailyDto | undefined;
}

export class ViwTripPlanedDailyDto implements IViwTripPlanedDailyDto {
    tripIDGTFS!: string | undefined;
    trpPlanBusNumber!: string | undefined;
    trpPlanCalnderID!: number | undefined;
    trpPlanStartTime!: string | undefined;
    trpPlanLineNumber!: number | undefined;
    trpPlanDirection!: number | undefined;
    trpPlanDriverName!: string | undefined;
    tripMinistryID!: number | undefined;
    tripMinistryLineNumber!: number | undefined;
    tripMinistryDirection!: number | undefined;
    tripMinistryCalenderID!: number | undefined;
    tripMinistryTimeSpan!: string | undefined;
    tripMinistryMonday!: boolean | undefined;
    tripMinistryTuesday!: boolean | undefined;
    tripMinistryWensday!: boolean | undefined;
    tripMinistryFriday!: boolean | undefined;
    tripMinistryThursday!: boolean | undefined;
    tripMinistrySaturday!: boolean | undefined;
    tripMinistrySunday!: boolean | undefined;
    tripMinistryStart_date!: moment.Moment | undefined;
    tripMinistryRouteID!: number | undefined;
    trpPlanmonday!: boolean | undefined;
    trpPlanTuesday!: boolean | undefined;
    trpPlanWensday!: boolean | undefined;
    trpPlanthursday!: boolean | undefined;
    trpPlanfriday!: boolean | undefined;
    trpPlansaturday!: boolean | undefined;
    trpPlansunday!: boolean | undefined;
    trpPlanStart_date!: moment.Moment | undefined;
    trpPlanEnd_date!: moment.Moment | undefined;
    trpPlanTaskNo!: number | undefined;
    tripPlanedID!: number | undefined;
    driverIDPPlaned!: number | undefined;
    busidPlanlned!: number | undefined;
    trpPlanISValid!: boolean | undefined;
    trpPlanEndTime!: string | undefined;
    trpPlanRouteID!: number | undefined;
    workingday!: moment.Moment | undefined;
    autran!: number | undefined;
    startLocationName!: string | undefined;
    startLocationNameHeb!: string | undefined;
    startLocationCode!: number | undefined;
    startLocationLatitude!: number | undefined;
    startLocationLongitude!: number | undefined;
    routeTotalKM!: number | undefined;
    routeTotalMinutes!: number | undefined;
    isMinistry!: string | undefined;
    busID!: number | undefined;
    routeIDGTFS!: string | undefined;
    controlStartTime!: string | undefined;
    tripTypesName!: string | undefined;
    busGroup!: string | undefined;
    driverOrginal!: number | undefined;
    busOrginal!: number | undefined;
    endLocationName!: string | undefined;
    endLocationNameHebrew!: string | undefined;
    endStationCode!: number | undefined;
    endLatitude!: number | undefined;
    endLongitude!: number | undefined;
    tripPlannedWothDriverID!: number | undefined;
    id!: number | undefined;

    constructor(data?: IViwTripPlanedDailyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripIDGTFS = data["tripIDGTFS"];
            this.trpPlanBusNumber = data["trpPlanBusNumber"];
            this.trpPlanCalnderID = data["trpPlanCalnderID"];
            this.trpPlanStartTime = data["trpPlanStartTime"];
            this.trpPlanLineNumber = data["trpPlanLineNumber"];
            this.trpPlanDirection = data["trpPlanDirection"];
            this.trpPlanDriverName = data["trpPlanDriverName"];
            this.tripMinistryID = data["tripMinistryID"];
            this.tripMinistryLineNumber = data["tripMinistryLineNumber"];
            this.tripMinistryDirection = data["tripMinistryDirection"];
            this.tripMinistryCalenderID = data["tripMinistryCalenderID"];
            this.tripMinistryTimeSpan = data["tripMinistryTimeSpan"];
            this.tripMinistryMonday = data["tripMinistryMonday"];
            this.tripMinistryTuesday = data["tripMinistryTuesday"];
            this.tripMinistryWensday = data["tripMinistryWensday"];
            this.tripMinistryFriday = data["tripMinistryFriday"];
            this.tripMinistryThursday = data["tripMinistryThursday"];
            this.tripMinistrySaturday = data["tripMinistrySaturday"];
            this.tripMinistrySunday = data["tripMinistrySunday"];
            this.tripMinistryStart_date = data["tripMinistryStart_date"] ? moment(data["tripMinistryStart_date"].toString()) : <any>undefined;
            this.tripMinistryRouteID = data["tripMinistryRouteID"];
            this.trpPlanmonday = data["trpPlanmonday"];
            this.trpPlanTuesday = data["trpPlanTuesday"];
            this.trpPlanWensday = data["trpPlanWensday"];
            this.trpPlanthursday = data["trpPlanthursday"];
            this.trpPlanfriday = data["trpPlanfriday"];
            this.trpPlansaturday = data["trpPlansaturday"];
            this.trpPlansunday = data["trpPlansunday"];
            this.trpPlanStart_date = data["trpPlanStart_date"] ? moment(data["trpPlanStart_date"].toString()) : <any>undefined;
            this.trpPlanEnd_date = data["trpPlanEnd_date"] ? moment(data["trpPlanEnd_date"].toString()) : <any>undefined;
            this.trpPlanTaskNo = data["trpPlanTaskNo"];
            this.tripPlanedID = data["tripPlanedID"];
            this.driverIDPPlaned = data["driverIDPPlaned"];
            this.busidPlanlned = data["busidPlanlned"];
            this.trpPlanISValid = data["trpPlanISValid"];
            this.trpPlanEndTime = data["trpPlanEndTime"];
            this.trpPlanRouteID = data["trpPlanRouteID"];
            this.workingday = data["workingday"] ? moment(data["workingday"].toString()) : <any>undefined;
            this.autran = data["autran"];
            this.startLocationName = data["startLocationName"];
            this.startLocationNameHeb = data["startLocationNameHeb"];
            this.startLocationCode = data["startLocationCode"];
            this.startLocationLatitude = data["startLocationLatitude"];
            this.startLocationLongitude = data["startLocationLongitude"];
            this.routeTotalKM = data["routeTotalKM"];
            this.routeTotalMinutes = data["routeTotalMinutes"];
            this.isMinistry = data["isMinistry"];
            this.busID = data["busID"];
            this.routeIDGTFS = data["routeIDGTFS"];
            this.controlStartTime = data["controlStartTime"];
            this.tripTypesName = data["tripTypesName"];
            this.busGroup = data["busGroup"];
            this.driverOrginal = data["driverOrginal"];
            this.busOrginal = data["busOrginal"];
            this.endLocationName = data["endLocationName"];
            this.endLocationNameHebrew = data["endLocationNameHebrew"];
            this.endStationCode = data["endStationCode"];
            this.endLatitude = data["endLatitude"];
            this.endLongitude = data["endLongitude"];
            this.tripPlannedWothDriverID = data["tripPlannedWothDriverID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ViwTripPlanedDailyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ViwTripPlanedDailyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripIDGTFS"] = this.tripIDGTFS;
        data["trpPlanBusNumber"] = this.trpPlanBusNumber;
        data["trpPlanCalnderID"] = this.trpPlanCalnderID;
        data["trpPlanStartTime"] = this.trpPlanStartTime;
        data["trpPlanLineNumber"] = this.trpPlanLineNumber;
        data["trpPlanDirection"] = this.trpPlanDirection;
        data["trpPlanDriverName"] = this.trpPlanDriverName;
        data["tripMinistryID"] = this.tripMinistryID;
        data["tripMinistryLineNumber"] = this.tripMinistryLineNumber;
        data["tripMinistryDirection"] = this.tripMinistryDirection;
        data["tripMinistryCalenderID"] = this.tripMinistryCalenderID;
        data["tripMinistryTimeSpan"] = this.tripMinistryTimeSpan;
        data["tripMinistryMonday"] = this.tripMinistryMonday;
        data["tripMinistryTuesday"] = this.tripMinistryTuesday;
        data["tripMinistryWensday"] = this.tripMinistryWensday;
        data["tripMinistryFriday"] = this.tripMinistryFriday;
        data["tripMinistryThursday"] = this.tripMinistryThursday;
        data["tripMinistrySaturday"] = this.tripMinistrySaturday;
        data["tripMinistrySunday"] = this.tripMinistrySunday;
        data["tripMinistryStart_date"] = this.tripMinistryStart_date ? this.tripMinistryStart_date.toISOString() : <any>undefined;
        data["tripMinistryRouteID"] = this.tripMinistryRouteID;
        data["trpPlanmonday"] = this.trpPlanmonday;
        data["trpPlanTuesday"] = this.trpPlanTuesday;
        data["trpPlanWensday"] = this.trpPlanWensday;
        data["trpPlanthursday"] = this.trpPlanthursday;
        data["trpPlanfriday"] = this.trpPlanfriday;
        data["trpPlansaturday"] = this.trpPlansaturday;
        data["trpPlansunday"] = this.trpPlansunday;
        data["trpPlanStart_date"] = this.trpPlanStart_date ? this.trpPlanStart_date.toISOString() : <any>undefined;
        data["trpPlanEnd_date"] = this.trpPlanEnd_date ? this.trpPlanEnd_date.toISOString() : <any>undefined;
        data["trpPlanTaskNo"] = this.trpPlanTaskNo;
        data["tripPlanedID"] = this.tripPlanedID;
        data["driverIDPPlaned"] = this.driverIDPPlaned;
        data["busidPlanlned"] = this.busidPlanlned;
        data["trpPlanISValid"] = this.trpPlanISValid;
        data["trpPlanEndTime"] = this.trpPlanEndTime;
        data["trpPlanRouteID"] = this.trpPlanRouteID;
        data["workingday"] = this.workingday ? this.workingday.toISOString() : <any>undefined;
        data["autran"] = this.autran;
        data["startLocationName"] = this.startLocationName;
        data["startLocationNameHeb"] = this.startLocationNameHeb;
        data["startLocationCode"] = this.startLocationCode;
        data["startLocationLatitude"] = this.startLocationLatitude;
        data["startLocationLongitude"] = this.startLocationLongitude;
        data["routeTotalKM"] = this.routeTotalKM;
        data["routeTotalMinutes"] = this.routeTotalMinutes;
        data["isMinistry"] = this.isMinistry;
        data["busID"] = this.busID;
        data["routeIDGTFS"] = this.routeIDGTFS;
        data["controlStartTime"] = this.controlStartTime;
        data["tripTypesName"] = this.tripTypesName;
        data["busGroup"] = this.busGroup;
        data["driverOrginal"] = this.driverOrginal;
        data["busOrginal"] = this.busOrginal;
        data["endLocationName"] = this.endLocationName;
        data["endLocationNameHebrew"] = this.endLocationNameHebrew;
        data["endStationCode"] = this.endStationCode;
        data["endLatitude"] = this.endLatitude;
        data["endLongitude"] = this.endLongitude;
        data["tripPlannedWothDriverID"] = this.tripPlannedWothDriverID;
        data["id"] = this.id;
        return data; 
    }
}

export interface IViwTripPlanedDailyDto {
    tripIDGTFS: string | undefined;
    trpPlanBusNumber: string | undefined;
    trpPlanCalnderID: number | undefined;
    trpPlanStartTime: string | undefined;
    trpPlanLineNumber: number | undefined;
    trpPlanDirection: number | undefined;
    trpPlanDriverName: string | undefined;
    tripMinistryID: number | undefined;
    tripMinistryLineNumber: number | undefined;
    tripMinistryDirection: number | undefined;
    tripMinistryCalenderID: number | undefined;
    tripMinistryTimeSpan: string | undefined;
    tripMinistryMonday: boolean | undefined;
    tripMinistryTuesday: boolean | undefined;
    tripMinistryWensday: boolean | undefined;
    tripMinistryFriday: boolean | undefined;
    tripMinistryThursday: boolean | undefined;
    tripMinistrySaturday: boolean | undefined;
    tripMinistrySunday: boolean | undefined;
    tripMinistryStart_date: moment.Moment | undefined;
    tripMinistryRouteID: number | undefined;
    trpPlanmonday: boolean | undefined;
    trpPlanTuesday: boolean | undefined;
    trpPlanWensday: boolean | undefined;
    trpPlanthursday: boolean | undefined;
    trpPlanfriday: boolean | undefined;
    trpPlansaturday: boolean | undefined;
    trpPlansunday: boolean | undefined;
    trpPlanStart_date: moment.Moment | undefined;
    trpPlanEnd_date: moment.Moment | undefined;
    trpPlanTaskNo: number | undefined;
    tripPlanedID: number | undefined;
    driverIDPPlaned: number | undefined;
    busidPlanlned: number | undefined;
    trpPlanISValid: boolean | undefined;
    trpPlanEndTime: string | undefined;
    trpPlanRouteID: number | undefined;
    workingday: moment.Moment | undefined;
    autran: number | undefined;
    startLocationName: string | undefined;
    startLocationNameHeb: string | undefined;
    startLocationCode: number | undefined;
    startLocationLatitude: number | undefined;
    startLocationLongitude: number | undefined;
    routeTotalKM: number | undefined;
    routeTotalMinutes: number | undefined;
    isMinistry: string | undefined;
    busID: number | undefined;
    routeIDGTFS: string | undefined;
    controlStartTime: string | undefined;
    tripTypesName: string | undefined;
    busGroup: string | undefined;
    driverOrginal: number | undefined;
    busOrginal: number | undefined;
    endLocationName: string | undefined;
    endLocationNameHebrew: string | undefined;
    endStationCode: number | undefined;
    endLatitude: number | undefined;
    endLongitude: number | undefined;
    tripPlannedWothDriverID: number | undefined;
    id: number | undefined;
}

export class GetViwTripPlanedDailyForEditOutput implements IGetViwTripPlanedDailyForEditOutput {
    viwTripPlanedDaily!: CreateOrEditViwTripPlanedDailyDto | undefined;

    constructor(data?: IGetViwTripPlanedDailyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.viwTripPlanedDaily = data["viwTripPlanedDaily"] ? CreateOrEditViwTripPlanedDailyDto.fromJS(data["viwTripPlanedDaily"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetViwTripPlanedDailyForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetViwTripPlanedDailyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viwTripPlanedDaily"] = this.viwTripPlanedDaily ? this.viwTripPlanedDaily.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetViwTripPlanedDailyForEditOutput {
    viwTripPlanedDaily: CreateOrEditViwTripPlanedDailyDto | undefined;
}

export class CreateOrEditViwTripPlanedDailyDto implements ICreateOrEditViwTripPlanedDailyDto {
    tripIDGTFS!: string | undefined;
    trpPlanBusNumber!: string | undefined;
    trpPlanCalnderID!: number | undefined;
    trpPlanStartTime!: string | undefined;
    trpPlanLineNumber!: number;
    trpPlanDirection!: number;
    trpPlanDriverName!: string | undefined;
    tripMinistryID!: number | undefined;
    tripMinistryLineNumber!: number | undefined;
    tripMinistryDirection!: number | undefined;
    tripMinistryCalenderID!: number | undefined;
    tripMinistryTimeSpan!: string | undefined;
    tripMinistryMonday!: boolean | undefined;
    tripMinistryTuesday!: boolean | undefined;
    tripMinistryWensday!: boolean | undefined;
    tripMinistryFriday!: boolean | undefined;
    tripMinistryThursday!: boolean | undefined;
    tripMinistrySaturday!: boolean | undefined;
    tripMinistrySunday!: boolean | undefined;
    tripMinistryStart_date!: moment.Moment | undefined;
    tripMinistryRouteID!: number | undefined;
    trpPlanmonday!: boolean | undefined;
    trpPlanTuesday!: boolean | undefined;
    trpPlanWensday!: boolean | undefined;
    trpPlanthursday!: boolean | undefined;
    trpPlanfriday!: boolean | undefined;
    trpPlansaturday!: boolean | undefined;
    trpPlansunday!: boolean | undefined;
    trpPlanStart_date!: moment.Moment | undefined;
    trpPlanEnd_date!: moment.Moment | undefined;
    trpPlanTaskNo!: number;
    tripPlanedID!: number;
    driverIDPPlaned!: number | undefined;
    busidPlanlned!: number | undefined;
    trpPlanISValid!: boolean;
    trpPlanEndTime!: string | undefined;
    trpPlanRouteID!: number | undefined;
    workingday!: moment.Moment | undefined;
    autran!: number | undefined;
    startLocationName!: string | undefined;
    startLocationNameHeb!: string | undefined;
    startLocationCode!: number | undefined;
    startLocationLatitude!: number | undefined;
    startLocationLongitude!: number | undefined;
    routeTotalKM!: number | undefined;
    routeTotalMinutes!: number | undefined;
    isMinistry!: string;
    busID!: number | undefined;
    routeIDGTFS!: string | undefined;
    controlStartTime!: string | undefined;
    tripTypesName!: string;
    busGroup!: string | undefined;
    driverOrginal!: number | undefined;
    busOrginal!: number | undefined;
    endLocationName!: string | undefined;
    endLocationNameHebrew!: string | undefined;
    endStationCode!: number | undefined;
    endLatitude!: number | undefined;
    endLongitude!: number | undefined;
    tripPlannedWothDriverID!: number;
    id!: number | undefined;

    constructor(data?: ICreateOrEditViwTripPlanedDailyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tripIDGTFS = data["tripIDGTFS"];
            this.trpPlanBusNumber = data["trpPlanBusNumber"];
            this.trpPlanCalnderID = data["trpPlanCalnderID"];
            this.trpPlanStartTime = data["trpPlanStartTime"];
            this.trpPlanLineNumber = data["trpPlanLineNumber"];
            this.trpPlanDirection = data["trpPlanDirection"];
            this.trpPlanDriverName = data["trpPlanDriverName"];
            this.tripMinistryID = data["tripMinistryID"];
            this.tripMinistryLineNumber = data["tripMinistryLineNumber"];
            this.tripMinistryDirection = data["tripMinistryDirection"];
            this.tripMinistryCalenderID = data["tripMinistryCalenderID"];
            this.tripMinistryTimeSpan = data["tripMinistryTimeSpan"];
            this.tripMinistryMonday = data["tripMinistryMonday"];
            this.tripMinistryTuesday = data["tripMinistryTuesday"];
            this.tripMinistryWensday = data["tripMinistryWensday"];
            this.tripMinistryFriday = data["tripMinistryFriday"];
            this.tripMinistryThursday = data["tripMinistryThursday"];
            this.tripMinistrySaturday = data["tripMinistrySaturday"];
            this.tripMinistrySunday = data["tripMinistrySunday"];
            this.tripMinistryStart_date = data["tripMinistryStart_date"] ? moment(data["tripMinistryStart_date"].toString()) : <any>undefined;
            this.tripMinistryRouteID = data["tripMinistryRouteID"];
            this.trpPlanmonday = data["trpPlanmonday"];
            this.trpPlanTuesday = data["trpPlanTuesday"];
            this.trpPlanWensday = data["trpPlanWensday"];
            this.trpPlanthursday = data["trpPlanthursday"];
            this.trpPlanfriday = data["trpPlanfriday"];
            this.trpPlansaturday = data["trpPlansaturday"];
            this.trpPlansunday = data["trpPlansunday"];
            this.trpPlanStart_date = data["trpPlanStart_date"] ? moment(data["trpPlanStart_date"].toString()) : <any>undefined;
            this.trpPlanEnd_date = data["trpPlanEnd_date"] ? moment(data["trpPlanEnd_date"].toString()) : <any>undefined;
            this.trpPlanTaskNo = data["trpPlanTaskNo"];
            this.tripPlanedID = data["tripPlanedID"];
            this.driverIDPPlaned = data["driverIDPPlaned"];
            this.busidPlanlned = data["busidPlanlned"];
            this.trpPlanISValid = data["trpPlanISValid"];
            this.trpPlanEndTime = data["trpPlanEndTime"];
            this.trpPlanRouteID = data["trpPlanRouteID"];
            this.workingday = data["workingday"] ? moment(data["workingday"].toString()) : <any>undefined;
            this.autran = data["autran"];
            this.startLocationName = data["startLocationName"];
            this.startLocationNameHeb = data["startLocationNameHeb"];
            this.startLocationCode = data["startLocationCode"];
            this.startLocationLatitude = data["startLocationLatitude"];
            this.startLocationLongitude = data["startLocationLongitude"];
            this.routeTotalKM = data["routeTotalKM"];
            this.routeTotalMinutes = data["routeTotalMinutes"];
            this.isMinistry = data["isMinistry"];
            this.busID = data["busID"];
            this.routeIDGTFS = data["routeIDGTFS"];
            this.controlStartTime = data["controlStartTime"];
            this.tripTypesName = data["tripTypesName"];
            this.busGroup = data["busGroup"];
            this.driverOrginal = data["driverOrginal"];
            this.busOrginal = data["busOrginal"];
            this.endLocationName = data["endLocationName"];
            this.endLocationNameHebrew = data["endLocationNameHebrew"];
            this.endStationCode = data["endStationCode"];
            this.endLatitude = data["endLatitude"];
            this.endLongitude = data["endLongitude"];
            this.tripPlannedWothDriverID = data["tripPlannedWothDriverID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditViwTripPlanedDailyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditViwTripPlanedDailyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tripIDGTFS"] = this.tripIDGTFS;
        data["trpPlanBusNumber"] = this.trpPlanBusNumber;
        data["trpPlanCalnderID"] = this.trpPlanCalnderID;
        data["trpPlanStartTime"] = this.trpPlanStartTime;
        data["trpPlanLineNumber"] = this.trpPlanLineNumber;
        data["trpPlanDirection"] = this.trpPlanDirection;
        data["trpPlanDriverName"] = this.trpPlanDriverName;
        data["tripMinistryID"] = this.tripMinistryID;
        data["tripMinistryLineNumber"] = this.tripMinistryLineNumber;
        data["tripMinistryDirection"] = this.tripMinistryDirection;
        data["tripMinistryCalenderID"] = this.tripMinistryCalenderID;
        data["tripMinistryTimeSpan"] = this.tripMinistryTimeSpan;
        data["tripMinistryMonday"] = this.tripMinistryMonday;
        data["tripMinistryTuesday"] = this.tripMinistryTuesday;
        data["tripMinistryWensday"] = this.tripMinistryWensday;
        data["tripMinistryFriday"] = this.tripMinistryFriday;
        data["tripMinistryThursday"] = this.tripMinistryThursday;
        data["tripMinistrySaturday"] = this.tripMinistrySaturday;
        data["tripMinistrySunday"] = this.tripMinistrySunday;
        data["tripMinistryStart_date"] = this.tripMinistryStart_date ? this.tripMinistryStart_date.toISOString() : <any>undefined;
        data["tripMinistryRouteID"] = this.tripMinistryRouteID;
        data["trpPlanmonday"] = this.trpPlanmonday;
        data["trpPlanTuesday"] = this.trpPlanTuesday;
        data["trpPlanWensday"] = this.trpPlanWensday;
        data["trpPlanthursday"] = this.trpPlanthursday;
        data["trpPlanfriday"] = this.trpPlanfriday;
        data["trpPlansaturday"] = this.trpPlansaturday;
        data["trpPlansunday"] = this.trpPlansunday;
        data["trpPlanStart_date"] = this.trpPlanStart_date ? this.trpPlanStart_date.toISOString() : <any>undefined;
        data["trpPlanEnd_date"] = this.trpPlanEnd_date ? this.trpPlanEnd_date.toISOString() : <any>undefined;
        data["trpPlanTaskNo"] = this.trpPlanTaskNo;
        data["tripPlanedID"] = this.tripPlanedID;
        data["driverIDPPlaned"] = this.driverIDPPlaned;
        data["busidPlanlned"] = this.busidPlanlned;
        data["trpPlanISValid"] = this.trpPlanISValid;
        data["trpPlanEndTime"] = this.trpPlanEndTime;
        data["trpPlanRouteID"] = this.trpPlanRouteID;
        data["workingday"] = this.workingday ? this.workingday.toISOString() : <any>undefined;
        data["autran"] = this.autran;
        data["startLocationName"] = this.startLocationName;
        data["startLocationNameHeb"] = this.startLocationNameHeb;
        data["startLocationCode"] = this.startLocationCode;
        data["startLocationLatitude"] = this.startLocationLatitude;
        data["startLocationLongitude"] = this.startLocationLongitude;
        data["routeTotalKM"] = this.routeTotalKM;
        data["routeTotalMinutes"] = this.routeTotalMinutes;
        data["isMinistry"] = this.isMinistry;
        data["busID"] = this.busID;
        data["routeIDGTFS"] = this.routeIDGTFS;
        data["controlStartTime"] = this.controlStartTime;
        data["tripTypesName"] = this.tripTypesName;
        data["busGroup"] = this.busGroup;
        data["driverOrginal"] = this.driverOrginal;
        data["busOrginal"] = this.busOrginal;
        data["endLocationName"] = this.endLocationName;
        data["endLocationNameHebrew"] = this.endLocationNameHebrew;
        data["endStationCode"] = this.endStationCode;
        data["endLatitude"] = this.endLatitude;
        data["endLongitude"] = this.endLongitude;
        data["tripPlannedWothDriverID"] = this.tripPlannedWothDriverID;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditViwTripPlanedDailyDto {
    tripIDGTFS: string | undefined;
    trpPlanBusNumber: string | undefined;
    trpPlanCalnderID: number | undefined;
    trpPlanStartTime: string | undefined;
    trpPlanLineNumber: number;
    trpPlanDirection: number;
    trpPlanDriverName: string | undefined;
    tripMinistryID: number | undefined;
    tripMinistryLineNumber: number | undefined;
    tripMinistryDirection: number | undefined;
    tripMinistryCalenderID: number | undefined;
    tripMinistryTimeSpan: string | undefined;
    tripMinistryMonday: boolean | undefined;
    tripMinistryTuesday: boolean | undefined;
    tripMinistryWensday: boolean | undefined;
    tripMinistryFriday: boolean | undefined;
    tripMinistryThursday: boolean | undefined;
    tripMinistrySaturday: boolean | undefined;
    tripMinistrySunday: boolean | undefined;
    tripMinistryStart_date: moment.Moment | undefined;
    tripMinistryRouteID: number | undefined;
    trpPlanmonday: boolean | undefined;
    trpPlanTuesday: boolean | undefined;
    trpPlanWensday: boolean | undefined;
    trpPlanthursday: boolean | undefined;
    trpPlanfriday: boolean | undefined;
    trpPlansaturday: boolean | undefined;
    trpPlansunday: boolean | undefined;
    trpPlanStart_date: moment.Moment | undefined;
    trpPlanEnd_date: moment.Moment | undefined;
    trpPlanTaskNo: number;
    tripPlanedID: number;
    driverIDPPlaned: number | undefined;
    busidPlanlned: number | undefined;
    trpPlanISValid: boolean;
    trpPlanEndTime: string | undefined;
    trpPlanRouteID: number | undefined;
    workingday: moment.Moment | undefined;
    autran: number | undefined;
    startLocationName: string | undefined;
    startLocationNameHeb: string | undefined;
    startLocationCode: number | undefined;
    startLocationLatitude: number | undefined;
    startLocationLongitude: number | undefined;
    routeTotalKM: number | undefined;
    routeTotalMinutes: number | undefined;
    isMinistry: string;
    busID: number | undefined;
    routeIDGTFS: string | undefined;
    controlStartTime: string | undefined;
    tripTypesName: string;
    busGroup: string | undefined;
    driverOrginal: number | undefined;
    busOrginal: number | undefined;
    endLocationName: string | undefined;
    endLocationNameHebrew: string | undefined;
    endStationCode: number | undefined;
    endLatitude: number | undefined;
    endLongitude: number | undefined;
    tripPlannedWothDriverID: number;
    id: number | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string] : string; } | undefined;
    stripe!: { [key: string] : string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
    stripe: { [key: string] : string; } | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}